// -----------------------------------------------------------------------------------------------------------
// Copyright (C) AVIN SYSTEMS PVT LTD 2021 - All Rights Reserved Reproduction, distribution and utilization
// of this document as well as the communication of its contents to others without explicit authorization is
// prohibited. Offenders will be held liable for the payment of damages.
// -----------------------------------------------------------------------------------------------------------
// File Name   : adapter_x509provider.cpp
//
// Purpose     : Implementation of file adapter_x509provider.cpp
// -----------------------------------------------------------------------------------------------------------
// CODE GENERATED BY        : CM Code Generator
//
// CODE GENERATOR VERSION   : 1.4.0.A-006
//
// GENERATED ON             : 2022-02-07T12:05:52+05:30
// -----------------------------------------------------------------------------------------------------------

#include "adapter_x509provider.h"
namespace ara
{
namespace crypto
{
namespace ipccom
{
namespace x509
{
namespace x509provider_binding
{
namespace vsomeip
{

X509ProviderServiceAdapter::~X509ProviderServiceAdapter() noexcept {
  StopOfferService(ServiceDescriptor::service_id, GetInstanceId());
  UnregisterMethodDispatcher(ServiceDescriptor::service_id);
  Disconnect(dynamic_cast<ServiceInterface&>(service_));
}

void X509ProviderServiceAdapter::DispatchMethodCall(const std::shared_ptr<::vsomeip::message>& msg)
{
  ServiceInterface& service{dynamic_cast<ServiceInterface&>(service_)};
  switch(msg->get_method()) {
    case descriptors::BuildDn::method_id:
      HandleCall(service, &ServiceInterface::BuildDn, msg);
    break;
    case descriptors::CheckCertStatus::method_id:
      HandleCall(service, &ServiceInterface::CheckCertStatus, msg);
    break;
    case descriptors::CheckCertStatusWithCertList::method_id:
      HandleCall(service, &ServiceInterface::CheckCertStatusWithCertList, msg);
    break;
    case descriptors::CleanupVolatileStorage::method_id:
      HandleCall(service, &ServiceInterface::CleanupVolatileStorage, msg);
    break;
    case descriptors::CountCertsInChain::method_id:
      HandleCall(service, &ServiceInterface::CountCertsInChain, msg);
    break;
    case descriptors::CreateCertSignRequest::method_id:
      HandleCall(service, &ServiceInterface::CreateCertSignRequest, msg);
    break;
    case descriptors::CreateEmptyDn::method_id:
      HandleCall(service, &ServiceInterface::CreateEmptyDn, msg);
    break;
    case descriptors::CreateEmptyExtensions::method_id:
      HandleCall(service, &ServiceInterface::CreateEmptyExtensions, msg);
    break;
    case descriptors::CreateOcspRequest::method_id:
      HandleCall(service, &ServiceInterface::CreateOcspRequest, msg);
    break;
    case descriptors::CreateOcspRequestWithCertList::method_id:
      HandleCall(service, &ServiceInterface::CreateOcspRequestWithCertList, msg);
    break;
    case descriptors::DecodeDn::method_id:
      HandleCall(service, &ServiceInterface::DecodeDn, msg);
    break;
    case descriptors::FindCertByDn::method_id:
      HandleCall(service, &ServiceInterface::FindCertByDn, msg);
    break;
    case descriptors::FindCertByKeyIds::method_id:
      HandleCall(service, &ServiceInterface::FindCertByKeyIds, msg);
    break;
    case descriptors::FindCertBySn::method_id:
      HandleCall(service, &ServiceInterface::FindCertBySn, msg);
    break;
    case descriptors::Import::method_id:
      HandleCall(service, &ServiceInterface::Import, msg);
    break;
    case descriptors::ImportCrl::method_id:
      HandleCall(service, &ServiceInterface::ImportCrl, msg);
    break;
    case descriptors::LoadCertificate::method_id:
      HandleCall(service, &ServiceInterface::LoadCertificate, msg);
    break;
    case descriptors::ParseCert::method_id:
      HandleCall(service, &ServiceInterface::ParseCert, msg);
    break;
    case descriptors::ParseCertChain::method_id:
      HandleCall(service, &ServiceInterface::ParseCertChain, msg);
    break;
    case descriptors::ParseCertChainVectorReadOnlyMemRegion::method_id:
      HandleCall(service, &ServiceInterface::ParseCertChainVectorReadOnlyMemRegion, msg);
    break;
    case descriptors::ParseCertSignRequest::method_id:
      HandleCall(service, &ServiceInterface::ParseCertSignRequest, msg);
    break;
    case descriptors::ParseOcspResponse::method_id:
      HandleCall(service, &ServiceInterface::ParseOcspResponse, msg);
    break;
    case descriptors::Remove::method_id:
      HandleCall(service, &ServiceInterface::Remove, msg);
    break;
    case descriptors::SetAsRootOfTrust::method_id:
      HandleCall(service, &ServiceInterface::SetAsRootOfTrust, msg);
    break;
    case descriptors::SetPendingStatus::method_id:
      HandleCall(service, &ServiceInterface::SetPendingStatus, msg);
    break;
    case descriptors::VerifyCert::method_id:
      HandleCall(service, &ServiceInterface::VerifyCert, msg);
    break;
    case descriptors::VerifyCertChain::method_id:
      HandleCall(service, &ServiceInterface::VerifyCertChain, msg);
    break;
    default:
    // Avoid Warning.
    break;
  }
}

void X509ProviderServiceAdapter::Connect(ServiceInterface& service) {
  service.AddDelegate(*this);
}

void X509ProviderServiceAdapter::Disconnect(ServiceInterface& service) {
  service.RemoveDelegate(*this);
}

void X509ProviderServiceAdapter::SendInitialNotification(ServiceInterface& service) {
}

} // namespace vsomeip
} // namespace x509provider_binding
} // namespace x509
} // namespace ipccom
} // namespace crypto
} // namespace ara


