
\begin{DoxyItemize}
\item \hyperlink{adaptive_platform_introduction}{Introduction to Adaptive Platform}
\item \hyperlink{adaptive_communicationmanagement}{Communication Management}
\item \hyperlink{adaptive_executionmanagement}{Execution Management}
\item \hyperlink{adaptive_configurationmethodology}{Configuration Methodology}
\item \hyperlink{adaptive_state_manager}{State Manager}
\item \hyperlink{Guideline_Document_for_Platform_Health_Management}{Platform Health Management}
\item \hyperlink{Performance_parameter}{Performance Parameter} 
\end{DoxyItemize}\hypertarget{adaptive_platform_introduction}{}\section{Introduction to Adaptive Platform}\label{adaptive_platform_introduction}
To understand, why we need an Adaptive Platform, let\textquotesingle{}s start to understand current {\bfseries In-\/\+Vehicle Network Infrastructure}. Current generation E\+C\+Us mainly implement functionality that replaces or augments electromechanical systems. Software in those deeply-\/embedded E\+C\+Us, controls electrical output signals based on input signals and information from other E\+C\+Us connected to vehicle network. Much of the control software is designed and implemented for the target vehicle and does not change fundamentally during vehicle life-\/time. 
\begin{DoxyItemize}
\item Deeply Embedded with real time, safe and secure system
\item Static Network Configuration
\item Static deployment of Application S\+W\+Cs
\item Low Computing Power
\item Not scalable, Limited Bandwidth
\item No standardized solution available for fail operational systems and updates over the air
\end{DoxyItemize}

Future vehicle functions/applications such as Autonomous Car, Car-\/2-\/X, software updates over the air, or vehicles as part of the IoT, will introduce highly complex and computing resource demanding software into the vehicles and must fulfill strict integrity and security requirements. Such software realizes functions, such as environment perception, behavior planning, integrates the vehicle into external backend and infrastructure systems. The software in the vehicle needs to be changed during the life cycle of the vehicle, due to evolving external systems or improved functionality. However, the generic automotive M\+C\+Us of today are not focused on high-\/performance and are therefore not capable of handling such tasks. A trend towards having a larger, central and more computational heavy core can be seen, making high-\/performance hardware an interesting option. This compels A\+U\+T\+O\+S\+AR to adopt the idea of utilizing either V\+Ms or more powerful hardware. The A\+U\+T\+O\+S\+AR Classic Platform (CP) standard addresses the needs of deeply-\/embedded E\+C\+Us, while the needs of E\+C\+Us described above cannot be fulfilled well. Therefore, A\+U\+T\+O\+S\+AR specifies a second software platform, the A\+U\+T\+O\+S\+AR Adaptive Platform (AP). AP provides mainly high-\/performance computing and communication mechanisms and offers flexible software configuration, e.\+g. to support software update over-\/the-\/air.  {\bfseries Comparison between A\+U\+T\+O\+S\+AR Classic Platform and Adaptive Platform}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Classic Platform }&\textbf{ Adaptive Platform  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Classic Platform }&\textbf{ Adaptive Platform  }\\\cline{1-2}
\endhead
Based on O\+S\+EK OS (Real time Embedded System) and Generally Developed in “\+C” &Based on P\+O\+S\+IX (P\+S\+E51 – Minimal Real time Embedded System) and Developed in C++ \\\cline{1-2}
Signal based communication &Service based communication \\\cline{1-2}
Static Network, Task and Application S\+WC Configuration and Scheduling Strategy. Whole Stack compiled and linked to generate the full target image for the hardware &Thread and not runnable based communication, Flexible Configuration, Dynamic Deployment of new functionalities without the need to generate the full target image for the hardware \\\cline{1-2}
Same Address space for all the applications (M\+PU Support) &Each Application run in it’s own protected address space (M\+MU Support) \\\cline{1-2}
Execution of code directly from R\+OM &Application is loaded from persistence memory to R\+AM \\\cline{1-2}
Real time (High in the range of micro second), Safety critical (up to A\+S\+IL D), Low computing power &Not so real time (in the range of milli second), High Computing Power, Fail Safe Operational System, Highly secured \\\cline{1-2}
\end{longtabu}




While the communication protocols of the classical platform are based on signal based paradigm that is statically pre-\/configured before run-\/time (operation), while the adaptive platform is based service-\/oriented communication allowing dynamic initiation of communication paths. Similarly, the dynamic scheduling of applications would allow dynamic deployment of application during runtime. Another important characteristic is the Memory Management Unit, through which each process (task) executed by the operating system have its own virtual address and doesn’t recognize the existence of others. This assists the achievement of freedom from interference between applications, even after their deployment during runtime. All this is realized through a P\+O\+S\+IX complaint operating system, to allow the compatibility between other applications.

{\bfseries Types of Adaptive Platform\+:} Machine term has been newly introduced with the A\+U\+T\+O\+S\+AR Adaptive Platform. A machine is resembled to virtualized E\+CU, an entity where software can be deployed to. In this context, one real E\+CU could run several machines. In the simplest case the term machine is nothing but an E\+CU.  \begin{quote}
{\bfseries Existence of Classic Platform\+:} A\+U\+T\+O\+S\+AR has no intention of replacing the Classical Platform with the Adaptive Platform, but the aim is to have both platforms coexisting and functioning together on the same network without risking the stability of the existing classical architecture that has been proven over the years. The introduction of the Adaptive Platform intends to complement the automotive specific functionalities and sustain the domain’s fundamental attributes such as reliability, availability, maintainability and safety. \end{quote}


{\bfseries Integration of Classic, Adaptive and Non-\/\+A\+U\+T\+O\+S\+AR E\+C\+Us\+:} A\+U\+T\+O\+S\+AR Adaptive Architecture uses the S\+O\+M\+E/\+IP to integrate with A\+U\+T\+O\+S\+AR CP and other Non-\/\+A\+U\+T\+O\+S\+AR Platforms like G\+E\+N\+I\+VI  \section*{1. Technology Drivers}

There are two major groups of technology drivers behind. One is Ethernet, and the other is processors.
\begin{DoxyItemize}
\item {\itshape Ethernet}
\begin{DoxyItemize}
\item High bandwidth
\item Communication system is not a limiting aspect any more
\item Switched network
\item Efficient point-\/to-\/point communication
\item Efficient transfer of long messages
\end{DoxyItemize}
\item {\itshape Processor}
\begin{DoxyItemize}
\item Switch from microcontroller to processors with external memory (and maybe filesystems)
\item Many core processors
\item Parallel computing
\item \char`\"{}\+Cheap\char`\"{} availability of computing power
\item Special purpose processors
\end{DoxyItemize}
\end{DoxyItemize}

\section*{2. Adaptive Platform Characteristics}


\begin{DoxyItemize}
\item {\itshape Language C++}
\item {\itshape S\+OA}
\item {\itshape Parallel processing}
\item {\itshape Leveraging existing standard}
\item {\itshape Safety and security}
\item {\itshape Planned dynamics}
\item {\itshape Agile}
\end{DoxyItemize}

\subsection*{2.\+1 Service Oriented Architecture (S\+OA)}

A service-\/oriented architecture (S\+OA) is an approach used to create a software architecture based on the use of services that is exchanged between application software components. It enables the idea of service reuse, no need to start from scratch when upgrades and other modifications are needed; which creates an efficient and flexible way to interconnect systems to perform a specific job increasing the system scalability and re-\/usability, and simultaneously eases the coexistence of different applications.  The exchange of services is based on a Service-\/\+Oriented Communication (S\+OC) paradigm, where “an application is interpreted as a set of data providing (sensors), data processing (application logic), and data consuming (actuators) services. As shown in the above figure, the communication paths follow a producer/consumer or client/server model, where some applications offer their services as producers, while other applications subscribe for services as consumers. This allows the introduction of new services independent of vendors, products, technologies, and without introducing changes in the underlying program, which further support the establishment of communication paths at run-\/time.

Only the needed data is subscribed for and reaches the client; unlike the classical way where all the data is broadcasted regardless of the receiver. Moreover, S\+O\+M\+E/\+IP can be implemented on different operating system and even embedded devices without an operating system; serving the intention of providing compatibility, and allowing stronger interactions with off-\/board systems and non-\/\+A\+U\+T\+O\+S\+AR applications.

A service consists of a combination of
\begin{DoxyItemize}
\item Events
\item Methods
\item Fields
\end{DoxyItemize}

\subsection*{2.\+2 Parallel Processing}

The distributed computing is inherently parallel. The S\+OA, as different applications uses different set of services, shares this characteristic. The advancement or many core processors and heterogeneous computing that offer parallel processing capability offers technological opportunities to harness the compute power to match the inherent parallelism. Thus, the AP possesses the architectural capability to scale its functionality and performance as the manycore-\/heterogeneous computing technologies advance.

\subsection*{2.\+3 Leveraging existing standard}


\begin{DoxyItemize}
\item Reuse existing (non-\/automotive) standards
\item Ease software development
\item Support automotive use-\/cases and protocols 
\end{DoxyItemize}

\subsection*{2.\+4 Safety and Security}

The systems that AP targets often require highest level of safety and security. To cope with the challenge, AP combines architectural, functional, and procedural approaches. The architecture is based on distributed computing based on S\+OA, which inherently makes each component more independent and free of unintended interferences, dedicated functionalities to assist achieving safety and security.

\subsection*{2.\+5 Planned Dynamics}

The AP supports incremental deployment of applications, where resources and communications are managed dynamically to reduce the effort for software development and integration, enabling short iteration cycles. Incremental deployment also supports explorative software development phases. AP allows the system integrator to carefully limit dynamic behavior to reduce the risk of unwanted or adverse effects allowing safety qualification. Dynamic behavior of an application will be limited by constraints stated in the Application Manifest.  Configuration of communication paths can happen at design-\/, at startup-\/ or at run-\/time and is therefore considered either static or dynamic.
\begin{DoxyItemize}
\item {\bfseries Full static configuration\+:} service discovery is not needed at all as the server knows all clients and clients know the server.
\item {\bfseries No discovery by application code\+:} the clients know the server but the server does not know the clients. Event subscription is the only dynamic communication pattern in the application.
\item {\bfseries Full service discovery in the application\+:} No communication paths are known at configuration time. An A\+PI for Service discovery allows the application code to choose the service instance at runtime.
\end{DoxyItemize}

Examples of Planned Dynamics are
\begin{DoxyItemize}
\item Pre-\/determination of service discovery process
\item Restriction of dynamic memory allocation to startup phase only
\item Fair scheduling policy in addition to priority-\/based scheduling
\item Fixed allocation of processes to C\+PU cores
\item Access to pre-\/existing files in the file-\/system only
\item Constraints for AP A\+PI usage by Applications
\item Execution of authenticated code only
\end{DoxyItemize}

\subsection*{2.\+6 Agile}

To support Agile Development process, it is important that underlying architecture e.\+g. Adaptive Platform is scalable with the possibility of updating the system after its deployment.

\section*{3 Adaptive Platform Architecture}

The A\+U\+T\+O\+S\+AR Adaptive architecture organizes the software of the A\+U\+T\+O\+S\+AR Adaptive foundation as functional clusters. These clusters offer common functionality as services to the applications. The Adaptive Application (AA) run on top of A\+RA, A\+U\+T\+O\+S\+AR Runtime for Adaptive applications. A\+RA consists of application interfaces provided by Functional Clusters, which belong to either Adaptive Platform Foundation or Adaptive Platform Services. Adaptive Platform Foundation provides fundamental functionalities of AP, and Adaptive Platform Services provide platform standard services of AP. The interface of Functional Clusters, either they are those of Adaptive Platform Foundation or Adaptive Platform Services, are indifferent from AA point of view. \subsection*{3.\+1 Adaptive Platform Foundation}

Adaptive Platform Foundation consists of following functional clusters\+:
\begin{DoxyItemize}
\item {\bfseries Communication Management}
\item {\bfseries A\+RA Core Types}
\item {\bfseries Execution Management}
\item {\bfseries R\+E\+S\+Tful Communication}
\item {\bfseries Time Synchronization}
\item {\bfseries Persistency}
\item {\bfseries Log\+And\+Trace}
\item {\bfseries Platform Health Management}
\item {\bfseries Identify Access Management}
\item {\bfseries Crypto}
\item {\bfseries Operating System with P\+O\+S\+IX Interface (P\+SE 51)}
\end{DoxyItemize}

\subsubsection*{3.\+1.\+1 Communication Management}

The Communication Management (CM) for A\+U\+T\+O\+S\+AR Adaptive is a functional cluster and is part of \char`\"{}\+A\+U\+T\+O\+S\+A\+R Runtime for Adaptive Applications\char`\"{} -\/ A\+RA. It is responsible for the construction and supervision of communication paths between applications, both local and remote. The CM provides the infrastructure that enables communication between Adaptive A\+U\+T\+O\+S\+AR Applications within one machine and with software entities on other machines, e.\+g. other Adaptive A\+U\+T\+O\+S\+AR applications or Classic A\+U\+T\+O\+S\+AR S\+W\+Cs. All communication paths can be established at design-\/ , start-\/up-\/ or run-\/time.  The Communication management of A\+U\+T\+O\+S\+AR Adaptive can be logically divided into the following sub-\/parts\+:
\begin{DoxyItemize}
\item Language binding
\item End-\/to-\/end communication protection
\item Communication / Network binding
\item Communication Management software
\end{DoxyItemize}

The Communication Management provides standardized means how a defined service is presented to the application implementer (upper layer, Language Binding) as well as the respective representation of the service’s data on the network (lower layer, Network Binding). This assures portability of source code and compatibility of compiled services across different implementations of the platform.

Service-\/\+Oriented Communication (SoC) is the main communication pattern for Adaptive A\+U\+T\+O\+S\+AR Applications. It allows establishing communication paths both at design-\/time and run-\/time. Hence, it can be used to build up both static communication with known numbers of participants and dynamic communication with unknown number of participants.

The service class is the central element of the Service-\/\+Oriented Communication pattern applied in Adaptive A\+U\+T\+O\+S\+AR. It represents the service by collecting the methods and events which are provided or requested by the applications implementing the concrete service functionality.

Regarding interaction between A\+As, P\+S\+E51 do not include I\+PC (Inter-\/\+Process-\/\+Communication), so there is no direct interface to interact between A\+As. The Communication Management (CM) is the only explicit interface. CM also provides Service Oriented Communication for both intra-\/machine and inter-\/machine, which are transparent to applications. CM handles routing of Service requests/replies regardless of the topological deployment of Service and client applications.

\begin{quote}
{\bfseries Note\+: The Communication Management software using Service-\/\+Oriented Communication will not achieve hard real time requirements, as the implementation will behave like a virtual ethernet including latencies of communication. This behavior must be respected with the design of the overall E\+CU and SW system.} \end{quote}


\subsubsection*{3.\+1.\+2 Execution Management}

Execution Management is responsible for all aspects of system execution management including platform initialization and startup / shutdown of Applications. Execution Management works in conjunction with the Operating System to perform run-\/time scheduling of Applications.  When the Machine is started, the OS will be initialized first and then Execution Management is launched as one of the O\+S’s initial processes. Other functional clusters and platform-\/level Applications of the Adaptive Platform Foundation are then launched by Execution Management. After the Adaptive Platform Foundation is up and running, Execution Management continues launching Adaptive Applications. The startup order of the platform-\/level Applications and the Adaptive Applications are determined by the Execution Management, based on Machine Manifest and Application Manifest information.  Execution Management is responsible for all aspects of Adaptive Platform execution management and Application execution management including\+:


\begin{DoxyItemize}
\item Machine State Management
\item Start-\/up and shutdown of Applications, including platform-\/level Applications and Adaptive Applications.
\item The Execution Management is the initial (“boot”) process of the operating system and is responsible for Machine start-\/up.
\item The Execution Management enforces process isolation with each Executable managed as a single process.
\item Privileges and use of access control
\end{DoxyItemize}

\begin{quote}
{\bfseries Note\+: The Execution Management is not responsible for run-\/time scheduling of Applications since this is the responsibility of the Operating System. However, the Execution Management is responsible for initialization / configuration of the OS to enable it to perform the necessary run-\/time scheduling based on information extracted by the Execution Management from the Machine Manifest and Application Manifests.} \end{quote}


\subsubsection*{3.\+1.\+3 Persistency}

Persistency offers mechanisms to applications and other functional clusters of the Adaptive Platform to store information in the non-\/volatile memory of an Adaptive Machine. The data is available over boot and ignition cycles. Persistency offers standard interfaces to access the non-\/volatile memory. The Persistency A\+P\+Is take storage location identifiers as parameters from the application to address different storage locations. The available storage locations fall into two categories. Every application may use a combination of these storage types.
\begin{DoxyItemize}
\item {\bfseries Key-\/\+Value Storage}
\item {\bfseries File-\/\+Proxy Storage}
\end{DoxyItemize}

\begin{quote}
{\bfseries Note\+: Persistent data is always private to one application. There is no mechanism available to share data between different applications using the Persistency} \end{quote}


\subsubsection*{3.\+1.\+4 Operating System with P\+O\+S\+IX Interface (P\+SE 51)}

The Operating System is responsible for run-\/time resource management (including time) for all Applications on the Adaptive Platform. It offers the foundation for dynamic behavior of the software applications. It manages the scheduling of processes and events, the data exchange and synchronization between different processes and provides features for monitoring and error handling. The AP Operating System is required to provide multi-\/process P\+O\+S\+IX OS capability. Each AA is implemented as an independent process, with its own logical memory space and name space.

G\+N\+U/\+Linux is an operating system that uses a combination of G\+NU software and Linux as its kernel, hence named \char`\"{}\+G\+N\+U/\+Linux\char`\"{}. G\+N\+U/\+Linux is used to refer to the whole operating system and the term Linux would be used to refer to the kernel itself. Linux -\/the kernel-\/ is the most important part of the operating system, as it manages access to the hardware resources required by the programs of the operating system run as User Applications. It operates in what is called “the kernel space”; interacting with these applications through its system call interface

On the other hand, G\+N\+U/\+Linux consists of many programs other than the kernel, which may include for example the graphical user interfaces, compilers, specific libraries and many other services. However, without the kernel the operating system can’t provide these services  \begin{quote}
{\bfseries Note\+: Adaptive Platform does not specify a new Operating System for highly performant processors. Rather, it defines an execution context and Operating System Interface (O\+SI) for use by Adaptive Applications.} \end{quote}


{\bfseries P\+O\+S\+IX (P\+S\+E51)}\+:Minimal Real-\/\+Time System (P\+S\+E51) offers functions for
\begin{DoxyEnumerate}
\item basic synchronized I/O,
\item high-\/resolution timer,
\item signals,
\item semaphores,
\item shared memory and threads.
\end{DoxyEnumerate}

 Scheduling\+: The operating system provides multi-\/threading and multi-\/process support. The standard scheduling policies are S\+C\+H\+E\+D\+\_\+\+F\+I\+FO and S\+C\+H\+E\+D\+\_\+\+RR, which are defined by the P\+O\+S\+IX standard.

\begin{quote}
{\bfseries Note\+: As the envisioned application software components for Adaptive Platform will not require to fork new processes themselves, and only need limited direct access to files, the P\+S\+E51 profile is thought to be sufficient.} \end{quote}


\subsection*{3.\+2 Adaptive Platform Services}


\begin{DoxyItemize}
\item {\bfseries Update and Configuration Management}
\item {\bfseries Signal to Service Mapping}
\item {\bfseries State Management}
\item {\bfseries Diagnostic}
\item {\bfseries Network Management}
\end{DoxyItemize}

\subsubsection*{3.\+2.\+1 Update and Configuration Management}

One of the declared goals of Adaptive A\+U\+T\+O\+S\+AR is the ability to flexibly update the software and its configuration through over-\/the-\/air updates. To support changes in the software on an Adaptive Platform the Update and Configuration Manager(\+U\+C\+M) provides an Adaptive Platform service that handles software update requests.  U\+CM is responsible for updating, installing, removing and keeping a record of the software on an Adaptive Platform. Its role is similar to known package management systems like dpkg or Y\+UM in Linux, with additional functionality to ensure a safe and secure way to update or modify software on the Adaptive Platform.

\subsubsection*{3.\+2.\+2 State Management}

State Management provides a mechanism to define the state of the operation for an Adaptive Platform. State Management grants full control over the set of Applications to be executed and ensures that processes are only executed (and hence resources allocated) when needed. Machine States and Function Group States define the current set of running processes. Each process declares in its Application Manifest in which States it shall be active.  Four different states are relevant for Execution Management\+:
\begin{DoxyItemize}
\item {\bfseries Machine State\+:} Machine States are mainly used to control machine life cycle (startup/shutdown/restart), platform level processes and other infrastructure. There are several mandatory Machine states that must be present on each machine. Additional machine specific Machine States can be defined in the Machine Manifest.
\item {\bfseries Function Group State\+:} Function Group States are mainly used to individually start and stop groups of functionally coherent user level Application processes. They can be configured in the Machine Manifest.
\item {\bfseries Process State\+:} Process States are used for Application Life cycle Management and are implemented by an Execution Management internal state machine.
\item {\bfseries Application State\+:} The Application State characterizes the internal life cycle of any instance of an Application Executable, i.\+e. process. Each process must report Application State changes to Execution Management.
\end{DoxyItemize}

\section*{4 Configuration Methodology}

In contrast to the A\+U\+T\+O\+S\+AR Classic Platform, instances of Adaptive Applications, for example, are executed within the context of processes, entities managed by the operating system. If permitted by the configuration of the operating system, processes may be started, executed or stopped, at any time during the life cycle of a machine. As a consequence, the way of configuration (by the means of Manifests) or when and how software packages are deployed (e.\+g., by software updates over-\/the-\/air) clearly differ from the concepts of the A\+U\+T\+O\+S\+AR Classic Platform.

A Manifest represents a piece of A\+U\+T\+O\+S\+AR model description that is created to support the configuration of an A\+U\+T\+O\+S\+AR AP product and which is uploaded to the A\+U\+T\+O\+S\+AR AP product, potentially in combination with other artifacts (like binary files) that contain executable code to which the Manifest applies.  Development Work flow is mainly divided into four parts\+:


\begin{DoxyItemize}
\item {\bfseries Application Design\+:} This kind of description specifies all design-\/related aspects e.\+g. data types, service interfaces, persistency interfaces etc.. that apply to the creation of application software for the A\+U\+T\+O\+S\+AR AP. It is not necessarily required to be deployed to the adaptive platform machine, but the application design aids the definition of the deployment of application software in the Application Manifest and Service Instance Manifest.
\item {\bfseries Application Manifest\+:} This kind of Manifest is used to specify the deployment-\/related information of applications running on the A\+U\+T\+O\+S\+AR AP e.\+g how the application instance shall be started with startup options and access roles. An Application Manifest is bundled with the actual executable code to support the integration of the executable code onto the machine.
\item {\bfseries Service Instance Manifest\+:} This kind of Manifest is used to specify how service-\/oriented communication is configured in terms of the requirements of the underlying transport protocols. A Service Instance Manifest is bundled with the actual executable code that implements the respective usage of service-\/oriented communication.
\item {\bfseries Machine Manifest\+:} This kind of Manifest is supposed to describe deployment-\/related content that applies to the configuration of just the underlying machine (i.\+e. without any applications running on the machine) e.\+g. Configuration of the service discovery technology, Definition of the used machine states, Definition of the used function groups that runs an A\+U\+T\+O\+S\+AR AP. A Machine Manifest is bundled with the software taken to establish an instance of the A\+U\+T\+O\+S\+AR AP. 
\end{DoxyItemize}\hypertarget{adaptive_communicationmanagement}{}\section{Communication Management}\label{adaptive_communicationmanagement}

\begin{DoxyItemize}
\item \hyperlink{adaptive_communicationmanagement_introduction}{Introduction}
\item \hyperlink{adaptive_communicationmanagement_someip}{S\+O\+M\+E/\+IP(Scalable service-\/\+Oriented MiddlewarE over IP)}
\item \hyperlink{adaptive_communicationmanagement_aracom}{A\+RA Com A\+PI} 
\end{DoxyItemize}\hypertarget{adaptive_communicationmanagement_introduction}{}\subsection{Introduction}\label{adaptive_communicationmanagement_introduction}
The A\+U\+T\+O\+S\+AR Adaptive architecture organizes the software of the A\+U\+T\+O\+S\+AR Adaptive foundation as functional clusters. These clusters offer common functionality as services to the applications. The Communication Management (CM) for A\+U\+T\+O\+S\+AR Adaptive is such a functional cluster and also part of \char`\"{}\+A\+U\+T\+O\+S\+A\+R Runtime for Adaptive Applications\char`\"{} -\/ A\+RA. It is responsible for the construction and supervision of communication paths between applications, both local and remote. The CM provides the infrastructure that enables communication between Adaptive A\+U\+T\+O\+S\+AR Applications within one machine and with software entities on other machines, e.\+g. other Adaptive A\+U\+T\+O\+S\+AR applications or Classic A\+U\+T\+O\+S\+AR S\+W\+Cs. All communication paths can be established at design-\/ , start-\/up-\/ or run-\/time.

 \subsection*{1. Architectural concepts}

The Communication management of A\+U\+T\+O\+S\+AR Adaptive can be logically divided into the following sub-\/parts\+:
\begin{DoxyEnumerate}
\item Language binding
\item End-\/to-\/end communication protection
\item Communication / Network binding
\item Communication Management software
\end{DoxyEnumerate}

\subsection*{2. Design of the A\+RA A\+PI}


\begin{DoxyItemize}
\item The (service) proxy is the representative of the possibly remote (i.\+e. other process, other core, other node) service. It is an instance of a C++ class local to the application/client, which uses the service.
\item The (service) skeleton is the connection of the user provided service implementation to the middleware transport infrastructure. Service implementation is sub-\/classing the (service) skeleton.
\item Beside proxies/skeletons, there might exist a so-\/called \char`\"{}\+Runtime\char`\"{} (singleton) class to provide some essentials to manage proxies and skeletons.
\item Client/\+Server Communication uses concepts introduced by C++11 language, e.\+g. std\+::future, std\+::promise, to fully support method calls between different contexts. Future and Promise are the two separate sides of an asynchronous operation.
\begin{DoxyItemize}
\item std\+::promise is used by the \char`\"{}producer/writer\char`\"{} of the asynchronous operation.
\item std\+::future is used by the \char`\"{}consumer/reader\char`\"{} of the asynchronous operation.
\item The reason it is separated into these two separate \char`\"{}interfaces\char`\"{} is to hide the \char`\"{}write/set\char`\"{} functionality from the \char`\"{}consumer/reader\char`\"{}
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+1 Communication paradigms}

Service-\/\+Oriented Communication (SoC) is the main communication pattern for Adaptive A\+U\+T\+O\+S\+AR Applications. It allows establishing communication paths both at design-\/ and run-\/time, so it can be used to build up both static communication with known numbers of participants and dynamic communication with unknown number of participants.

 Service Discovery decides whether external and/or internal service-\/oriented communication is established. The discovery strategy allows either returning a specific service instance or all available instances providing the requested service at the time of the request, no matter if they are available locally or remote. \hypertarget{adaptive_communicationmanagement_someip}{}\subsection{S\+O\+M\+E/\+IP(Scalable service-\/\+Oriented MiddlewarE over IP)}\label{adaptive_communicationmanagement_someip}
S\+O\+M\+E/\+IP is an abbreviation for \char`\"{}\+Scalable service-\/\+Oriented Middlewar\+E over I\+P\char`\"{}. This middleware was designed for typical automotive use cases and for being compatible with A\+U\+T\+O\+S\+AR. S\+O\+M\+E/\+IP is an automotive/embedded communication protocol which supports remote procedure calls, event notifications and the underlying serialization/wire format.

\section*{Glossary of Terms}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Term }&\textbf{ Description  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Term }&\textbf{ Description  }\\\cline{1-2}
\endhead
Method &A method, procedure, function, or subroutine that is called/invoked. \\\cline{1-2}
Parameters &input, output, or input/output arguments of a method or an event \\\cline{1-2}
Remote Procedure Call (R\+PC) &A method call from one E\+CU to another that is transmitted using messages \\\cline{1-2}
Request &a message of the client to the server invoking a method \\\cline{1-2}
Response &a message of the server to the client transporting results of a method invocation \\\cline{1-2}
Request/\+Response communication &a R\+PC that consists of request and response \\\cline{1-2}
Event &A uni-\/directional data transmission that is only invoked on changes or cyclically and is sent from the producer of data to the consumers. \\\cline{1-2}
Field &A field does represent a status and thus has an valid value at all times on which getter, setter and notifier act upon. \\\cline{1-2}
Notification Event &An event message of the notifier of a field. \\\cline{1-2}
Getter &A Request/\+Response call that allows read access to a field. \\\cline{1-2}
Setter &A Request/\+Response call that allows write access to a field. \\\cline{1-2}
Notifier &Sends out event message with a new value on change of the value of the field. \\\cline{1-2}
Service &A logical combination of zero or more methods, zero or more events, and zero or more fields. \\\cline{1-2}
Service Interface &the formal specification of the service including its methods, events, and fields \\\cline{1-2}
Eventgroup &A logical grouping of events and notification events of fields inside a service in order to allow subscription \\\cline{1-2}
Service Instance &Implementation of a service, which can exist more than once in the vehicle and more than once on an E\+CU \\\cline{1-2}
Server &The E\+CU offering a service instance is called server in the context of this service instance. \\\cline{1-2}
Client &The E\+CU using the service instance of a server is called client in the context of this service instance. \\\cline{1-2}
Fire and Forget &Requests without response message are called fire\&forget. \\\cline{1-2}
Union &A data structure that dynamically assumes different data types. \\\cline{1-2}
\end{longtabu}


The three main parts of the S\+O\+M\+E/\+IP specification is as follows\+:


\begin{DoxyEnumerate}
\item \hyperlink{adaptive_communicationmanagement_someip_on_wire_format}{On-\/wire format}
\item \hyperlink{adaptive_communicationmanagement_someip_protocol}{Protocol}
\item \hyperlink{adaptive_communicationmanagement_someip_service_discovery}{Service Discovery(S\+O\+M\+E/\+I\+P-\/\+SD)}
\end{DoxyEnumerate}\hypertarget{adaptive_communicationmanagement_someip_on_wire_format}{}\subsubsection{1. On-\/wire format}\label{adaptive_communicationmanagement_someip_on_wire_format}

\begin{DoxyItemize}
\item S\+O\+M\+E/\+IP allows applications to communicate.
\item Packet formats are automatically determined by the specification of the Service.
\item Server offers a Service Instance that implements the Service Interface.
\item Client uses the Service Instance using S\+O\+M\+E/\+IP.
\end{DoxyItemize}\hypertarget{adaptive_communicationmanagement_someip_protocol}{}\subsubsection{2. Protocol}\label{adaptive_communicationmanagement_someip_protocol}
\subsection*{2.\+1 S\+O\+M\+E/\+IP Header Format}

 \subsubsection*{2.\+1.\+1 Message ID \mbox{[}32 Bit\mbox{]}}


\begin{DoxyItemize}
\item The Message ID is a 32 Bit identifier that is used to identify the R\+PC call to a method of an application or to identify an event.
\item Message I\+Ds of method calls will be structured in the ID with 2$^\wedge$16 services with 2$^\wedge$15 methods as shown below. 
\end{DoxyItemize}

\subsubsection*{2.\+1.\+2 Length \mbox{[}32 Bit\mbox{]}}


\begin{DoxyItemize}
\item Length field contains the length in Byte starting from Request I\+D/\+Client ID until the end of the S\+O\+M\+E/\+IP message.
\end{DoxyItemize}

\subsubsection*{2.\+1.\+3 Request ID \mbox{[}32 Bit\mbox{]}}


\begin{DoxyItemize}
\item The Request ID allows a provider and subscriber to differentiate multiple parallel uses of the same method, event, getter or setter.
\item The Request ID is unique for a provider-\/ and subscriber-\/combination only.
\item When generating a response message, the provider copies the Request ID from the request to the response message.
\item Request ID constructed of the Client ID and Session ID as shown below. 
\item The Client ID is the unique identifier for the calling client inside the E\+CU. The Client ID allows an E\+CU to differentiate calls from multiple clients to the same method.
\item The Session ID is a unique identifier that allows to distinguish sequential messages. It also allows to distinguish requests originating from the same sender from each other.
\item The Client ID supports being unique in the overall vehicle by having a configurable prefix or fixed value (e.\+g. the most significant byte of Client ID being the diagnostics address or a configured Client ID for a given application/\+S\+W-\/C). 
\item Request/\+Response methods use session handling with Session I\+Ds. Session ID should be incremented after each call.
\item When the Session ID reaches 0x\+F\+F\+FF, it wraps around and starts again with 0x01.
\item For request/response methods, a subscriber has to ignore a response if the Session ID of the response does not match the Session ID of the request.
\item For notification messages, a receiver ignores the Session ID in case Session Handling is not active.
\item For notification messages, a receiver treats the Session ID according to the respective use case.
\end{DoxyItemize}

\subsubsection*{2.\+1.\+4 Protocol Version \mbox{[}8 Bit\mbox{]}}


\begin{DoxyItemize}
\item The Protocol Version set to 1.
\end{DoxyItemize}

\subsubsection*{2.\+1.\+5 Interface Version \mbox{[}8 Bit\mbox{]}}


\begin{DoxyItemize}
\item Interface Version contains the Major Version of the Service Interface.
\end{DoxyItemize}

\subsubsection*{2.\+1.\+6 Message Type \mbox{[}8 Bit\mbox{]}}


\begin{DoxyItemize}
\item The Message Type field is used to differentiate different types of messages and contains the following values as shown in Table.
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Number }&\textbf{ Value }&\textbf{ Description  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Number }&\textbf{ Value }&\textbf{ Description  }\\\cline{1-3}
\endhead
0x00 &R\+E\+Q\+U\+E\+ST &A request expecting a response (even void) \\\cline{1-3}
0x01 &R\+E\+Q\+U\+E\+S\+T\+\_\+\+N\+O\+\_\+\+R\+E\+T\+U\+RN &A fire\&forget request \\\cline{1-3}
0x02 &N\+O\+T\+I\+F\+I\+C\+A\+T\+I\+ON &A request of a notification/event callback expecting no response \\\cline{1-3}
0x80 &R\+E\+S\+P\+O\+N\+SE &The response message \\\cline{1-3}
0x81 &E\+R\+R\+OR &The response containing an error \\\cline{1-3}
0x20 &T\+P\+\_\+\+R\+E\+Q\+U\+E\+ST &A Transport Protocol request expecting a response (even void) \\\cline{1-3}
0x21 &T\+P\+\_\+\+R\+E\+Q\+U\+E\+S\+T\+\_\+\+N\+O\+\_\+\+R\+E\+T\+U\+RN &A Transport Protocol fire\&forget request \\\cline{1-3}
0x22 &T\+P\+\_\+\+N\+O\+T\+I\+F\+I\+C\+A\+T\+I\+ON &A Transport Protocol request of a notification/event callback expecting no response \\\cline{1-3}
0x23 &T\+P\+\_\+\+R\+E\+S\+P\+O\+N\+SE &The Transport Protocol response message \\\cline{1-3}
0x24 &T\+P\+\_\+\+E\+R\+R\+OR &The Transport Protocol response containing an error \\\cline{1-3}
\end{longtabu}

\begin{DoxyItemize}
\item The 3rd highest bit of the Message Type (=0x20) is called as T\+P-\/\+Flag and will be set to 1 to signal that the current S\+O\+M\+E/\+IP message is a segment. The other bits of the Message Type are set as specified in this Section.
\end{DoxyItemize}

\subsubsection*{2.\+1.\+7 Return Code \mbox{[}8 Bit\mbox{]}}


\begin{DoxyItemize}
\item The Return Code is used to signal whether a request was successfully processed. For simplification of the header layout, every message transports the field Return Code. The allowed Return Codes for specific message types are shown in Table.
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Message Type }&\textbf{ Allowed Return Codes  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Message Type }&\textbf{ Allowed Return Codes  }\\\cline{1-2}
\endhead
R\+E\+Q\+U\+E\+ST &N/A set to 0x00 (E\+\_\+\+OK) \\\cline{1-2}
R\+E\+Q\+U\+E\+S\+T\+\_\+\+N\+O\+\_\+\+R\+E\+T\+U\+RN &N/A set to 0x00 (E\+\_\+\+OK) \\\cline{1-2}
N\+O\+T\+I\+F\+I\+C\+A\+T\+I\+ON &N/A set to 0x00 (E\+\_\+\+OK) \\\cline{1-2}
R\+E\+S\+P\+O\+N\+SE &Please refer 2.\+2.\+6.\+1 section \\\cline{1-2}
E\+R\+R\+OR &Please refer 2.\+2.\+6.\+1 section \\\cline{1-2}
\end{longtabu}
\subsubsection*{2.\+1.\+8 Payload \mbox{[}variable size\mbox{]}}


\begin{DoxyItemize}
\item In the payload field the parameters are carried. The serialization of the parameters will be specified in the following section.
\item The size of the S\+O\+M\+E/\+IP payload field depends on the transport protocol used.
\item The U\+DP binding of S\+O\+M\+E/\+IP can only transport S\+O\+M\+E/\+IP messages that fit directly into an IP packet. Use T\+CP only if very large chunks of data need to be transported ($>$ 1400 Bytes) and no hard latency requirements in the case of errors exists
\end{DoxyItemize}

\subsubsection*{2.\+1.\+9 Event, Field and Eventgroup}


\begin{DoxyItemize}
\item Eventgroup is a logical grouping of events and notification events of fields inside a service in order to allow subscription.
\item Events and notifications are transported using R\+PC. Events will be structured as shown in Table 
\end{DoxyItemize}

\subsubsection*{2.\+1.\+10 Endianess}


\begin{DoxyItemize}
\item S\+O\+M\+E/\+IP Header will be encoded in network byte order (big endian).
\item The byte order of the parameters inside the payload is defined by configuration.
\end{DoxyItemize}

\subsubsection*{2.\+1.\+11 Serialization of Data Structures}


\begin{DoxyItemize}
\item The serialization is based on the parameter list defined by the interface specification. The interface specification defines the exact position of all data structures in the P\+DU and has to consider the memory alignment.
\item Alignment is used to align the beginning of data by inserting padding elements after the data in order to ensure that the aligned data starts at certain memory addresses.
\end{DoxyItemize}

\paragraph*{2.\+1.\+11.\+1 Basic Datatypes}

The following basic datatypes as shown in Table are supported\+:

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Type }&\textbf{ Description }&\textbf{ Size \mbox{[}bit\mbox{]} }&\textbf{ Remark  }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Type }&\textbf{ Description }&\textbf{ Size \mbox{[}bit\mbox{]} }&\textbf{ Remark  }\\\cline{1-4}
\endhead
boolean &T\+R\+U\+E/\+F\+A\+L\+SE value &8 &F\+A\+L\+SE (0), T\+R\+UE (1) \\\cline{1-4}
uint8 &unsigned Integer &8 &\\\cline{1-4}
uint16 &unsigned Integer &16 &\\\cline{1-4}
uint32 &unsigned Integer &32 &\\\cline{1-4}
sint8 &signed Integer &8 &\\\cline{1-4}
sint16 &signed Integer &16 &\\\cline{1-4}
sint32 &signed Integer &32 &\\\cline{1-4}
float32 &floating point number &32 &I\+E\+EE 754 binary32 (Single Precision) \\\cline{1-4}
float64 &floating point number &64 &I\+E\+EE 754 binary64 (Double Precision) \\\cline{1-4}
\end{longtabu}
\paragraph*{2.\+1.\+11.\+2 Structured Datatypes (structs)}


\begin{DoxyItemize}
\item The serialization of a struct will be close to the in-\/memory layout. This means, only the parameters will be serialized sequentially into the buffer. Especially for structs it is important to consider the correct memory alignment. 
\end{DoxyItemize}

\paragraph*{2.\+1.\+11.\+3 Strings}


\begin{DoxyItemize}
\item All strings always starts with a Byte Order Mark (B\+OM).
\begin{DoxyItemize}
\item B\+OM \+: The byte order mark (B\+OM) is a Unicode character, U+\+F\+E\+FF byte order mark (B\+OM), whose appearance as a magic number at the start of a text stream can signal several things (eg. endianness) to a program consuming the text
\end{DoxyItemize}
\item The B\+OM will be included in fixed-\/length-\/strings as well as dynamic-\/length strings.
\item B\+OM allows the possibility to detect the used encoding.
\end{DoxyItemize}

\paragraph*{2.\+1.\+11.\+4 Arrays (fixed length)}


\begin{DoxyItemize}
\item The length of fixed length arrays is defined by the data type definition. They can be seen as repeated elements.\+Fixed length arrays are easier for use in very small devices. Dynamic length arrays might need more resources on the E\+CU using them.
\end{DoxyItemize}

\subparagraph*{2.\+1.\+11.\+4.\+1 One-\/dimensional}


\begin{DoxyItemize}
\item The one-\/dimensional arrays with fixed length \char`\"{}n\char`\"{} will carry exactly \char`\"{}n\char`\"{} elements of the same type. 
\end{DoxyItemize}

\subparagraph*{2.\+1.\+11.\+4.\+2 Multidimensional}


\begin{DoxyItemize}
\item The serialization of multidimensional arrays follows the in-\/memory layout of multidimensional arrays in the programming language (row-\/major order) and is shown in Figure below. 
\end{DoxyItemize}

\paragraph*{2.\+1.\+11.\+5 Dynamic Length Arrays}


\begin{DoxyItemize}
\item The layout of arrays with dynamic length will be based on the layout of fixed length arrays.
\item An optional length field at the beginning of an array should be used to specify the length of the array in Bytes.
\end{DoxyItemize}

\subparagraph*{2.\+1.\+11.\+5.\+1 One-\/dimensional}


\begin{DoxyItemize}
\item In the one-\/dimensional array one length field is used, which carries the number of bytes used for the array.
\end{DoxyItemize}

\subparagraph*{2.\+1.\+11.\+5.\+2 Multidimensional}


\begin{DoxyItemize}
\item In multidimensional arrays every sub array of different dimensions will have its own length field.
\end{DoxyItemize}

\paragraph*{2.\+1.\+11.\+6 Enumeration}


\begin{DoxyItemize}
\item Enumerations are not considered in S\+O\+M\+E/\+IP. Enumerations are transmitted as unsigned integer datatypes.
\end{DoxyItemize}

\paragraph*{2.\+1.\+11.\+7 Bitfield}


\begin{DoxyItemize}
\item Bitfields are transported as unsigned datatypes uint8/uint16/uint32.
\end{DoxyItemize}

\paragraph*{2.\+1.\+11.\+8 Union / Variant}


\begin{DoxyItemize}
\item A union (also called variant) is such a parameter that can contain different types of data. For example, if one defines a union of type uint8 and type uint16, the union will carry data which are a uint8 or a uint16.
\item Which data type will be transmitted in the payload can only be decided during execution. In this case, however, it is necessary to not only send the data itself but add an information about the applicable data type as a form of \char`\"{}meta-\/data\char`\"{} to the transmission.\+By the means of the attached meta-\/data the sender can identify the applicable data type of the union and the receiver can accordingly access the data properly.
\item A union consists of a length field, type selector and the payload as shown Table below. 
\item The length field defines the size of the data and padding in bytes and does not include the size of the length field and type field.
\item The type field specifies the data type of the data.
\end{DoxyItemize}

\subsection*{2.\+2 S\+O\+M\+E/\+IP Protocol specification}

This section describes the Remote Procedure Call(\+R\+P\+C), Event Notifications and Error Handling of S\+O\+M\+E/\+IP.

\subsubsection*{2.\+2.\+1 Transport Protocol Bindings}


\begin{DoxyItemize}
\item In order to transport S\+O\+M\+E/\+IP messages different transport protocols may be used. S\+O\+M\+E/\+IP currently supports U\+DP and T\+CP.
\item If a server runs different instances of the same service, messages belonging to different service instances will be mapped to the service instance by the transport protocol port on the server side.
\item All Transport Protocol Bindings supports transporting more than one S\+O\+M\+E/\+IP message in a Transport Layer P\+DU (i.\+e. U\+DP packet or T\+CP segment).
\end{DoxyItemize}

\paragraph*{2.\+2.\+1.\+1 U\+DP Binding}


\begin{DoxyItemize}
\item The U\+DP binding of S\+O\+M\+E/\+IP will be achieved by transporting S\+O\+M\+E/\+IP messages in U\+DP packets.
\item The header format allows transporting more than one S\+O\+M\+E/\+IP message in a single U\+DP packet. The S\+O\+M\+E/\+IP implementation identifies the end of a S\+O\+M\+E/\+IP message by means of the S\+O\+M\+E/\+IP length field. Based on the U\+DP length field, S\+O\+M\+E/\+IP determines if there are additional S\+O\+M\+E/\+IP messages in the U\+DP packet.
\end{DoxyItemize}

\paragraph*{2.\+2.\+1.\+2 T\+CP Binding}


\begin{DoxyItemize}
\item The T\+CP binding of S\+O\+M\+E/\+IP is based on the U\+DP binding. In contrast to the U\+DP binding, the T\+CP binding allows much bigger S\+O\+M\+E/\+IP messages and uses the robustness features of T\+CP (coping with loss, reorder, duplication, etc.).
\item When the T\+CP connection is lost, outstanding requests will be handled as timeouts. Since T\+CP handles reliability, additional means of reliability are not needed.
\item The client and server uses a single T\+CP connection for all methods, events, and notifications of a service instance. When having more than one instance of a service a T\+CP connection per services instance is needed.
\item The T\+CP connection will be opened by the client, when the first method call will be transported or the client tries to receive the first notifications. The client is responsible for re-\/establishing the T\+CP connection whenever it fails.
\item The T\+CP connection will be closed by the client, when the T\+CP connection is not required anymore.
\item The T\+CP connection will be closed by the client, when all Services using the T\+CP connections are not available anymore (stopped or timed out).
\item The server will not stop the T\+CP connection when stopping all services. Give the client enough time to process the control data to shutdown the T\+CP connection itself.
\end{DoxyItemize}

\paragraph*{2.\+2.\+1.\+3 Multiple Service-\/\+Instances}


\begin{DoxyItemize}
\item Service-\/\+Instances of the same Service are identified through different Instance I\+Ds. S\+O\+M\+E/\+IP supports multiple Service-\/\+Instances reside on different E\+C\+Us as well as multiple Service-\/\+Instances of one or more Services reside on one single E\+CU.
\item While different Services will be able to share the same port number of the transport layer protocol used, multiple Service-\/\+Instances of the same service on one single E\+CU listens on different ports per Service-\/\+Instance.
\item A Service Instance can be identified through the combination of the Service ID combined with the socket (i.\+e. I\+P-\/address, transport protocol (U\+D\+P/\+T\+CP), and port number).
\end{DoxyItemize}

\paragraph*{2.\+2.\+1.\+4 Transporting large S\+O\+M\+E/\+IP messages of U\+DP (S\+O\+M\+E/\+I\+P-\/\+TP)}


\begin{DoxyItemize}
\item The U\+DP binding of S\+O\+M\+E/\+IP can only transport S\+O\+M\+E/\+IP messages that fit directly into an IP packet. If larger S\+O\+M\+E/\+IP messages need to be transported over U\+DP (e.\+g. of 32 KB) the S\+O\+M\+E/\+IP Transport Protocol (S\+O\+M\+E/\+I\+P-\/\+TP) will be used. The S\+O\+M\+E/\+IP message too big to be transported directly with the U\+DP binding will be called \char`\"{}original\char`\"{} S\+O\+M\+E/\+IP message. The \char`\"{}pieces\char`\"{} of the original S\+O\+M\+E/\+IP message payload transported in S\+O\+M\+E/\+I\+P-\/\+TP messages will be called \char`\"{}segments\char`\"{}.
\item S\+O\+M\+E/\+IP messages using S\+O\+M\+E/\+I\+P-\/\+TP activates Session Handling (Session ID must be unique for the original message).
\item All S\+O\+M\+E/\+I\+P-\/\+TP segments carry the Session ID of the original message; thus, they have all the same Session-\/\+ID.
\item S\+O\+M\+E/\+I\+P-\/\+TP segments will have the T\+P-\/\+Flag of the Message Type set to 1.
\item S\+O\+M\+E-\/\+I\+P-\/\+T\+P-\/\+Header is as shown in below. S\+O\+M\+E/\+I\+P-\/\+TP segments will have a TP header right after the S\+O\+M\+E/\+IP header (i.\+e. before the S\+O\+M\+E/\+IP payload) with the following structure (bits from highest to lowest)\+:

{\bfseries a. Offset \mbox{[}28 bits\mbox{]}}

{\bfseries b. Reserved Flag \mbox{[}1 bit\mbox{]}}

{\bfseries c. Reserved Flag \mbox{[}1 bit\mbox{]}}

{\bfseries d. Reserved Flag \mbox{[}1 bit\mbox{]}}

{\bfseries e. More Segments Flag \mbox{[}1 bit\mbox{]}}
\end{DoxyItemize}

 \paragraph*{2.\+2.\+1.\+4.\+1 Example}


\begin{DoxyItemize}
\item This example describes how an original S\+O\+M\+E/\+IP message of 5880 bytes payload has to be transmitted. The Length field of this original S\+O\+M\+E/\+IP message is set to 8 + 5880 bytes. 
\item This original S\+O\+M\+E/\+IP message will now be segmented into 5 consecutive S\+O\+M\+E/\+IP segments. Every payload of these segments carries at most 1392 bytes in this example.
\item For these segments, the S\+O\+M\+E/\+IP TP module adds additional TP fields. The Length field of the S\+O\+M\+E/\+IP carries the overall length of the S\+O\+M\+E/\+IP segment including 8 bytes for the Request ID, Protocol Version, Interface Version, Message Type and Return Code. Because of the added TP fields (4 bytes), this Length information is extended by 4 additional S\+O\+M\+E/\+IP TP bytes.
\item The following figure provides an overview of the relevant S\+O\+M\+E/\+IP header settings for every S\+O\+M\+E/\+IP segment\+: 
\item Please note that the value provided within the Offset Field is given in units of 16 bytes, i.\+e.\+: The Offset Value of 87 correspond to 1392 bytes Payload.
\item The first 4 segments contain 1392 Payload bytes each with \char`\"{}\+More Segments Flag\char`\"{} set to ’1’\+: 
\item The last segment (i.\+e. 5) contains the remaining 312 Payload bytes of the original 5880 bytes payload. This last segment is marked with \char`\"{}\+More Segments flag\char`\"{} set to ’0’. 
\end{DoxyItemize}

\subsubsection*{2.\+2.\+2 Request/\+Response Communication}


\begin{DoxyItemize}
\item One of the most common communication patterns is the request/response pattern. One communication partner (Client) sends a request message, which is answered by another communication partner (Server). 
\item For the S\+O\+M\+E/\+IP request message the client has to do the following for payload and header\+:
\begin{DoxyItemize}
\item Construct the payload
\item Set the Message ID based on the method the client wants to call
\item Set the Length field to 8 bytes (for the part of the S\+O\+M\+E/\+IP header after the length field) + length of the serialized payload
\item Optionally set the Request ID to a unique number (unique for client only)
\item Set the Protocol Version according
\item Set the Interface Version according to the interface definition
\item Set the Message Type to R\+E\+Q\+U\+E\+ST (i.\+e. 0x00)
\item Set the Return Code to 0x00
\end{DoxyItemize}
\item The server builds the header of the response based on the header of the client’s request and does in addition\+:
\begin{DoxyItemize}
\item Construct the payload
\item Take over the Message ID from the corresponding request
\item Set the length to the 8 Bytes + new payload size
\item Take over the Request ID from the corresponding request
\item Set the Message Type to R\+E\+S\+P\+O\+N\+SE (i.\+e. 0x80) or E\+R\+R\+OR (i.\+e. 0x81)
\item Set Return Code to the return code of called method or in case of an Error message to a valid error code
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+2.\+3 Fire\&Forget Communication}


\begin{DoxyItemize}
\item Requests without response message are called fire\&forget. 
\item For the S\+O\+M\+E/\+IP request-\/no-\/return message the client has to do the following for payload and header\+:
\begin{DoxyItemize}
\item Construct the payload
\item Set the Message ID based on the method the client wants to call
\item Set the Length field to 8 bytes (for the part of the S\+O\+M\+E/\+IP header after the length field) + length of the serialized payload
\item Optionally set the Request ID to a unique number (unique for client only)
\item Set the Protocol Version according
\item Set the Interface Version according to the interface definition
\item Set the Message Type to R\+E\+Q\+U\+E\+S\+T\+\_\+\+N\+O\+\_\+\+R\+E\+T\+U\+RN (i.\+e. 0x01)
\item Set the Return Code to 0x00
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+2.\+4 Notification Events}


\begin{DoxyItemize}
\item Notifications describe a general Publish/\+Subscribe-\/\+Concept. Usually the server publishes a service to which a client subscribes. On certain cases the server will send the client an event, which could be for example an updated value or an event that occurred. 
\item S\+O\+M\+E/\+IP is used only for transporting the updated value and not for the publishing and subscription mechanisms. These mechanisms are implemented by S\+O\+M\+E/\+I\+P-\/\+SD.
\item For the S\+O\+M\+E/\+IP notification message the client has to do the following for payload and header\+:
\begin{DoxyItemize}
\item Construct the payload
\item Set the Message ID based on the event the server wants to send
\item Set the Length field to 8 bytes (for the part of the S\+O\+M\+E/\+IP header after the length field) + length of the serialized payload
\item Set the Client ID to 0x00. In case of active Session Handling the Session ID will be incremented upon each transmission.
\item Set the Protocol Version according
\item Set the Interface Version according to the interface definition
\item Set the Message Type to N\+O\+T\+I\+F\+I\+C\+A\+T\+I\+ON (i.\+e. 0x02)
\item Set the Return Code to 0x00
\end{DoxyItemize}
\end{DoxyItemize}

\paragraph*{2.\+2.\+4.\+1 Strategy for sending notifications}


\begin{DoxyItemize}
\item For different use cases different strategies for sending notifications are possible. The following examples are common\+:

{\bfseries a. Cyclic update} — send an updated value in a fixed interval (e.\+g. every 100 ms for safety relevant messages with Alive)

{\bfseries b. Update on change} — send an update as soon as a \char`\"{}value\char`\"{} changes (e.\+g. door open)

{\bfseries c. Epsilon change} — only send an update when the difference to the last value is greater than a certain epsilon. This concept may be adaptive, i.\+e. the prediction is based on a history; thus, only when the difference between prediction and current value is greater than epsilon an update is transmitted.
\end{DoxyItemize}

\subsubsection*{2.\+2.\+5 Fields}


\begin{DoxyItemize}
\item A field represents a status and has a valid value. The consumers subscribing for the field instantly after subscription get the field value as an initial event. 
\item A field is a combination of getter, setter and notification event.
\item The getter of a field is a request/response call that has an empty payload in the request message and the value of the field in the payload of the response message.
\item The setter of a field is a request/response call that has the desired value of the field in the payload of the request message and the value that was set to the field in the payload of the response message.
\item The notifier sends an event message that transports the value of the field to the client when the client subscribes to the field.
\end{DoxyItemize}

\subsubsection*{2.\+2.\+6 Error Handling}


\begin{DoxyItemize}
\item Error handling can be done in the application or the communication layer below. Therefore S\+O\+M\+E/\+IP supports two different mechanisms explained below\+:
\end{DoxyItemize}

\paragraph*{2.\+2.\+6.\+1 Error Handling Return Codes in the Response Messages of methods}


\begin{DoxyItemize}
\item Return Codes in the Response Messages of methods is used to transport application errors and the response data of a method from the provider to the caller of a method.
\end{DoxyItemize}



\paragraph*{2.\+2.\+6.\+2 Explicit Error Messages}


\begin{DoxyItemize}
\item Explicit Error Messages are used to transport application errors and the response data or generic S\+O\+M\+E/\+IP errors from the provider to the caller of a method.
\item If more detailed error information need to be transmitted, the payload of the Error Message (Message Type 0x81) will be filled with error specific data, e.\+g. an exception string. Error Messages will be sent instead of Response Messages.
\item This can be used to handle all different application errors that might occur in the server. In addition, problems with the communication medium or intermediate components (e.\+g. switches) may occur, which have to be handled e.\+g. by means of reliable transport.
\item For more flexible error handling, S\+O\+M\+E/\+IP allows a different message layout specific for Error Messages instead of using the message layout of Response Messages. The recommended layout for the exception message is the following\+: a. Union of specific exceptions. At least a generic exception without fields needs to exist. b. Dynamic Length String for exception description.
\item The union gives the flexibility to add new exceptions in the future in a typesafe manner. The string is used to transport human readable exception descriptions to ease testing and debugging.
\end{DoxyItemize}

\paragraph*{2.\+2.\+6.\+3 Error Processing Overview}

Error handling is based on the message type received (e.\+g. only methods can be answered with a return code) and will be checked in a defined order shown below.

 \hypertarget{adaptive_communicationmanagement_someip_service_discovery}{}\subsubsection{3. Service Discovery(\+S\+O\+M\+E/\+I\+P-\/\+S\+D)}\label{adaptive_communicationmanagement_someip_service_discovery}

\begin{DoxyItemize}
\item S\+O\+M\+E/\+I\+P-\/\+SD is used to
\begin{DoxyItemize}
\item Locate service instances.
\item Detect if service instances are running.
\item Implement the Publish/\+Subscribe handling.
\end{DoxyItemize}
\item S\+O\+M\+E/\+I\+P-\/\+SD depends on S\+O\+M\+E/\+IP. S\+O\+M\+E/\+IP itself supports both T\+CP and U\+DP communications but S\+O\+M\+E/\+IP SD uses S\+O\+M\+E/\+IP only over U\+DP
\end{DoxyItemize}

 \subsection*{3.\+1 S\+O\+M\+E/\+I\+P-\/\+SD Message Format}

We can divide the above mention figure into two parts.

\subsubsection*{3.\+1.\+1 S\+O\+M\+E/\+IP header}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Field() }&\textbf{ Description(\+Default Value)  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Field() }&\textbf{ Description(\+Default Value)  }\\\cline{1-2}
\endhead
Service-\/\+ID(16 bits) &0x\+F\+F\+FF \\\cline{1-2}
Method-\/\+ID(16 bits) &0x8100 \\\cline{1-2}
length(32 bits) &length is measured in bytes and starts with the first byte after the length field and ends with the last byte of the S\+O\+M\+E/\+I\+P-\/\+SD message. \\\cline{1-2}
Client-\/\+ID(16 bits) &Set to 0x0000 \\\cline{1-2}
Session-\/\+ID (16 Bits) &The Session-\/\+ID (S\+O\+M\+E/\+IP header) will be incremented for every S\+O\+M\+E/\+I\+P-\/\+SD message sent.\+The Session-\/\+ID (S\+O\+M\+E/\+IP header) starts with 1 and be 1 even after wrapping. \\\cline{1-2}
Protocol-\/ Version (8 Bits) &0x01 \\\cline{1-2}
Interface-\/ Version (8 Bits) &0x01 \\\cline{1-2}
Message Type (8 bits) &0x02 (Notification) \\\cline{1-2}
Return Code(8 bits) &Return Code(8 bits) \\\cline{1-2}
\end{longtabu}


\subsubsection*{3.\+1.\+2 S\+O\+M\+E/\+I\+P-\/\+SD Header}


\begin{DoxyItemize}
\item The S\+O\+M\+E/\+I\+P-\/\+SD Header starts with an 8 Bit field called Flags as shown in the Figure below. 
\item The Reboot Flag of the S\+O\+M\+E/\+I\+P-\/\+SD Header is set to 1 for all messages after reboot until the Session-\/\+ID in the S\+O\+M\+E/\+I\+P-\/\+Header wraps around and thus starts with 1 again. After this wrap around the Reboot Flag is set to 0.
\item The information for the reboot flag and the Session ID will be kept for multicast, unicast and every sender-\/receiver relation (i.\+e. source address and destination address) separately.
\item This means there will be separate counters for sending and receiving.
\item {\bfseries Sending}
\begin{DoxyItemize}
\item There will be a counter for multicast.
\item There will be a separate counter for each peer for unicast.
\end{DoxyItemize}
\item {\bfseries Receiving}
\begin{DoxyItemize}
\item There will be a counter for each peer for multicast.
\item There will be a counter for each peer for unicast.
\end{DoxyItemize}
\item The Unicast Flag of the S\+O\+M\+E/\+I\+P-\/\+SD Header is set to Unicast (that means 1) for all SD Messages since this means that receiving using unicast is supported.
\item The third flag of the S\+O\+M\+E/\+I\+P-\/\+SD Flags (third highest order bit) will be called Explicit Initial Data Control Flag and means that the E\+CU supports explicit initial data control.
\item After the S\+O\+M\+E/\+I\+P-\/\+SD Header the Entries Array follows. The entries will be processed exactly in the order they arrive.
\item After the Entries Array in the S\+O\+M\+E/\+I\+P-\/\+SD Header an Option Array will follow.
\end{DoxyItemize}

\paragraph*{3.\+1.\+2.\+1 Entry Format}


\begin{DoxyItemize}
\item The service discovery supports multiple entries that are combined in one service discovery message. The entries are used to synchronize the state of services instances and the Publish/\+Subscribe handling.
\item Two types of entries exist\+: A Service Entry Type for Services and an Eventgroup Entry Type for Eventgroups.
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+1.\+1 Service Entry Type for Services}


\begin{DoxyItemize}
\item Type Field \mbox{[}uint8\mbox{]}\+: encodes Find\+Service (0x00) and Offer\+Service (0x01).
\item Index First Option Run \mbox{[}uint8\mbox{]}\+: Index of this runs first option in the option array.
\item Index Second Option Run \mbox{[}uint8\mbox{]}\+: Index of this runs second option in the option array.
\item Number of Options 1 \mbox{[}uint4\mbox{]}\+: Describes the number of options the first option run uses.
\item Number of Options 2 \mbox{[}uint4\mbox{]}\+: Describes the number of options the second option run uses.
\item Service-\/\+ID \mbox{[}uint16\mbox{]}\+: Describes the Service ID of the Service or Service-\/\+Instance this entry is concerned with.
\item Instance ID \mbox{[}uint16\mbox{]}\+: Describes the Service Instance ID of the Service Instance this entry is concerned with or is set to 0x\+F\+F\+FF if all service instances of a service are meant.
\item Major Version \mbox{[}uint8\mbox{]}\+: Encodes the major version of the service (instance).
\item T\+TL \mbox{[}uint24\mbox{]}\+: Describes the lifetime of the entry in seconds.
\item Minor Version \mbox{[}uint32\mbox{]}\+: Encodes the minor version of the service.
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+1.\+2 Eventgroup Entry Type for Eventgroups}


\begin{DoxyItemize}
\item Type Field \mbox{[}uint8\mbox{]}\+: encodes Subscribe (0x06), and Subscribe\+Ack (0x07).
\item Index First Option Run \mbox{[}uint8\mbox{]}\+: Index of this runs first option in the option array.
\item Index Second Option Run \mbox{[}uint8\mbox{]}\+: Index of this runs second option in the option array.
\item Number of Options 1 \mbox{[}uint4\mbox{]}\+: Describes the number of options the first option run uses.
\item Number of Options 2 \mbox{[}uint4\mbox{]}\+: Describes the number of options the second option run uses.
\item Service-\/\+ID \mbox{[}uint16\mbox{]}\+: Describes the Service ID of the Service or Service Instance this entry is concerned with.
\item Instance ID \mbox{[}uint16\mbox{]}\+: Describes the Service Instance ID of the Service Instance this entry is concerned with or is set to 0x\+F\+F\+FF if all service instances of a service are meant.
\item Major Version \mbox{[}uint8\mbox{]}\+: Encodes the major version of the service instance this eventgroup is part of.
\item T\+TL \mbox{[}uint24\mbox{]}\+: Descibes the lifetime of the entry in seconds.
\item Reserved \mbox{[}uint8\mbox{]}\+: Set to 0x00.
\item Initial Data Requested Flag \mbox{[}1 bit\mbox{]} (I Flag)\+: Set to 1, if initial data will sent by Server
\item Reserved2 \mbox{[}uint3\mbox{]}\+: Set to 0x0.
\item Counter \mbox{[}uint4\mbox{]}\+: Is used to differentiate identical Subscribe Eventgroups of the same subscriber. Set to 0x0 if not used.
\item Eventgroup ID \mbox{[}uint16\mbox{]}\+: Transports the ID of an Eventgroup.
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+1.\+3 Referencing Options from Entries}


\begin{DoxyItemize}
\item Index First Option Run\+: Index into array of options for first option run. Index 0 means first of S\+O\+M\+E/\+I\+P-\/\+SD packet.
\item Index Second Option Run\+: Index into array of options for second option run. Index 0 means first of S\+O\+M\+E/\+I\+P-\/\+SD packet.
\item Number of Options 1\+: Length of first option run. Length 0 means no option in option run.
\item Number of Options 2\+: Length of second option run. Length 0 means no option in option run.
\item Two different option runs exist\+: First Option Run and Second Option Run. Two different types of options are expected\+: options common between multiple S\+O\+M\+E/\+I\+P-\/\+SD entries and options different for each S\+O\+M\+E/\+I\+P-\/\+SD entry. Supporting to different options runs is the most efficient way to support these two types of options, while keeping the wire format highly efficient.
\item Each option run will reference the first option and the number of options for this run.
\item If the number of options is set to zero, the option run is considered empty.
\item For empty runs the Index (i.\+e. Index First Option Run and/or Index Second Option Run) will set to zero.
\end{DoxyItemize}

\paragraph*{3.\+1.\+2.\+2 Options Format}


\begin{DoxyItemize}
\item Options are used to transport additional information to the entries. This includes for instance the information how a service instance is reachable (I\+P-\/\+Address, Transport Protocol, Port Number).
\item In order to identify the option type every option starts with\+:
\begin{DoxyItemize}
\item Length \mbox{[}uint16\mbox{]}\+: Specifies the length of the option in Bytes.
\item Type \mbox{[}uint8\mbox{]}\+: Specifying the type of the option.
\end{DoxyItemize}
\item The length field covers all bytes of the option except the length field and type field.
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+2.\+1 Configuration Option}


\begin{DoxyItemize}
\item The configuration option is used to transport arbitrary configuration strings. This allows to encode additional information like the name of a service or its configuration. 
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+2.\+2 Load Balancing Option}


\begin{DoxyItemize}
\item The Load Balancing option is used to prioritize different instances of a service, so that a client chooses the service instance based on these settings. This option will be attached to Offer Service entries.
\item The Load Balancing Option carry a Priority and Weight, which is used for load balancing different service instances. 
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+2.\+3 I\+Pv4 Endpoint Option}


\begin{DoxyItemize}
\item The I\+Pv4 Endpoint Option is used by a S\+O\+M\+E/\+I\+P-\/\+SD instance to signal the relevant endpoint(s).
\item Endpoints include the local IP address, the transport layer protocol (e.\+g. U\+DP or T\+CP), and the port number of the sender.
\item These ports are used for the events and notification events as well. 
\item This option is used by the server for its Offer\+Service entry and by client for Subscribe Eventgroup entry.
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+2.\+4 I\+Pv6 Endpoint Option}


\begin{DoxyItemize}
\item The I\+Pv6 Endpoint Option is used by a S\+O\+M\+E/\+I\+P-\/\+SD instance to signal the relevant endpoint(s).
\item Endpoints include the local IP address, the transport layer protocol (e.\+g. U\+DP or T\+CP), and the port number of the sender.
\item ports are used for the events and notification events as well.
\item This option is used by the server for its Offer\+Service entry and by client for Subscribe Eventgroup entry. 
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+2.\+5 I\+Pv4 Multicast Option}


\begin{DoxyItemize}
\item The I\+Pv4 Multicast Option is used by the server to announce the I\+Pv4 multicast address, the transport layer protocol (I\+S\+O/\+O\+SI layer 4), and the port number the multicast events and multicast notification events are sent to.
\item As transport layer protocol currently only U\+DP is supported.
\item The I\+Pv4 Multicast Option is referenced by Subscribe Eventgroup Ack entries.
\item The server reference the I\+Pv4 Multicast Option, which encodes the I\+Pv4 Multicast Address and Port Number the server will send multicast events and notification events to. 
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+2.\+6 I\+Pv6 Multicast Option}


\begin{DoxyItemize}
\item The I\+Pv6 Multicast Option is used by the server to announce the I\+Pv6 multicast address, the layer 4 protocol, and the port number the multicast events and multicast notifications events are sent to.
\item For the transport layer protocol (I\+S\+O/\+O\+SI layer 4) currently only U\+DP is supported.
\item The I\+Pv6 Multicast Option, referenced by Subscribe Eventgroup Ack messages.
\item The server references the I\+Pv6 Multicast Option, which encodes the I\+Pv6 Multicast Address and Port Number the server will send multicast events and notification events to. 
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+2.\+7 I\+Pv4 SD Endpoint Option}


\begin{DoxyItemize}
\item The I\+Pv4 SD Endpoint Option is used to transport the endpoint (i.\+e. I\+P-\/\+Address and Port) of the senders SD implementation.
\item This is used to identify the S\+O\+M\+E/\+I\+P-\/\+SD Instance even in cases in which the I\+P-\/\+Address and/or Port Number cannot be used.
\item A use case would be a proxy service discovery on one E\+CU which handles the multicast traffic for another E\+CU. 
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+2.\+8 I\+Pv6 SD Endpoint Option}


\begin{DoxyItemize}
\item The Ipv6 SD Endpoint Option is used to transport the endpoint (i.\+e. I\+P-\/\+Address and Port) of the senders SD implementation.
\item This is used to identify the S\+O\+M\+E/\+I\+P-\/\+SD Instance even in cases in which the I\+P-\/\+Address and/or Port Number cannot be used.
\item A use case would be a proxy service discovery on one E\+CU which handles the multicast traffic for another E\+CU. 
\item Example\+:Below Figure shows an example with the different Endpoint and a Multicast Option\+:
\item The Server offers the Service Instance on Server U\+D\+P-\/\+Endpoint SU and Server T\+C\+P-\/\+Endpoint ST
\item The Client sends a Subscribe Eventgroup entry with Client U\+D\+P-\/\+Endpoint CU (unicast) and a Client T\+C\+P-\/\+Endpoint CT. 
\end{DoxyItemize}

\subsubsection*{3.\+1.\+3 Service Entries}

\paragraph*{3.\+1.\+3.\+1 Find Service Entry}


\begin{DoxyItemize}
\item The Find Service entry type is used for finding service instances and will only be sent if the current state of a service is unknown.(no current Service Offer was received and is still valid).
\item Find Service entries sets the entry fields in the following way\+: \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Field }&\textbf{ Description(\+Default Value)  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Field }&\textbf{ Description(\+Default Value)  }\\\cline{1-2}
\endhead
Type &0x00 (Find\+Service) \\\cline{1-2}
Service ID &Set to the Service ID of the service \\\cline{1-2}
Instance ID &0x\+F\+F\+FF(all service instances) or Instance ID of a specific service instance \\\cline{1-2}
Major Version &0x\+FF \\\cline{1-2}
Minor Version &0x\+F\+F\+F\+F\+F\+F\+FF(services with any version will be returned) or set to a value different to 0x\+F\+F\+FF F\+F\+FF, services with this specific minor version will be returned only \\\cline{1-2}
T\+TL &Set to the lifetime of the Find Service entry. After this lifetime the Find Service entry is considered not existing. If T\+TL is set to 0x\+F\+F\+F\+F\+FF, the Find Service entry is considered valid until the next reboot. T\+TL will not be set to 0x000000 since this is considered to be the Stop Find Service Entry. \\\cline{1-2}
\end{longtabu}

\item Find the wireshark output for Find\+Service service below.
\item Consider IP address 192.\+168.\+7.\+4 for consumer application, 192.\+168.\+7.\+2 for producer application and 224.\+244.\+224.\+245 as a multicast address.
\end{DoxyItemize}

 \paragraph*{3.\+1.\+3.\+2 Offer Service Entry}


\begin{DoxyItemize}
\item The Offer Service entry type is used to offer a service to other communication partners.
\item Offer Service entries sets the entry fields in the following way\+: \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Field }&\textbf{ Description(\+Default Value)  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Field }&\textbf{ Description(\+Default Value)  }\\\cline{1-2}
\endhead
Type &0x01 (Offer\+Service) \\\cline{1-2}
Service ID &Set to the Service ID of the service instance offered. \\\cline{1-2}
Instance ID &Set to the Instance ID of the service instance that is offered \\\cline{1-2}
Major Version &Set to the Major Version of the service instance that is offered. \\\cline{1-2}
Minor Version &Set to the Minor Version of the service instance that is offered. \\\cline{1-2}
T\+TL &Set to the lifetime of the Offer Service entry. After this lifetime the Offer Service entry is considered not existing. If T\+TL is set to 0x\+F\+F\+F\+F\+FF, the Offer Service entry will be considered valid until the next reboot. T\+TL will not be set to 0x000000 since this is considered to be the Stop Offer Service Entry. \\\cline{1-2}
\end{longtabu}

\item Find the wireshark output for Offer\+Service service below.
\item Consider IP address 192.\+168.\+7.\+4 for consumer application, 192.\+168.\+7.\+2 for producer application and 224.\+244.\+224.\+245 as a multicast address.
\end{DoxyItemize}

 \subsubsection*{3.\+1.\+4 Eventgroup Entry}

\paragraph*{3.\+1.\+4.\+1 Subscribe Eventgroup Entry}


\begin{DoxyItemize}
\item The Subscribe Eventgroup entry type is used to subscribe to an eventgroup. \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Field }&\textbf{ Description(\+Default Value)  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Field }&\textbf{ Description(\+Default Value)  }\\\cline{1-2}
\endhead
Type &0x06 (Subscribe\+Eventgroup) \\\cline{1-2}
Service ID &set to the Service ID of the service instance that includes the eventgroup subscribed to. \\\cline{1-2}
Instance ID &set to the Instance ID of the service instance that includes the eventgroup subscribed to. \\\cline{1-2}
Major Version &set to the Major Version of the service instance of the eventgroup subscribed to. \\\cline{1-2}
Eventgroup ID &set to the Eventgroup ID of the eventgroup subscribed to. \\\cline{1-2}
Minor Version &set to the Minor Version of the service instance of the eventgroup subscribed to. \\\cline{1-2}
T\+TL &If set to 0x\+F\+F\+F\+F\+FF, the Subscribe Eventgroup entry considered as valid until the next reboot. T\+TL will not be set to 0x000000 since this is considered to be the Stop \\\cline{1-2}
Reserved &set to 0x00 \\\cline{1-2}
Initial Data Requested Flag &set to 1, if the client sends the first subscribe in sequence to trigger the sending of initial events. Set to 0 otherwise \\\cline{1-2}
Reserved2 &set to three 0 bits \\\cline{1-2}
Counter &used to differentiate between parallel subscribes to the same eventgroup of the same service (only difference in endpoint). If not used, set to 0x0. \\\cline{1-2}
\end{longtabu}

\end{DoxyItemize}

\paragraph*{3.\+1.\+4.\+2 Subscribe Eventgroup Acknowledgement (Subscribe Eventgroup Ack) Entry}


\begin{DoxyItemize}
\item The Subscribe Eventgroup Acknowledgment entry type is used to indicate that Subscribe Eventgroup entry was accepted.
\item Type\+: 0x07 (Subscribe\+Eventgroup\+Ack).
\item Service ID, Instance ID, Major Version, Eventgroup ID, Counter, and Reserved are same value as in the Subscribe that is being answered. 
\end{DoxyItemize}

\subsubsection*{3.\+1.\+5 Service Discovery Communication Behavior}


\begin{DoxyItemize}
\item S\+O\+M\+E/\+IP Service Discovery reduces the number of Service Discovery messages by packing entries together whenever possible.
\end{DoxyItemize}

\paragraph*{3.\+1.\+5.\+1 Startup Behavior}


\begin{DoxyItemize}
\item For each Service Instance or Eventgroup the Service Discovery have at least these three phases in regard to sending entries\+:
\begin{DoxyItemize}
\item Initial Wait Phase
\item Repetition Phase
\item Main Phase
\end{DoxyItemize}
\item The service discovery enters the Initial\+Wait Phase for a client service instance when the link on the interface needed for this service instance is up and the client service is requested by the application.
\item The service discovery enters the Initial Wait Phase for a server service instance when the link on the interface needed for this service instance is up and the server service is available.
\item The Service Discovery waits based on the I\+N\+I\+T\+I\+A\+L\+\_\+\+D\+E\+L\+AY after entering the Initial Wait Phase and before sending the first messages for the Service Instance.
\item I\+N\+I\+T\+I\+A\+L\+\_\+\+D\+E\+L\+AY defined as a minimum and a maximum delay.
\end{DoxyItemize}


\begin{DoxyCode}
<\textcolor{keywordtype}{INITIAL-DELAY-MAX-VALUE}>0.1</\textcolor{keywordtype}{INITIAL-DELAY-MAX-VALUE}>
<\textcolor{keywordtype}{INITIAL-DELAY-MIN-VALUE}>0.01</\textcolor{keywordtype}{INITIAL-DELAY-MIN-VALUE}>
\end{DoxyCode}

\begin{DoxyItemize}
\item The wait time will be determined by choosing a random value between the minimum and maximum of I\+N\+I\+T\+I\+A\+L\+\_\+\+D\+E\+L\+AY.
\item After sending the first message the Repetition Phase of this Service Instance/these Service Instances is entered.
\item The Service Discovery waits in the Repetitions Phase based on R\+E\+P\+E\+T\+I\+T\+I\+O\+N\+S\+\_\+\+B\+A\+S\+E\+\_\+\+D\+E\+L\+AY.
\item After each message sent in the Repetition Phase the delay is doubled.
\item The Service Discovery sends out only up to R\+E\+P\+E\+T\+I\+T\+I\+O\+N\+S\+\_\+\+M\+AX entries during the Repetition Phase.
\end{DoxyItemize}


\begin{DoxyCode}
<\textcolor{keywordtype}{INITIAL-REPETITIONS-BASE-DELAY}>0.2</\textcolor{keywordtype}{INITIAL-REPETITIONS-BASE-DELAY}>
<\textcolor{keywordtype}{INITIAL-REPETITIONS-MAX}>3</\textcolor{keywordtype}{INITIAL-REPETITIONS-MAX}>
\end{DoxyCode}

\begin{DoxyItemize}
\item After the Repetition Phase the Main Phase is being entered for a Service Instance.
\item After entering the Main Phase, the provider waits 1$\ast$\+C\+Y\+C\+L\+I\+C\+\_\+\+O\+F\+F\+E\+R\+\_\+\+D\+E\+L\+AY before sending the first offer entry message.
\item In the Main Phase Offer Messages is sent cyclically if a C\+Y\+C\+L\+I\+C\+\_\+\+O\+F\+F\+E\+R\+\_\+\+D\+E\+L\+AY is configured.
\item After a message for a specific Service Instance the Service Discovery waits for 1$\ast$\+C\+Y\+C\+L\+I\+C\+\_\+\+O\+F\+F\+E\+R\+\_\+\+D\+E\+L\+AY before sending the next message for this Service Instance. 
\begin{DoxyCode}
<\textcolor{keywordtype}{OFFER-CYCLIC-DELAY}>2.0</\textcolor{keywordtype}{OFFER-CYCLIC-DELAY}>
\end{DoxyCode}

\item Example\+:
\item A. Initial Wait Phase\+:
\begin{DoxyItemize}
\item 1. Wait for random\+\_\+delay in Range(\+I\+N\+I\+T\+I\+A\+L\+\_\+\+D\+E\+L\+A\+Y\+\_\+\+M\+I\+N, \+\_\+\+M\+A\+X)
\item 2. Send message (Find Service and Offer Service entries)
\end{DoxyItemize}
\item B. Repetition Phase (R\+E\+P\+E\+T\+I\+T\+I\+O\+N\+S\+\_\+\+B\+A\+S\+E\+\_\+\+D\+E\+L\+AY=100ms, R\+E\+P\+E\+T\+I\+T\+I\+O\+N\+S\+\_\+\+M\+AX=2)\+:
\begin{DoxyItemize}
\item 1. Wait 2$^\wedge$0 $\ast$ 100ms
\item Send message (Find Service and Offer Service entries)
\item Wait 2$^\wedge$1 $\ast$ 100ms
\item Send message (Find Service and Offer Service entries)
\end{DoxyItemize}
\item C. Main Phase (as long message is active and C\+Y\+C\+L\+I\+C\+\_\+\+O\+F\+F\+E\+R\+\_\+\+D\+E\+L\+AY is defined)\+:
\begin{DoxyItemize}
\item Wait C\+Y\+C\+L\+I\+C\+\_\+\+O\+F\+F\+E\+R\+\_\+\+D\+E\+L\+AY
\item Send message (Offer Service entries)
\end{DoxyItemize}
\end{DoxyItemize}

\paragraph*{3.\+1.\+5.\+2 Server Answer Behavior}


\begin{DoxyItemize}
\item The Service Discovery delay answers to entries that were received in multicast S\+O\+M\+E/\+I\+P-\/\+SD messages using the configuration item R\+E\+Q\+U\+E\+S\+T\+\_\+\+R\+E\+S\+P\+O\+N\+S\+E\+\_\+\+D\+E\+L\+AY.
\item The R\+E\+Q\+U\+E\+S\+T\+\_\+\+R\+E\+S\+P\+O\+N\+S\+E\+\_\+\+D\+E\+L\+AY will not apply if unicast messages are answered with unicast messages.
\item R\+E\+Q\+U\+E\+S\+T\+\_\+\+R\+E\+S\+P\+O\+N\+S\+E\+\_\+\+D\+E\+L\+AY will be specified by a minimum and a maximum.
\item The actual delay is randomly chosen between minimum and maximum of R\+E\+Q\+U\+E\+S\+T\+\_\+\+R\+E\+S\+P\+O\+N\+S\+E\+\_\+\+D\+E\+L\+AY. 
\begin{DoxyCode}
<\textcolor{keywordtype}{REQUEST-RESPONSE-DELAY}>
  <\textcolor{keywordtype}{MAX-VALUE}>1.5</\textcolor{keywordtype}{MAX-VALUE}>
  <\textcolor{keywordtype}{MIN-VALUE}>1.5</\textcolor{keywordtype}{MIN-VALUE}>
</\textcolor{keywordtype}{REQUEST-RESPONSE-DELAY}>
\end{DoxyCode}

\end{DoxyItemize}

\paragraph*{3.\+1.\+5.\+3 Shutdown Behavior}


\begin{DoxyItemize}
\item When a server service instance of an E\+CU is in the Repetition and Main Phase and is being stopped, a Stop Offer Service entry will be sent out.
\item When a server sends out a Stop Offer Service entry all subscriptions for this service instance get deleted on the server side.\textbackslash{}
\item When the whole E\+C\+Us is being shut down Stop Offer Service entries will be sent out for all service entries and Stop Subscribe Eventgroup entries for Eventgroups.
\item T\+T\+L(\+Time to live) \+: Describes the lifetime of the entry in seconds
\end{DoxyItemize}


\begin{DoxyCode}
<\textcolor{keywordtype}{SERVICE-OFFER-TIME-TO-LIVE}>10</\textcolor{keywordtype}{SERVICE-OFFER-TIME-TO-LIVE}>
\end{DoxyCode}
 \subsubsection*{3.\+1.\+6 Generation of vsomeip.\+json}


\begin{DoxyItemize}
\item In case of adaptive platform, vsomeip.\+json will get generated from system\+\_\+manifest.\+arxml file by using jsongen.\+py scripts.
\end{DoxyItemize}

\hypertarget{adaptive_communicationmanagement_aracom}{}\subsection{A\+RA Com A\+PI}\label{adaptive_communicationmanagement_aracom}

\begin{DoxyItemize}
\item Existing communication middleware A\+P\+I/technology are listed below\+:
\begin{DoxyItemize}
\item {\bfseries R\+O\+S(\+Robot Operating System) A\+PI}
\item {\bfseries D\+D\+S(\+Data Distribution Service) A\+PI}
\item {\bfseries Common\+A\+P\+I(\+G\+E\+N\+I\+V\+I)}
\item {\bfseries D\+A\+D\+DY A\+P\+I(\+Bosch)}
\end{DoxyItemize}
\item Decision to come up with a new and A\+U\+T\+O\+S\+A\+R-\/specific Communication Management A\+PI was due to the fact, that not all of the key requirements were met by existing solutions\+:
\begin{DoxyItemize}
\item Need for a Communication Management, which is N\+OT bound to a concrete network communication protocol. It has to support the S\+O\+M\+E/\+IP protocol along with the flexibility to exchange that.
\item The A\+U\+T\+O\+S\+AR service model, which defines services as a collection of provided methods, events and fields are supported naturally/straight forward.
\item The A\+PI supports an event-\/driven and a polling model to get access to communicated data equally . The latter is needed by real-\/time applications to avoid unnecessary context switches, while the former is much more convenient for applications without real-\/time requirements.
\item Possibility for seamless integration of end-\/to-\/end protection to fulfill A\+S\+IL requirements.
\item Support for static (preconfigured) and dynamic (runtime) selection of service instances to communicate with.
\end{DoxyItemize}
\end{DoxyItemize}

\begin{quote}
{\bfseries ara\+::com only defines the A\+PI signatures and its behaviour visible to the application developer. Providing an implementation of those A\+P\+Is and the underlying middleware transport layer is the responsibility of the A\+U\+T\+O\+S\+AR AP vendor.} \end{quote}


\section*{1. High Level A\+PI Structure}

\subsection*{1.\+1 Proxy/\+Skeleton Architecture}


\begin{DoxyItemize}
\item The basic idea of this pattern is, that from a formal service definition two code artifacts are generated\+: 
\begin{DoxyItemize}
\item {\bfseries Service Proxy}\+: This code is from the perspective of the service consumer, which wants to use a possibly remote service. Service proxy represents this service on code level.
\item {\bfseries Service Skeleton}\+: This code is from the perspective of the service implementation, which provides functionalities according to the service definition -\/ Connects the service implementation to the Communication Management transport layer, so that the service implementation can be contacted by distributed service consumers.
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{1.\+2 Datatype Abstractions}


\begin{DoxyItemize}
\item ara\+::com A\+PI introduces specific datatypes, which are used throughout its various interfaces. They can roughly be divided into the following classes\+:
\begin{DoxyItemize}
\item {\bfseries Pointer types\+:} for pointers to data transmitted via middleware
\item {\bfseries Collection types\+:} for collections of data transmitted via middleware
\item {\bfseries Types for async operation result management\+:} ara\+::com specific versions of C++ std\+::future and std\+::promise
\item {\bfseries Function wrappers\+:} for various application side callback or handler functions to be called by the middleware
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{1.\+3 Error Notification}


\begin{DoxyItemize}
\item ara\+::com A\+PI uses C++ exceptions to notify the user of the A\+PI about any errors occurred.
\end{DoxyItemize}

\subsubsection*{1.\+3.\+1 Checked Exceptions}


\begin{DoxyItemize}
\item Checked Exceptions within ara\+::com A\+PI can only occur in the context of a call of a service interface method
\end{DoxyItemize}

\subsubsection*{1.\+3.\+2 Unchecked Exceptions}


\begin{DoxyItemize}
\item Unchecked Exceptions within ara\+::com A\+PI can basically occur in the context of any ara\+::com A\+PI call and are fully ara\+::com implementation specific! A property of unchecked exceptions is, that programs/program artifacts hitting such an exception can typically not recover from it.
\end{DoxyItemize}

\section*{2. A\+PI Elements}


\begin{DoxyItemize}
\item A virtual service (interface) called "Radar\+Service is defined in the below example.
\end{DoxyItemize}


\begin{DoxyItemize}
\item So the example service Radar\+Service provides an event called “\+Brake\+Event”, which consists of a structure containing a flag and a variable length array of uint8 (as extra payload). A field “\+Update\+Rate”, which is of type uint32 (supports get and set calls) and methods Adjust, Calibrate and Log\+Current\+State.
\item Method “\+Adjust” is used to position the radar. It contains a target position as in-\/parameter and two out-\/parameters. One to signal the success of the positioning and other to report the final (maybe deviating) effective position. The method “\+Calibrate” is used to calibrate the radar. It contains a configuration string as in-\/parameter and returning a success indicator as an out-\/parameter. \char`\"{}\+Calibrate\char`\"{} method may raise two different application errors, in case of the calibration failure\+: “\+Calibration\+Failed” and “\+Invalid\+Config\+String”. The method “\+Log\+Current\+State” is a one way method, which means, no feedback is returned to the caller. It instructs the service Radar\+Service to output its current state into its local log files.
\end{DoxyItemize}

\subsection*{2.\+1 Common Types}

\subsubsection*{2.\+1.\+1 Optional data elements}


\begin{DoxyItemize}
\item The structure in below Figure has the optional declared elements \char`\"{}current and health\char`\"{}. These elements are not mandatorily present. The consuming application has to check whether the optional elements contain a value or not during runtime. Optional element contains a may or may not contain a value depends on the providing application. The providing application may or may not set the value for that specific instance. The feature of optional contained elements provide forward and backward compatibility of the service interface as new added record elements can just be ignored by old applications. \begin{DoxyVerb}struct BatteryState {
  Voltage_t voltage;
  Temperature_t temperature;
  ara::com::optional<Current_t> current;
  ara::com::optional<Health> health;
};
\end{DoxyVerb}

\end{DoxyItemize}

\subsubsection*{2.\+1.\+2 Instance Identifier}


\begin{DoxyItemize}
\item Instance identifiers are used within ara\+::com during following scenarios\+:
\begin{DoxyItemize}
\item On client/proxy side when a specific instance of a service will be searched for.
\item At the server/skeleton side when a specific instance of a service is created.
\end{DoxyItemize}
\item At ara\+::com A\+PI level the instance identifier is a technical binding specific identifier. The content of instance identifier are totally technology specific.
\item Example\+: S\+O\+M\+E/\+IP is using 16 bit unsigned integer, while D\+DS (D\+D\+S-\/\+R\+PC) uses string$<$256$>$ as service\+\_\+instance\+\_\+name.
\item Independant of the binding technology, instance identifier complying to a signature given below. 
\begin{DoxyCode}
  \textcolor{keyword}{class }InstanceIdentifier \{
  \textcolor{keyword}{public}:
  \textcolor{keyword}{static} \textcolor{keyword}{const} InstanceIdentifier Any;

  \textcolor{keyword}{explicit} InstanceIdentifier(std::string value);
  std::string toString() \textcolor{keyword}{const};
  \textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} InstanceIdentifier& other) \textcolor{keyword}{const};
  \textcolor{keywordtype}{bool} operator<(\textcolor{keyword}{const} InstanceIdentifier& other) \textcolor{keyword}{const};
  InstanceIdentifier& operator=(\textcolor{keyword}{const} InstanceIdentifier& other);

\};
\end{DoxyCode}

\item An ara\+:com provided functionality, which translates a logical local name used by the software developer in his realm into the technology/binding specific ara\+::com\+::\+Instance\+Identifier.
\item The local name from which the ara\+::com\+::\+Instance\+Identifier is constructed comes basically from A\+U\+T\+O\+S\+AR meta-\/model, describing your software component model.
\item The requirement for this local name(abstract identifier) is, that it is unambiguous within an executable. It has basically the form\+:
\end{DoxyItemize}


\begin{DoxyCode}
<context 0>::<context 1>::...::<context N>::<port name>
\end{DoxyCode}
 If the unambiguousness is ensured, the integrator/deployer can assign a dedicated technical binding with its specific instance ids to those abstract identifiers via a \char`\"{}manifest file\char`\"{}, which is specifically used for a distinct instantiation/execution of the executable.
\begin{DoxyItemize}
\item This explicitly allows, to start the same executable N times, each time with a different manifest, which maps the same abstract identifier differently.
\item The A\+PI ara\+:com provides, to do the translation from the abstract identifier (local name in the software developers realm) to the technical ara\+::com\+::\+Instance\+Identifier, is the following\+:
\end{DoxyItemize}


\begin{DoxyCode}
std::vector<InstanceIdentifier> ResolveInstanceIdentifiers(ara::meta::ModelIdentifier modelName);
\end{DoxyCode}

\begin{DoxyItemize}
\item A\+PI does return a list of ara\+::com\+::\+Instance\+Identifier
\item A\+U\+T\+O\+S\+AR supports, that the integrator may configure multiple technical bindings behind one abstract identifier visible to the software component developer.\+This feature is called multi-\/binding.
\item Using multi-\/binding on the skeleton/ server side is a common use case, since it simply allows different clients to use their preferred binding, when contacting the server.
\item On the Contrary using multi-\/binding on the proxy/client side is a rather exotic one. E.\+g. it could be used to support some failover approaches (if binding A does not work, fall back on binding B).
\item The possible returns for a call of Resolve\+Instance\+Identifiers() are\+:
\begin{DoxyItemize}
\item empty list\+: The integrator failed to provide a mapping for the abstract identifier. This most likely is a configuration error.
\item list with one element\+: The common case. No multi-\/binding.
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{2.\+2 Proxy Class}


\begin{DoxyItemize}
\item ara\+::com does standardization of the interface of the generated Proxy class. \begin{quote}
{\bfseries Note\+:The interfaces , Proxy class has to provide are defined by ara\+::com, a generic (product independent) generator could generate an abstract class or a mock class against which the application developer could implement the service consumer application. This perfectly suits the platform vendor independent development of Adaptive A\+U\+T\+O\+S\+AR S\+W\+Cs.} \end{quote}

\item ara\+::com expects proxy related artifacts inside a namespace \char`\"{}proxy\char`\"{}. This namespace is typically included in a namespace hierarchy deduced from the service definition and its context. 
\begin{DoxyCode}
\textcolor{keyword}{class }RadarServiceProxy \{
  \textcolor{keyword}{public}:
  \textcolor{comment}{/* }
\textcolor{comment}{   * brief Implementation is platform vendor specific}
\textcolor{comment}{   * A HandleType must contain the information that is needed to create a}
\textcolor{comment}{     proxy.}
\textcolor{comment}{   * This information will be hidden.}
\textcolor{comment}{   * Since the platform vendor is responsible for creation of handles, the}
\textcolor{comment}{   * ctor signature is not given as it is not of interest to the user.}
\textcolor{comment}{   */}

  \textcolor{keyword}{class }HandleType \{
  \textcolor{comment}{/*}
\textcolor{comment}{   * brief Two ServiceHandles are considered equal if they represent the}
\textcolor{comment}{     same service instance.}
\textcolor{comment}{   * param other}
\textcolor{comment}{   * return}
\textcolor{comment}{   */}
  \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} HandleType &other) \textcolor{keyword}{const};
  \textcolor{keyword}{const} ara::com::InstanceIdentifier &GetInstanceId() \textcolor{keyword}{const};
  \};

  \textcolor{comment}{/*}
\textcolor{comment}{   * StartFindService does not need an explicit version parameter as this}
\textcolor{comment}{     is internally available in ProxyClass}
\textcolor{comment}{   * That means only compatible services are returned.}
\textcolor{comment}{   *}
\textcolor{comment}{   * param handler this handler gets called any time the service}
\textcolor{comment}{     availability of the services matching the given}
\textcolor{comment}{   * instance criteria changes. If you use this variant of FindService,}
\textcolor{comment}{     the Communication Management has to}
\textcolor{comment}{   * continuously monitor the availability of the services and call the}
\textcolor{comment}{     handler on any change.}
\textcolor{comment}{   *}
\textcolor{comment}{   * param instance which instance of the service type defined by T will}
\textcolor{comment}{     be searched/found. Wildcards may be given.}
\textcolor{comment}{   * Default value is wildcard.}
\textcolor{comment}{   *}
\textcolor{comment}{   * return a handle for this search/find request, which will be used to }
\textcolor{comment}{     stop the availability monitoring and related}
\textcolor{comment}{   * firing of the given handler. (\(\backslash\)see StopFindService())}
\textcolor{comment}{   **/}
  \textcolor{keyword}{static} ara::com::FindServiceHandle StartFindService(
  ara::com::FindServiceHandler<RadarServiceProxy::HandleType> handler,
  ara::com::InstanceIdentifier instance =
  ara::com::InstanceIdentifier::Any);

  \textcolor{comment}{/*}
\textcolor{comment}{   * Method to stop finding service request (see above)}
\textcolor{comment}{   */}
  \textcolor{keyword}{static} \textcolor{keywordtype}{void} StopFindService(ara::com::FindServiceHandle handle);

  \textcolor{comment}{/*}
\textcolor{comment}{   * Opposed to StartFindService(handler, instance) this version is a "oneshot"}
\textcolor{comment}{     find request, which is}
\textcolor{comment}{   * - synchronous, i.e. it returns after the find has been done and a}
\textcolor{comment}{    result list of matching service instances is}
\textcolor{comment}{   * available. (list may be empty, if no matching service instances }
\textcolor{comment}{     currently exist)}
\textcolor{comment}{   * - does reflect the availability at the time of the method call. No}
\textcolor{comment}{    further (background) checks of availability}
\textcolor{comment}{   * are done.}
\textcolor{comment}{   *}
\textcolor{comment}{   * param instance which instance of the service type defined by T will}
\textcolor{comment}{     searched/found. Wildcards may be given.}
\textcolor{comment}{   * Default value is wildcard.}
\textcolor{comment}{   */}
  \textcolor{keyword}{static} ara::com::ServiceHandleContainer<RadarServiceProxy::HandleType>
  FindService(
  ara::com::InstanceIdentifier instance =
  ara::com::InstanceIdentifier::Any);

  \textcolor{comment}{/*}
\textcolor{comment}{   * brief The proxy can only be created using a specific handle which}
\textcolor{comment}{    identifies a service.}
\textcolor{comment}{   *}
\textcolor{comment}{   * This handle can be a known value which is defined at deployment or it }
\textcolor{comment}{     can be obtained using the ProxyClass::FindService method.}
\textcolor{comment}{   *}
\textcolor{comment}{   * param handle The identification of the service the proxy should represent.}
\textcolor{comment}{   */}
  \textcolor{keyword}{explicit} RadarServiceProxy(HandleType &handle);

  \textcolor{comment}{/*}
\textcolor{comment}{   * brief Public member for the BrakeEvent}
\textcolor{comment}{   */}
  events::BrakeEvent BrakeEvent;

  \textcolor{comment}{/*}
\textcolor{comment}{   * brief Public Field for UpdateRate}
\textcolor{comment}{   */}
  fields::UpdateRate UpdateRate;

  \textcolor{comment}{/*}
\textcolor{comment}{   * brief Public member for the Calibrate method}
\textcolor{comment}{   */}
  methods::Calibrate Calibrate;

  \textcolor{comment}{/*}
\textcolor{comment}{   * brief Public member for the Adjust method}
\textcolor{comment}{   */}
  methods::Adjust Adjust;

  \textcolor{comment}{/*}
\textcolor{comment}{   * brief Public member for the LogCurrentState fire-and-forget method}
\textcolor{comment}{   */}
  methods::LogCurrentState LogCurrentState;
\};
\end{DoxyCode}

\end{DoxyItemize}

\subsubsection*{2.\+2.\+1 Constructor and Handle Concept}


\begin{DoxyItemize}
\item As seen in the above code, ara\+::com prescribes the Proxy class to provide a constructor. This means, that the developer is responsible for creating a proxy instance to communicate with a possibly remote service. The ctor takes a parameter of type Radar\+Service\+Proxy\+::\+Handle\+Type — an inner class of the generated proxy class.
\item After the call to the ctor, there is proxy instance, which allows to communicate with the service. Therefore the handle has to contain the needed addressing information, so that the Communication Management binding implementation is able to contact the service.
\end{DoxyItemize}

\subsubsection*{2.\+2.\+2 Finding Services}


\begin{DoxyItemize}
\item The Proxy class provides class (static) methods to find service instances, which are compatible with the Proxy class.
\item Since the availability of service instances is dynamic by nature, as they have a life cycle, ara\+::com provides two different ways to do a ‘\+Find\+Service’ for convenience\+:
\begin{DoxyItemize}
\item Start\+Find\+Service is a class method, which starts a continuous ‘\+Find\+Service’ activity in the background, which notifies the caller via a given callback anytime the availability of instances of the service changes.
\item Find\+Service is a one-\/off call, which returns available instances at the point in time of the call.
\end{DoxyItemize}
\item Both of those methods have the instance parameter in common, which allows to either search for an explicit instance of the service or any instance (which is the default parameter value). The synchronous one-\/off variant Find\+Service returns a container of handles for the matching service instances, which might also be empty, if no matching service instance is currently available. Opposed to that, the Start\+Find\+Service returns a Find\+Service\+Handle, which can be used to stop the ongoing background activity of monitoring service instance availability via call to Stop\+Find\+Service. The first (and specific for this variant) parameter to Start\+Find\+Service is a user provided handler function with the following signature\+:
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{keyword}{using} FindServiceHandler = std::function<void(ServiceHandleContainer<T>)>;
\end{DoxyCode}


\paragraph*{2.\+2.\+2.\+1 Auto Update Proxy instance}


\begin{DoxyItemize}
\item Irrespective of the usage of one-\/off Find\+Service or the Start\+Find\+Service variant, in both cases a handle identifying the — possibly remote — service instance is received, from which proxy instance is created.
\item In the service based communication universe it is expected, that during the life time of the entire system (e.\+g. vehicle) service provider and consumer instances start up and go down frequently due to their own life cycle concepts. To deal with this, there is service discovery infrastructure, where the life cycle of service providers and consumers is monitored in terms of service offerings and service (re)subscriptions. If a service consumer application has instantiated a service proxy instance from a handle returned from some of the Find Service variants, the following sequence might possibly occur\+:
\end{DoxyItemize}


\begin{DoxyItemize}
\item Explanation of above figure\+:
\begin{DoxyItemize}
\item {\bfseries T0}\+: The service consumer may successfully call a service method of that proxy and Get\+Subscription\+State() on subscribed events will return k\+Subscribed.
\item {\bfseries T1}\+: The service instance goes down, correctly notified via service discovery.
\item {\bfseries T2}\+: A call of a service method on that proxy will lead to an exception, since the targeted service instance of the call does not exist anymore. Correspondingly Get\+Subscription\+State() on any subscribed event will return k\+Subscription\+Pending at this point even if the event has been successfully subscribed (k\+Subscribed) before.
\item {\bfseries T3}\+: The service instance comes up again, notified via service discovery infrastructure. The CM at the proxy side will be notified and will silently update the proxy object instance with a possibly changed transport layer addressing information.
\item {\bfseries T4}\+:Consequently service method calls on that proxy instance will succeed again and Get\+Subscription\+State() on events which the service consumer had subscribed before, will return k\+Subscribed again.
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+2.\+3 Events}


\begin{DoxyItemize}
\item For each event the remote service provides, the proxy class containing a member of a event specific wrapper class.
\item In the example the member has the name Brake\+Event and is of type events\+::\+Brake\+Event.
\item Below mentioned method gets generated for each event.
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Method }&\textbf{ Description  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Method }&\textbf{ Description  }\\\cline{1-2}
\endhead
void Subscribe(ara\+::com\+::\+Event\+Cache\+Update\+Policy policy, size\+\_\+t cache\+Size); &Used for subscription of events \\\cline{1-2}
ara\+::com\+::\+Subscription\+State Get\+Subscription\+State() const; &Query current subscription state \\\cline{1-2}
void Unsubscribe(); &Unsubscribe from the service \\\cline{1-2}
void Set\+Receive\+Handler(ara\+::com\+::\+Event\+Receive\+Handler handler); &Setting a receive handler signals the Communication Management implementation to use event style mode. \\\cline{1-2}
void Unset\+Receive\+Handler(); &Remove handler set by Set\+Receive\+Handler \\\cline{1-2}
void Set\+Subscription\+State\+Change\+Handler(ara\+::com\+:: Subscription\+State\+Change\+Handler handler); &Setting a subscription state change handler, which gets called by the Communication Management implementation as soon as the subscription state of this event has hanged. \\\cline{1-2}
void Unset\+Subscription\+State\+Change\+Handler(); &Remove handler set by Set\+Subscription\+State\+Change\+Handler \\\cline{1-2}
bool Update(ara\+::com\+::\+Filter\+Function$<$\+Sample\+Type$>$ filter = \{\}); &Fetch data from the Communication Management buffers and apply filter before writing the samples into the cache. \\\cline{1-2}
const ara\+::com\+::\+Sample\+Container$<$ara\+::com\+::\+Sample\+Ptr$<$const Sample\+Type$>$$>$ \& Get\+Cached\+Samples() const; &Get the container of the samples in the cache that was updated by the last call of upadate \\\cline{1-2}
void Cleanup(); &Explicitly clean the application local cache \\\cline{1-2}
\end{longtabu}



\begin{DoxyCode}
\textcolor{keyword}{class }BrakeEvent \{
   \textcolor{comment}{/*}
\textcolor{comment}{   * brief Shortcut for the events data type.}
\textcolor{comment}{   */}
   \textcolor{keyword}{using} SampleType = RadarObjects;

   \textcolor{comment}{/*}
\textcolor{comment}{   * brief The application expects the Communication Management to}
\textcolor{comment}{     subscribe the event.}
\textcolor{comment}{   *}
\textcolor{comment}{   * The Communication Management will try to subscribe and resubscribe}
\textcolor{comment}{     until \(\backslash\)see}
\textcolor{comment}{   * Unsubscribe() is called explicitly.}
\textcolor{comment}{   * The error handling will be kept within the Communication Management.}
\textcolor{comment}{   *}
\textcolor{comment}{   * The function return immediately. If the user wants to get notified,}
\textcolor{comment}{     when subscription has succeeded, he needs}
\textcolor{comment}{   * to register a handler via \(\backslash\)see SetSubscriptionStateChangeHandler().}
\textcolor{comment}{     This handler gets then called after}
\textcolor{comment}{   * subscription was successful.}
\textcolor{comment}{   *}
\textcolor{comment}{   * \(\backslash\)param policy Defines the update policy for the application local cache.}
\textcolor{comment}{   * \(\backslash\)param cacheSize Defines the size of the application local cache.}
\textcolor{comment}{   *}
\textcolor{comment}{   */}
   \textcolor{keywordtype}{void} Subscribe(ara::com::EventCacheUpdatePolicy policy, \textcolor{keywordtype}{size\_t} cacheSize);

   \textcolor{comment}{/*}
\textcolor{comment}{   * brief query current subscription state.}
\textcolor{comment}{   *}
\textcolor{comment}{   * \(\backslash\)return current state of the subscription.}
\textcolor{comment}{   */}
   ara::com::SubscriptionState GetSubscriptionState() \textcolor{keyword}{const};

   \textcolor{comment}{/*}
\textcolor{comment}{   * brief Unsubscribe from the service.}
\textcolor{comment}{   */}
   \textcolor{keywordtype}{void} Unsubscribe();

   \textcolor{comment}{/*}
\textcolor{comment}{   * Setting a receive handler signals the Communication Management }
\textcolor{comment}{     implementation to use event style mode.}
\textcolor{comment}{   * I.e. the registered handler gets called asynchronously by the}
\textcolor{comment}{     Communication Management as soon as new event data}
\textcolor{comment}{   * arrives for that event. If user wants to have strict polling behaviour,}
\textcolor{comment}{     where you decide when to check for}
\textcolor{comment}{   * new data via Update() he should NOT register a handler.}
\textcolor{comment}{   * Handler may be overwritten anytime during runtime.}
\textcolor{comment}{   *}
\textcolor{comment}{   * Provided Handler needs not to be re-entrant since the Communication}
\textcolor{comment}{     Management implementation has to serialize calls}
\textcolor{comment}{   * to the handler: Handler gets called once by the MW, when new events}
\textcolor{comment}{     arrived since the last call to Update().}
\textcolor{comment}{   * When application calls Update() again in the context of the receive}
\textcolor{comment}{     handler, MW must - in case new events arrived}
\textcolor{comment}{   * in the meantime - defer next call to receive handler until after the}
\textcolor{comment}{     previous call to receive handler has been}
\textcolor{comment}{   * completed.}
\textcolor{comment}{   *}
\textcolor{comment}{   **/}
   \textcolor{keywordtype}{void} SetReceiveHandler(ara::com::EventReceiveHandler handler);

   \textcolor{comment}{/*}
\textcolor{comment}{   * Remove handler set by SetReceiveHandler()}
\textcolor{comment}{   **/}
   \textcolor{keywordtype}{void} UnsetReceiveHandler();

   \textcolor{comment}{/*}
\textcolor{comment}{   * Setting a subscription state change handler, which gets called by}
\textcolor{comment}{     the Communication Management}
\textcolor{comment}{   * implementation as soon as the subscription state of this event has}
\textcolor{comment}{     changed.}
\textcolor{comment}{   * Communication Management implementation will serialize calls to the}
\textcolor{comment}{     registered handler. If multiple}
\textcolor{comment}{   * changes of the subscription state take place during the runtime of a}
\textcolor{comment}{     previous call to a handler, the}
\textcolor{comment}{   * Communication Management aggregates all changes to one call with the}
\textcolor{comment}{     last/effective state.}
\textcolor{comment}{   * Handler may be overwritten during runtime.}
\textcolor{comment}{   *}
\textcolor{comment}{   **/}
   \textcolor{keywordtype}{void}  SetSubscriptionStateChangeHandler(ara::com:: SubscriptionStateChangeHandler   handler);

   \textcolor{comment}{/*}
\textcolor{comment}{   * Remove handler set by SetSubscriptionStateChangeHandler()}
\textcolor{comment}{   **/}
   \textcolor{keywordtype}{void} UnsetSubscriptionStateChangeHandler();

   \textcolor{comment}{/*}
\textcolor{comment}{   * brief Fetch data from the Communication Management buffers and apply}
\textcolor{comment}{     filter before}
\textcolor{comment}{   * writing the samples into the cache.}
\textcolor{comment}{   *}
\textcolor{comment}{   * \(\backslash\)pre BrakeEvent::Subscribe has been called before (and not be}
\textcolor{comment}{     withdrawn by BrakeEvent::Unsubscribe)}
\textcolor{comment}{   *}
\textcolor{comment}{   * \(\backslash\)param filter}
\textcolor{comment}{   * parblock}
\textcolor{comment}{   * FilterFunction for the samples.}
\textcolor{comment}{   *}
\textcolor{comment}{   * This filter will be applied to the deserialized data within the}
\textcolor{comment}{     context of}
\textcolor{comment}{   * the update this function should return true if the sample will be}
\textcolor{comment}{     added to}
\textcolor{comment}{   * the cache.}
\textcolor{comment}{   * parblockend}
\textcolor{comment}{   *}
\textcolor{comment}{   * \(\backslash\)return True if new values received and those values are NOT ALL}
\textcolor{comment}{     filtered out,}
\textcolor{comment}{   * else false.}
\textcolor{comment}{   *}
\textcolor{comment}{   * \(\backslash\)note If precondition is not fulfilled, middleware impl might raise an}
\textcolor{comment}{     unchecked exception}
\textcolor{comment}{   * (e.g. NotSubscribed).}
\textcolor{comment}{   */}
   \textcolor{keywordtype}{bool} Update(ara::com::FilterFunction<SampleType> filter = \{\});
   \textcolor{comment}{/*}
\textcolor{comment}{   * brief Get the container of the samples in the cache that was updated}
\textcolor{comment}{     by the last call}
\textcolor{comment}{   * of \(\backslash\)see update.}
\textcolor{comment}{   *}
\textcolor{comment}{   * The container and referenced data is expected to be stable until}
\textcolor{comment}{     update is}
\textcolor{comment}{   * called again.}
\textcolor{comment}{   *}
\textcolor{comment}{   * \(\backslash\)return Container of SamplePtr}
\textcolor{comment}{   */}
   \textcolor{keyword}{const} ara::com::SampleContainer<ara::com::SamplePtr<const SampleType>> &
   GetCachedSamples() \textcolor{keyword}{const};
   \textcolor{comment}{/*}
\textcolor{comment}{   * brief Explicitly clean the application local cache.}
\textcolor{comment}{   *}
\textcolor{comment}{   * This should free the references to the data samples which are owned by}
\textcolor{comment}{     the}
\textcolor{comment}{   * Communication Management.}
\textcolor{comment}{   * This method only has an effect if policy in the call to \(\backslash\)see Subscribe}
\textcolor{comment}{     has been}
\textcolor{comment}{    * set to kNewestN!}
\textcolor{comment}{    */}
    \textcolor{keywordtype}{void} Cleanup();
 \};
\end{DoxyCode}
 \paragraph*{2.\+2.\+3.\+1 Event Subscription and Cache Semantics}


\begin{DoxyItemize}
\item The mere fact, that there exists a member of the event wrapper class inside the proxy instance does not mean, that the user gets instant access to events raised/sent out by service instance. First ‘subscribe’ for the event, in order to tell the Communication Management, that the application is now interested in receiving events. For that purpose the event wrapper class of ara\+::com provides below method\+:
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{comment}{/*}
\textcolor{comment}{ * brief The application expects the Communication Management to}
\textcolor{comment}{    subscribe the event.}
\textcolor{comment}{ *}
\textcolor{comment}{ * ....}
\textcolor{comment}{ *}
\textcolor{comment}{ * \(\backslash\)param policy Defines the update policy for the application local}
\textcolor{comment}{   cache.}
\textcolor{comment}{ * \(\backslash\)param cacheSize Defines the size of the application local cache.}
\textcolor{comment}{ *}
\textcolor{comment}{ */}
  \textcolor{keywordtype}{void} Subscribe(ara::com::EventCacheUpdatePolicy policy, \textcolor{keywordtype}{size\_t} cacheSize);
\end{DoxyCode}

\begin{DoxyItemize}
\item This method expects two parameters, policy and cache\+Size.
\end{DoxyItemize}

\subparagraph*{2.\+2.\+3.\+1.\+1 policy}


\begin{DoxyItemize}
\item With this parameter you control how the cache is updated if you call the Update method. Currently ara\+::com support two policies\+:
\item {\bfseries k\+LastN\+:} With this policy new available events are put in the cache by each call of Update. If they do not fit in the cache, older entries (oldest first) are displaced. With this policy the following applies\+: If the cache has been filled with a certain amount of events, the amount can only remain constant (if no new event has arrived) or get bigger with upcoming Update calls (if new events have been arrived).
\item {\bfseries k\+NewestN\+:} With this policy in each update the cache gets cleared and then filled with the newest arrived events. Even if NO event has arrived since the last call to Update, the cache gets cleared/emptied.
\end{DoxyItemize}

\subparagraph*{2.\+2.\+3.\+1.\+2 cache\+Size}


\begin{DoxyItemize}
\item With calling the method, you not only tell the Communication Management, that you now are interested in receiving event updates, but you are at the same time setting up a local cache for those events bound to the event wrapper instance with the given cache\+Size.
\item The idea behind this is very simple and possible uses are\+:
\begin{DoxyItemize}
\item {\bfseries stability}
\item {\bfseries interpolation/averaging between a number of events}
\item {\bfseries rate adoption}
\end{DoxyItemize}
\item Stability is realized with this concept by having an explicit method (see below) to update event data inside the cache. So this local cache decouples the event-\/wrapper instance from the Communication Management buffers into which the service instance may send its event updates! Updates of the cache status/content is only done explicitly by the user by calling Update.
\end{DoxyItemize}

\paragraph*{2.\+2.\+3.\+2 Monitoring Event Subscription}


\begin{DoxyItemize}
\item The call to the Subscribe method is asynchronous by nature. This means that at the point in time Subscribe returns, it is just the indication, that the Communication Management has accepted the order to care for subscription.
\item If the user needs to monitor the subscription state, he has two possibilities\+:
\begin{DoxyItemize}
\item {\bfseries Polling via Get\+Subscription\+State}
\item {\bfseries Registering a handler, which gets called, when the subscription state changes}
\end{DoxyItemize}
\end{DoxyItemize}

\subparagraph*{2.\+2.\+3.\+2.\+1 Polling via Get\+Subscription\+State}


\begin{DoxyItemize}
\item If the user — after having called Subscribe — wants to get feedback about the success of the subscription, he might call\+: 
\begin{DoxyCode}
\textcolor{comment}{/*}
\textcolor{comment}{ * brief query current subscription state.}
\textcolor{comment}{ *}
\textcolor{comment}{ * \(\backslash\)return current state of the subscription.}
\textcolor{comment}{ */}
ara::com::SubscriptionState GetSubscriptionState() \textcolor{keyword}{const};
\end{DoxyCode}

\end{DoxyItemize}

\subparagraph*{2.\+2.\+3.\+2.\+1 Registering a handler, which gets called, when the subscription state changes}


\begin{DoxyItemize}
\item User register a handler function, for subscription state changes. 
\begin{DoxyCode}
\textcolor{comment}{/*}
\textcolor{comment}{ * Setting a subscription state change handler, which gets called by}
\textcolor{comment}{   the Communication Management implementation as soon}
\textcolor{comment}{ * as the subscription state of this event has changed.}
\textcolor{comment}{ * Handler may be overwritten during runtime.}
\textcolor{comment}{ *}
\textcolor{comment}{ **/}
 \textcolor{keywordtype}{void} SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler);
\end{DoxyCode}

\item Anytime the subscription state changes, the Communication Management implementation calls the registered handler.
\end{DoxyItemize}

\paragraph*{2.\+2.\+3.\+3 Event-\/\+Driven vs Polling-\/\+Based access}


\begin{DoxyItemize}
\item {\bfseries Polling-\/\+Based access}
\begin{DoxyItemize}
\item An explicit interaction needed with ara\+::com A\+PI by calling Update to fill the local event wrapper specific cache\+: 
\begin{DoxyCode}
\textcolor{comment}{/*}
\textcolor{comment}{* brief Fetch data from the Communication Management buffers and apply filter before}
\textcolor{comment}{* writing the samples into the cache.}
\textcolor{comment}{*}
\textcolor{comment}{* \(\backslash\)pre BrakeEvent::Subscribe has been called before (and not be withdrawn by BrakeEvent::Unsubscribe)}
\textcolor{comment}{* \(\backslash\)param filter}
\textcolor{comment}{*  parblock}
\textcolor{comment}{* FilterFunction for the samples.}
\textcolor{comment}{*}
\textcolor{comment}{* This filter will be applied to the deserialized data within the context of}
\textcolor{comment}{* the update this function should return true if the sample is added to}
\textcolor{comment}{* the cache.}
\textcolor{comment}{* parblockend}
\textcolor{comment}{*}
\textcolor{comment}{* \(\backslash\)return True if new values received and those values are NOT ALL filtered out,}
\textcolor{comment}{* else false.}
\textcolor{comment}{*}
\textcolor{comment}{* \(\backslash\)note If precondition is not fulfilled, middleware impl might raise an unchecked exception}
\textcolor{comment}{* (e.g. NotSubscribed).}
\textcolor{comment}{*/}
\textcolor{keywordtype}{bool} Update(ara::com::FilterFunction<SampleType> filter = \{\});
\end{DoxyCode}

\item The method takes an optional parameter of a user defined filter function. 
\begin{DoxyCode}
\textcolor{keyword}{using} FilterFunction = std::function<bool(const S& sample)>;
\end{DoxyCode}

\item the user provided filter function gets an event (sample) and has to return true after checking, if he wants the sample to be put into the local cache.
\item During Update(), the Communication Management calls the filter function for each event, which has arrived since the last call to Update().
\item Update returns true in case new events have been placed into the local cache by the call, false otherwise.
\item After filling event specific local cache with event-\/data via Update() user typically want access those events. This is done with the following A\+PI\+: 
\begin{DoxyCode}
\textcolor{comment}{/*}
\textcolor{comment}{ * brief Get the container of the samples in the cache that was updated by the last call}
\textcolor{comment}{ * of \(\backslash\)see update.}
\textcolor{comment}{ *}
\textcolor{comment}{ * The container and referenced data is expected to be stable until update is}
\textcolor{comment}{ * called again.}
\textcolor{comment}{ *}
\textcolor{comment}{ * \(\backslash\)return Container of SamplePtr}
\textcolor{comment}{ */}
 \textcolor{keyword}{const} ara::com::SampleContainer<ara::com::SamplePtr<const SampleType>> &GetCachedSamples() \textcolor{keyword}{const};
\end{DoxyCode}

\item User can call this method as many times as you want — as long as user do not call Update() in between, the returned collection will always be the same/stable, even if the service side has send out several new events.
\end{DoxyItemize}
\item {\bfseries Event-\/\+Driven}
\item If user explicitly want the Communication Management to notify application thereby issuing asynchronous context switches to application process by below A\+PI.
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{keywordtype}{void} SetReceiveHandler(ara::com::EventReceiveHandler handler);
\end{DoxyCode}

\begin{DoxyItemize}
\item This A\+PI allows user to register a user defined callback, which the Communication Management has to call in case new event data is available since the last call to Update().
\end{DoxyItemize}

\paragraph*{2.\+2.\+3.\+4 Buffering Strategies}


\begin{DoxyItemize}
\item The following figure sketches a simple deployment, where we have a service providing an event, for which two different local adaptive S\+W\+Cs have subscribed through their respective ara\+::com proxies/event wrappers.
\item Both proxies have a local event cache. This is the cache, which gets filled via Update().
\item Service implementation sends its event data to a Communication Management buffer, which is apparently outside the process space of the service implementation
\end{DoxyItemize}


\begin{DoxyItemize}
\item This buffer is owned by kernel or it is realized as a shared memory between communicating proxies and skeleton or owned by a separate binding implementation specific ‘demon’ process.
\begin{DoxyItemize}
\item {\bfseries Kernel Space}
\item {\bfseries Shared Memory}
\item {\bfseries I\+P\+C-\/\+Demon Process}
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+2.\+4 Methods}


\begin{DoxyItemize}
\item For each method the remote service provides, the proxy class contains a member of a method specific wrapper class.
\item In our example, we have two methods and the corresponding members have the name Calibrate (of type methods\+::\+Calibrate) and Adjust (of type methods\+::\+Adjust).
\end{DoxyItemize}


\begin{DoxyItemize}
\item The return value of a call to a service method, which is not a “one-\/way method” is an ara\+::com\+::\+Future, where the template parameter is of the type of the inner struct, which aggregates all O\+U\+T-\/parameters of the method.
\end{DoxyItemize}

\paragraph*{2.\+2.\+4.\+1 One-\/\+Way or Fire-\/and-\/\+Forget Methods}


\begin{DoxyItemize}
\item ara\+::com supports a special flavor of a method, which we call “one-\/way” or “fire-\/and-\/forget”.
\item Technically this is a method with only I\+N-\/params — no O\+U\+T-\/params and no raising of errors allowed.
\item The client/caller therefore gets no feedback at all, whether the server/callee has processed a “one-\/way” call or not.
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{keyword}{class }LogCurrentState \{
  \textcolor{keyword}{public}:
  \textcolor{comment}{/*}
\textcolor{comment}{  * brief Operation will call the method.}
\textcolor{comment}{  *}
\textcolor{comment}{  * Using the operator the call will be made by the Communication Management.}
\textcolor{comment}{  * It is a one-way method, so no feedback (return value/out-parameter) is given.}
\textcolor{comment}{  */}
  \textcolor{keywordtype}{void} operator()();
\};
\end{DoxyCode}
 \paragraph*{2.\+2.\+4.\+2 Event-\/\+Driven vs Polling access to method results}

\subparagraph*{2.\+2.\+4.\+2.\+1 Event-\/\+Driven}


\begin{DoxyItemize}
\item Event-\/\+Driven means, that the caller of the method (the application with the proxy instance) gets notified by the Communication Management implementation as soon as the method call result has arrived.
\item Event driven method call can be achieve with following ways\+:
\begin{DoxyItemize}
\item {\bfseries 1.\+future.\+get()}
\item {\bfseries 2.\+wait(), wait\+\_\+for() or wait\+\_\+until()}
\item {\bfseries 3.\+Registering a callback method via then()}
\end{DoxyItemize}
\end{DoxyItemize}

\subparagraph*{2.\+2.\+4.\+2.\+2 Polling access}


\begin{DoxyItemize}
\item It is used in R\+T(real time) application.
\item ara\+::com\+::\+Future\+::is\+\_\+ready() is used to poll the method whether the method call has been finished.
\item After ara\+::com\+::\+Future\+::is\+\_\+ready() has returned true, it is guaranteed that the next call to ara\+::com\+::\+Future\+::get() will N\+OT block, but immediately return either the valid value or throw an exception in case of error
\end{DoxyItemize}

\paragraph*{2.\+2.\+4.\+3 Canceling Method Result}


\begin{DoxyItemize}
\item There may be cases, where you already have called a service method via the ()-\/ operator, which returned you an ara\+::com\+::\+Future, but you are not interested in the result anymore.
\item It could even be the case, that you already have registered a callback via ara\+::com\+::\+Future\+::then() for it. Instead of just let things go and ‘ignore’ the callback, you should tell the Communication Management explicitly.
\item This might free resources and avoid unnecessary processing load on the binding implementation level.
\item Telling that you are not interested in the method call result anymore is simply done by letting the ara\+::com\+::\+Future go out of scope, so that its destructor gets called.
\item Call of the dtor of the ara\+::com\+::\+Future is a signal to the binding implementation, that any registered callback for this future should not be called anymore, reserved/allocated memory for the method call result might be freed and event waiting mechanisms for the method result should be stopped.
\end{DoxyItemize}

\paragraph*{2.\+2.\+4.\+4 Checked Exception Handling}


\begin{DoxyItemize}
\item Unchecked Exceptions might be thrown by any ara\+::com A\+PI call, whereas Checked Exceptions might be thrown only in the context of non “one-\/way/fire-\/and-\/forget” service interface method calls.
\item There are two types of Checked Exceptions, which might be thrown in the course of a service method call on the proxy side\+:
\item Service\+Not\+Available\+Exception\+:This is a direct subclass of std\+::exception and will be thrown by the middleware implementation, when it detects during processing of a method call, that the providing service instance has already stopped offering the service.
\item Subclasses of ara\+::com\+::\+Application\+Error\+Exception\+:which are defined on meta-\/model level for a specific service interface method as Application\+Error and which are created at the application level service provider (skeleton) side and transported to the caller (proxy) side.
\item If one of those Checked Exception types happens, it will always be thrown in the context of the ara\+::com\+::\+Future\+::\+Get() call.
\item Calibrate method may raise the two application errors Calibration\+Failed and Invalid\+Config\+String, which get transformed to subclasses of ara\+::com\+::\+Application\+Error\+Exception on ara\+::com A\+PI level\+: 
\begin{DoxyCode}
 \textcolor{keyword}{using namespace }ara::com;
 \textcolor{keyword}{using namespace }com::mycompany::division::radarservice;

 Future<Calibrate::Output> calibrateFuture;

 \textcolor{keywordtype}{int} main() \{
 \textcolor{comment}{// some code to acquire handle}
 \textcolor{comment}{// ...}
 RadarServiceProxy service(handle);
 calibrateFuture = service.Calibrate(myConfigString);

 \textcolor{comment}{/* ....}
\textcolor{comment}{ Now we access the future (with potentially blocking) Get()}
\textcolor{comment}{ and directly handle the 3 different checked exceptions, which}
\textcolor{comment}{ might be raised. */}

 \textcolor{keywordflow}{try} \{
 calibrateFuture.Get();
 \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} ServiceNotAvailableException& e) \{
 \textcolor{comment}{// react on service shut down ...}
 cout << \textcolor{stringliteral}{"RadarService not available anymore"} << endl;
 ...
 \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} CalibrationFailed& e) \{
 \textcolor{comment}{// react on Application Error ’CalibrationFailed’ ...}
 cout << \textcolor{stringliteral}{"RadarService calibration failed because: "} << e.getFailureText() << endl;
 ...
 \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} InvalidConfigString& e) \{
 \textcolor{comment}{// react on Application Error ’InvalidConfigString’ ...}
 cout << \textcolor{stringliteral}{"Oops, we called RadarService.Calibrate with invalid config string: "} << e.getInvalidConfig() << 
      endl;
 cout << \textcolor{stringliteral}{"Current (valid) config is: "} << e.getCurrentValidConfig() << endl;
 ...
 \}

 \textcolor{comment}{// go on doing something ...}
 \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}

\end{DoxyItemize}

\subsubsection*{2.\+2.\+5 Fields}


\begin{DoxyItemize}
\item Conceptually a field has — unlike an event — a certain value at any time. That result in the following additions compared to an event\+:
\begin{DoxyItemize}
\item if a subscribtion to a field has been done, “immediately” initial values are sent back to the subscriber in an event-\/like notification pattern.
\item the current field value can be queried via a call to a Get() method or could be updated via a Set() method.
\end{DoxyItemize}
\item Field concept is roughly an aggregation of an event with correlated get()/set() methods.
\begin{DoxyItemize}
\item call Get() or Set() methods of the field with exactly the same mechanism as regular methods
\item access field update notifications in the form of events/event data, which are sent by the service instance our proxy is connected to with exactly the same mechanism as regular events
\end{DoxyItemize}
\end{DoxyItemize}

 \subsection*{2.\+3 Skeleton Class}


\begin{DoxyItemize}
\item The Skeleton class is generated from the service interface description of the A\+U\+T\+O\+S\+AR meta model.
\item ara\+::com does standardize the interface of the generated Skeleton class.
\item The toolchain of an AP product vendor will generate a Skeleton implementation class exactly implementing this interface.
\item The generated Skeleton class is an abstract class. It cannot be instantiated directly, because it does not contain implementations of the service methods, which the service should provide.
\item Therefore the service implementer has to subclass the skeleton and provide the service method implementation within the subclass. 
\end{DoxyItemize}

\subsubsection*{2.\+3.\+1 Instantiation}


\begin{DoxyItemize}
\item Skeleton class from which the service implementer has to subclass his service implementation provides a ctor with a parameter of type ara\+::com\+::\+Instance\+Identifier.
\item This identifier has to be unique — creating two instances in a way that they would exist at the same time with the same instance identifier will raise an exception.
\item If a new instance will be created with the same identifier, the existing instance needs to be destroyed before.
\end{DoxyItemize}

\subsubsection*{2.\+3.\+2 Offering Service instance}


\begin{DoxyItemize}
\item The skeleton provides the method Offer\+Service(). As application developer for the service provider side — have instantiated your custom service implementation class and initialized/set up your instance to a state, where it is now able to serve requests (method calls) and provide events to subscribing consumers, you will call this Offer\+Service() method on your instance.
\item If you decide at a certain point (maybe due to some state changes), that you do not want to provide the service anymore, you call Stop\+Offer\+Service() on your instance.
\end{DoxyItemize}

\subsubsection*{2.\+3.\+3 Polling and event-\/driven processing modes}


\begin{DoxyItemize}
\item The behavior of a skeleton instance is controlled by the second parameter of Skeleton class ctor, which is of type ara\+::com\+::\+Method\+Call\+Processing\+Mode.
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{comment}{/*}
\textcolor{comment}{* Request processing modes for the service implementation side}
\textcolor{comment}{* (skeleton).}
\textcolor{comment}{*}
\textcolor{comment}{* \(\backslash\)note Should be provided by platform vendor exactly like this.}
\textcolor{comment}{*/}
\textcolor{keyword}{enum class} MethodCallProcessingMode \{ kPoll, kEvent, kEventSingleThread \};
\end{DoxyCode}

\begin{DoxyItemize}
\item That means the processing mode is set for the entire service instance (i.\+e. all its provided methods are affected) and is fix for the whole lifetime of the skeleton instance. The default value in the ctor is set to k\+Event.
\end{DoxyItemize}

\paragraph*{2.\+3.\+3.\+1 Polling Mode}


\begin{DoxyItemize}
\item If you set it to k\+Poll, the Communication Management implementation will not call any of the provided service methods asynchronously! If you want to process the next (assume that there is a queue behind the scenes, where incoming service method calls are stored) pending service-\/call, you have to call the following method on your service instance\+:
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{comment}{/*}
\textcolor{comment}{* This fetches the next call from the Communication Management and executes it.}
\textcolor{comment}{* Only available in polling mode. In event mode it throws an exception.}
\textcolor{comment}{*/}
ara::com::Future<bool> ProcessNextMethodCall();
\end{DoxyCode}

\begin{DoxyItemize}
\item A simple use case for a typical RT application could be\+:
\begin{DoxyItemize}
\item RT application gets scheduled.
\item it calls Process\+Next\+Method\+Call and registers a callback with ara\+::com\+::\+Future\+::then()
\item the callback is invoked after the service method called by the midleware corresponding to the outstanding request has finished.
\item in the callback the RT application decides, if there is enough time left for serving a subsequent service method. If so, it calls another Process\+Next\+Method\+Call.
\end{DoxyItemize}
\end{DoxyItemize}

\paragraph*{2.\+3.\+3.\+2 Event-\/\+Driven Mode}


\begin{DoxyItemize}
\item If you set the processing mode to k\+Event or k\+Event\+Single\+Thread, the Communication Management implementation will dispatch events asynchronously to the service method implementations at the time the service call from the service consumer comes in.
\begin{DoxyItemize}
\item {\bfseries k\+Event\+:}
\begin{DoxyItemize}
\item Communication Management implementation may call the service method implementations concurrently.
\item If at the same point in time one call to method Calibrate and two calls to method Adjust arrive from different service consumers, the Communication Management implementation is allowed to take three threads from its internal thread-\/pool and do those three calls for the two service methods concurrently.
\end{DoxyItemize}
\item {\bfseries k\+Event\+Single\+Thread\+:}
\begin{DoxyItemize}
\item k\+Event\+Single\+Thread assures, that on the service instance only one service method at a time will be called by the Communication Management implementation.
\item That means, Communication Management implementation has to queue incoming service method call events for the same service instance and dispatch them one after the other.
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+3.\+4 Methods}


\begin{DoxyItemize}
\item Service methods on the skeleton side are abstract methods, which have to be overwritten by the service implementation sub-\/classing the skeleton.
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{comment}{/*}
\textcolor{comment}{* For all output and non-void return parameters}
\textcolor{comment}{* an enclosing struct is generated, which contains}
\textcolor{comment}{* non-void return value and/or out parameters.}
\textcolor{comment}{*/}
\textcolor{keyword}{struct }AdjustOutput \{
\textcolor{keywordtype}{bool} success;
Position effective\_position;
\};

\textcolor{keyword}{virtual} ara::com::Future<AdjustOutput> Adjust(
\textcolor{keyword}{const} Position& position) = 0;
\end{DoxyCode}

\begin{DoxyItemize}
\item The returned ara\+::com\+::\+Future contains a structure as template parameter, which aggregates all the O\+U\+T-\/parameters of the service call.
\end{DoxyItemize}

\paragraph*{2.\+3.\+4.\+1 Raising Application Errors}


\begin{DoxyItemize}
\item Whenever on the implementation side of a service method, an Application\+Error according to the interface description is detected, the Checked Exception representing this Application\+Error simply has to be stored into the Promise, from which the Future is returned to the caller\+:
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{keyword}{using namespace }ara::com;
\textcolor{keyword}{using namespace }com::mycompany::division::radarservice;

\textcolor{comment}{/* our implementation of RadarService */}
\textcolor{keyword}{class }RadarServiceImpl : \textcolor{keyword}{public} RadarServiceSkeleton \{

\textcolor{keyword}{public}:
Future<CalibrateOutput> Calibrate(\textcolor{keyword}{const} std::string& configuration)
\{
Promise<CalibrateOutput> promise;
\textcolor{keyword}{auto} future = promise.get\_future();

\textcolor{comment}{/* we check the given configuration arg */}
\textcolor{keywordflow}{if} (!checkConfigString(configuration)) \{
\textcolor{comment}{/* given arg is invalid: */}
InvalidConfigString myError(configuration, this->curValidConfig\_));
promise.set\_exception(std::make\_exception\_ptr(myError));
\} \textcolor{keywordflow}{else} \{
...
\}

\textcolor{comment}{/* we return a future with a potentially set exception */}
\textcolor{keywordflow}{return} future;
\}

\textcolor{keyword}{private}:
\textcolor{keywordtype}{bool} checkConfigString(\textcolor{keyword}{const} std::string& config);
std::string curValidConfig\_;
\}
\end{DoxyCode}



\begin{DoxyItemize}
\item In this example, the implementation of ‘\+Calibrate’ detects, that the given configuration string argument is invalid and sets the corresponding exception to the Promise.
\end{DoxyItemize}

\subsubsection*{2.\+3.\+5 Events}


\begin{DoxyItemize}
\item On the skeleton side the service implementation is in charge of notifying about occurrence of an event.
\item The event wrapper class on the skeleton/event provider side looks obviously different than on the proxy/event consumer side.
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{keyword}{class }BrakeEvent \{
\textcolor{keyword}{public}:

\textcolor{comment}{/*}
\textcolor{comment}{* Shortcut for the events data type.}
\textcolor{comment}{*/}
\textcolor{keyword}{using} SampleType = RadarObjects;

\textcolor{keywordtype}{void} Send(\textcolor{keyword}{const} SampleType &data);

ara::com::SampleAllocateePtr<SampleType> Allocate();
 \textcolor{comment}{/*}
\textcolor{comment}{ * After sending data you loose ownership and can’t access}
\textcolor{comment}{ * the data through the SampleAllocateePtr anymore.}
\textcolor{comment}{ * Implementation of SampleAllocateePtr will be with the}
\textcolor{comment}{ * semantics of std::unique\_ptr (see types.h)}
\textcolor{comment}{ **/}
 \textcolor{keywordtype}{void} Send(ara::com::SampleAllocateePtr<SampleType> data);

 \};
\end{DoxyCode}

\begin{DoxyItemize}
\item ara\+::com provides two different variants of a ‘\+Send’ method, which is used to send out new event data.
\end{DoxyItemize}
\begin{DoxyEnumerate}
\item The event data has been allocated somewhere by the service application developer and is given via reference to the binding implementation of Send(). After the call to send returns, the data might be removed/altered on the caller side. The binding implementation will make a copy in the call.
\item The second variant of ‘\+Send’ also has a parameter named ‘data’, but this is now of a different type ara\+::com\+::\+Sample\+Allocatee\+Ptr$<$\+Sample\+Type$>$. ara\+::com introduced here, will behave like a std\+::unique\+\_\+ptr$<$\+T$>$.\+Only one party can hold the pointer -\/ if the owner wants to give it away, he has to explicitly do it via std\+::move.
\item ara\+::com\+::\+Sample\+Allocatee\+Ptr$<$\+Sample\+Type$>$ Allocate();
\begin{DoxyItemize}
\item The event wrapper class provides us here with a method to allocate memory for one sample of event data.
\item It returns a smart pointer ara\+::com\+::\+Sample\+Allocatee\+Ptr$<$\+Sample\+Type$>$, which points to the allocated memory, where we then can write an event data sample to.
\end{DoxyItemize}
\end{DoxyEnumerate}

\subsubsection*{2.\+3.\+6 Fields}


\begin{DoxyItemize}
\item On the skeleton side the service implementation is in charge of
\begin{DoxyItemize}
\item updating and notifying about changes of the value of a field.
\item serving incoming Get() calls.
\item serving incoming Set() calls.
\end{DoxyItemize}
\item The field wrapper class on the skeleton/field provider side looks obviously different than on the proxy/field consumer side. 
\end{DoxyItemize}

\paragraph*{2.\+3.\+6.\+1 Registering Getters}


\begin{DoxyItemize}
\item The Register\+Get\+Handler method provides the possibility to register a method implementation by the service implementer, which gets then called by the binding implementation on an incoming Get() call from any proxy instance.
\item The Register\+Get\+Handler method in the generated skeleton does only exist in case availability of “field getter” has been configured for the field in the configuration.
\end{DoxyItemize}

\paragraph*{2.\+3.\+6.\+1 Registering Setters}


\begin{DoxyItemize}
\item Register\+Set\+Handler A\+PI has to be called by the service implementer in case field has been configured with setter support.
\end{DoxyItemize}

\section*{3 Service Discovery Implementation Strategies}


\begin{DoxyItemize}
\item As the service discovery functionality is basically defined at the A\+PI level with the methods for Find\+Service, Offer\+Service and Stop\+Offer\+Service.
\item When an AP node (more concretely an AP S\+WC) offers a service over the network or requires a service from another network node, then service discovery/service registry obviously takes place over the wire.
\item The protocol for service discovery over the wire needs to be completely specified by the used communication protocol.
\item if an ara\+::com application wants to communicate with another ara\+::com application on the same node within the AP of the same vendor there has to be a local variant of a service discovery available.
\end{DoxyItemize}

\subsection*{3.\+1 Central vs Distributed approach}

\subsubsection*{3.\+1.\+1 Central approach}


\begin{DoxyItemize}
\item This approach have one central entity(a demon process), which\+:
\begin{DoxyItemize}
\item maintains a registry of all service instances together with their location information
\item serves all Find\+Service, Offer\+Service and Stop\+Offer\+Service requests from local ara\+::com applications, thereby either updating the registry (Offer\+Service, Stop\+Offer\+Service) or querying the registry ( Find\+Service)
\item serves all S\+O\+M\+E/\+IP SD messages from the network either updating its registry (S\+O\+M\+E/\+IP Offer Service received) or querying the registry (S\+O\+M\+E/\+IP Find Service received) 
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{3.\+1.\+2 Distributed approach}


\begin{DoxyItemize}
\item This approach would be, to distribute the service registry information (availability and location information) among the ara\+::com applications within the node.\+So for the node local communication use case no prominent discovery demon would be needed. 
\end{DoxyItemize}

\subsection*{3.\+2 Multi-\/\+Binding implications}


\begin{DoxyItemize}
\item Multi-\/\+Binding describes the solution to support setups, where the technical transport/connection between different instances of a certain proxy class/skeleton class are different.
\begin{DoxyItemize}
\item proxy class uses different transport/\+I\+PC to communicate with different skeleton instances. Reason\+: Different service instances support different transport mechanisms because of deployment decisions.
\item symmetrically it may also be the case, that different proxy instances for the same skeleton instance uses different transport/\+I\+PC to communicate with this instance\+: The skeleton instance supports multiple transport mechanisms to get contacted.
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{3.\+2.\+1 Simple Multi-\/\+Binding use case}


\begin{DoxyItemize}
\item The following figure depicts an obvious and/or rather simple case. In this example, which only deals with node local (inside one AP product/\+E\+CU) communication between service consumers (proxy) and service providers (skeleton), there are two instances of the same proxy class on the service consumer side.
\item Service consumer application has triggered a ‘\+Find\+Service’ first, which returned two handles for two different service instances of the searched service type.
\item The service consumer application has instantiated a proxy instance for each of those handles.
\item Now in this example the instance 1 of the service is located inside the same adaptive application (same process/address space) as the service consumer (proxy instance 1), while the service instance 2 is located in a different adaptive application (different process/ address space). 
\end{DoxyItemize}

\subsubsection*{3.\+2.\+2 Local/\+Network Multi-\/\+Binding use case}


\begin{DoxyItemize}
\item After we have seen a special variant of Multi-\/\+Binding in the preceding section, we now look at a variant, which can also be considered as being a real-\/world case.
\item The instance 2 of the service is located on a different E\+CU attached to the same Ethernet network as our E\+CU with the AP product, where the service consumer (with its proxies for instance 1 and 2) resides.
\item As the standard protocol on Ethernet for AP is S\+O\+M\+E/\+IP, it is expected, that the communication between both E\+C\+Us is based on S\+O\+M\+E/\+IP.
\item For our concrete example this means, that proxy 1 talks to service 1 via unix domain sockets (which might be optimized for process local communication to direct method calls), while the proxy 2 talks to service 2 via network sockets in a S\+O\+M\+E/\+IP compliant message format. 
\end{DoxyItemize}

\subsubsection*{3.\+2.\+3 Typical S\+O\+M\+E/\+IP Multi-\/\+Binding use case}


\begin{DoxyItemize}
\item It is highly unlikely that an adaptive S\+WC (i.\+e. the language and network binding which runs in its context) opens socket connections itself to communicate with a remote service.
\item S\+O\+M\+E/\+IP was explicitly designed to use as few ports as possible.
\item The reason for that requirement comes from low power/low resources embedded E\+C\+Us\+:
\item Managing a huge amount of IP sockets in parallel means huge costs in terms of memory (and runtime) resources.
\item A\+U\+T\+O\+S\+AR CP siblings which will be main communication partner in an inside vehicle network demand this approach, which is uncommon, compared to non-\/automotive IT usage pattern for ports.
\item The entire S\+O\+M\+E/\+IP traffic of an E\+CU / network endpoint is routed through one IP port!
\item That means S\+O\+M\+E/\+IP messages originating from/dispatched to many different local applications (service providers or service consumers) are (de)multiplexed to/from one socket connection.
\item P\+O\+S\+IX compatible OS with P\+O\+S\+IX socket A\+PI, multiplexing S\+O\+M\+E/\+IP communication of many applications to/from one port means the introduction of a separate/central (demon) process, which manages the corresponding port.
\item The task of this process is to bridge between S\+O\+M\+E/\+IP network communication and local communication and vice versa. 
\end{DoxyItemize}

\section*{4 ara\+::com and A\+U\+T\+O\+S\+AR meta-\/model relationship}

\subsection*{4.\+1 Service Interface}


\begin{DoxyItemize}
\item Service Interface defines everything signaturewise of an ara\+::com proxy or skeleton.
\item The Service\+Interface describes the methods, fields and the methods a service interface consists of and how the signatures of those elements (arguments and data types) look like.
\item ara\+::com proxy and skeleton classes get generated from Service\+Interface.
\end{DoxyItemize}

\subsection*{4.\+2 Software Component}


\begin{DoxyItemize}
\item The idea of a software component is to describe a reusable part of software with well defined interfaces.
\item A\+U\+T\+O\+S\+AR manifest specification defines a model element Software\+Component\+Type, which is an abstract element with several concrete subtypes, of which the subtype Adaptive\+Application\+Sw\+Component\+Type is the most important one for Adaptive Application software developers. 
\item Software\+Component\+Types A and B from the example in the upper part (meta-\/model level) a concrete implementation exists on implementation level (lower part in the figure).
\item The realization/implementation of R-\/\+Port of Software\+Component\+Type A is based on an instance of ara\+::com proxy class on implementation level, while the P-\/\+Port implementation of Software\+Component\+Type B is using an instance of ara\+::com skeleton class.
\item Proxy and skeleton class are generated from the service interface definition Service\+Interface, which is referenced by the corresponding ports.
\item Such a code fragment, which realizes a Software\+Component\+Type can obviously be re-\/used. On C++ implementation level an implementation of an Adaptive\+Application\+Sw\+Component\+Type typically boils down to one or several C++ classes. So re-\/use simply means instantiating this class/those classes in different contexts multiple times. 
\item The figure above shows an arbitrary example, where the implementations of A and B are instantiated in different contexts. On the lower left side there is an Executable 1, which directly uses two instances of As impl and one instance of Bs impl.
\item Opposed to that, the right side shows an Executable 2, which \char`\"{}directly\char`\"{} (i.\+e. on its top most level) uses one instance of Bs impl and an instance of a composite software component, which itself \char`\"{}in its body\char`\"{} again instantiates one instance of As and Bs impl.
\item This natural implementation concept of composing software components from other components to a bigger/composite artefact is fully reflected in the A\+U\+T\+O\+S\+AR meta-\/model in the form of a Composition\+Sw\+Component\+Type, which itself is a Software\+Component\+Type and allows arbitrary recursive nesting/compositing of software components.
\end{DoxyItemize}

\subsection*{4.\+3 Adaptive Application/\+Executables and Processes}


\begin{DoxyItemize}
\item Deployable software units within AP are so called Adaptive Applications (the corresponding meta-\/model element is Adaptive\+Autosar\+Application).
\item Such an Adaptive Application consists of 1..n executeables. 
\item Abstract identifiers relate in a certain way to the corresponding port in the model of the Software\+Component\+Type.
\item Instance I\+Ds obviously have to be assigned to objects, which finally have a distinct identity in an deployment. 
\end{DoxyItemize}

\subsection*{4.\+4 Usage of meta-\/model identifiers within ara\+::com based application code}


\begin{DoxyItemize}
\item The abstract identifiers relate in a certain way to the corresponding port in the model of the Software\+Component\+Type.
\item Port name of the model alone isn’t sufficient to clearly identify it in its final instantiation, where the same component implementation might be instantiated multiple times in the code and then eventually started multiple times in different processes.
\item Instance I\+Ds obviously have to be assigned to objects, which finally have a distinct identity in an deployment. 
\item The figure above shows, within Executable 2 there are three instantiations of Software\+Component\+Type B implementation in different contexts (nesting levels).All instances do provide a specific instance of SI Radar\+Service.
\item The integrator, who applies the Service Instance Manifest for Process 2 has to do the technical mapping on ara\+::com level. I.\+e. he has to decide, which technical transport binding is to be used in each of the B instantiations and subsequently also, which technical transport binding specific instance ID.
\item In our example, the integrator wants to provide the SI Radar\+Service via S\+O\+M\+E/\+IP binding and an S\+O\+M\+E/\+IP specific instance ID \char`\"{}1\char`\"{} in the context of the B instantiation, which is nested inside the composite component on the right side, while he decides to provide the SI Radar\+Service via local I\+PC (Unix domain socket) binding and a Unix domain socket specific instance ID \char`\"{}/tmp/\+Radar/3\char`\"{} and \char`\"{}/tmp/\+Radar/4\char`\"{} in the context of the B instantiations on the left side, which are not nested.
\item Within the Service Instance Manifest, which allows to specify the mapping of port instantiations within a Process to technical bindings and their concrete instance I\+Ds, the sole usage of the port name from the model isn’t sufficient to differentiate.
\item To get unique identifiers within an executable (and therefore a process), the nature of nested instantiation and re-\/use of Software\+Component\+Types has to be considered. Every time a Software\+Component\+Type gets instantiated, its instantiation gets a unique name within its instantiation context.
\item In our example this means\+:
\begin{DoxyItemize}
\item B instantiations on top level get unique names on their level\+: \char`\"{}\+B\+\_\+\+Inst\+\_\+1\char`\"{} and \char`\"{}\+B\+\_\+\+Inst\+\_\+2\char`\"{}
\item B instantiation within the Composite Component Type gets unique name on this level\+: \char`\"{}\+B\+\_\+\+Inst\+\_\+1\char`\"{}
\item Composite Component instantiation on top level gets unique name on its level\+: \char`\"{}\+Comp\+\_\+\+Inst\+\_\+1\char`\"{}
\item From the perspective of the executable/process, we therefore have unique identifiers for all instances of B\+:
\begin{DoxyItemize}
\item \char`\"{}\+B\+\_\+\+Inst\+\_\+1\char`\"{}
\item \char`\"{}\+B\+\_\+\+Inst\+\_\+2\char`\"{}
\item \char`\"{}\+Comp\+\_\+\+Inst\+\_\+1\+::\+B\+\_\+\+Inst\+\_\+1\char`\"{}
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}

\section*{5. Serialization}


\begin{DoxyItemize}
\item Serialization is the process of transforming certain data structures into a standardized format for exchange between a sender and a (possibly different) receiver.
\item When putting data on the wire and reading it back, receiver have to follow exact, agreed-\/on rules to be able to correctly interpret the data on the receiver side.
\item For Adaptive Platform, the loading of executables during runtime, which have been built independently at different times and have been uploaded to an AP E\+CU at different times, is definitely a supported use case. The chance, that compiler settings for different ara\+::com applications were different regarding alignment decisions is consequently high. Therefore an AP product (more concrete its I\+PC binding implementation) has to use/support serialization of exchanged event/field/method data.
\end{DoxyItemize}

\subsection*{5.\+1 Zero-\/\+Copy implications}


\begin{DoxyItemize}
\item One thing which typically is at the top of the list of performance optimizations in I\+P\+C/middleware implementations is the avoidance of unnecessary copies between sender and the receiver of data.
\item When we talk about AP, where we have architectural expectations like applications running in separate processes providing memory protection, the typical communication approach needs at least O\+NE copy of the data from source address space to target address space.
\item Highly optimizing middleware/\+I\+PC implementations could even get rid of this single copy step by setting up shared memory regions between communicating ara\+::com components(sender and receiver). 
\end{DoxyItemize}\hypertarget{adaptive_executionmanagement}{}\section{Execution Management}\label{adaptive_executionmanagement}

\begin{DoxyItemize}
\item \hyperlink{execution_management}{Execution Management} 
\end{DoxyItemize}\hypertarget{execution_management}{}\subsection{Execution Management}\label{execution_management}
Execution Management is the functional cluster within the Adaptive Platform Foundation that is responsible for platform initialization and the startup and shutdown of Applications. It performs these tasks using information contained within one or more Manifest files such as when and how Executables should be started. The Execution Management functional cluster is part of the Adaptive Platform.

Execution Management, in common with other Applications is assumed to be a process executed on a P\+O\+S\+IX compliant operating system. Execution Management is responsible for initiating execution of the processes in all the Functional Clusters, Adaptive A\+U\+T\+O\+S\+AR Services, and Adaptive Applications. The launching order is derived by Execution Management to ensure proper startup of the Adaptive Platform.

For an example, The Adaptive A\+U\+T\+O\+S\+AR Services are provided via mechanisms provided by the Communication Management functional cluster of the Adaptive Platform Foundation. In order to use the Adaptive A\+U\+T\+O\+S\+AR Services, the functional clusters in the Foundation must be properly initialized beforehand.

Execution Management is responsible for all aspects of process lifecycle management, including\+:


\begin{DoxyItemize}
\item {\bfseries Machine startup and shutdown} – Execution Management is the initial (“boot”) process of the operating system.
\item {\bfseries Required process hierarchy of started services, e.\+g., init and its child process.} – The boot process in this case corresponds to machine init process.
\item {\bfseries Provision of process isolation with each instance of an Executable managed as a single process.}
\item {\bfseries Startup and shutdown of Applications.} – Loading Executable based on a defined Execution Dependency. – Specific requirements until starting an Executable main function (i.\+e. entry point)
\begin{DoxyItemize}
\item Ensure that startup and shutdown dependencies between Executable instances are respected, if an execution dependency is specified in the Application Manifest of an Executable instance. If no execution dependency is specified between Executable instances, they can be started and stopped in an arbitrary order.
\end{DoxyItemize}
\item {\bfseries Privileges and use of access control} – Description and semantics of access control in manifest files
\begin{DoxyItemize}
\item Allocate OS resource budgets for Executable and/or groups of Executables
\item Authentication and authorization of Executables at startup of Executable
\end{DoxyItemize}
\item {\bfseries State management} – Conditions for the execution of Applications
\end{DoxyItemize}

\section*{2. {\bfseries Technical aspect of execution manager}}

\subsection*{2.\+1 {\bfseries Application}}


\begin{DoxyItemize}
\item Applications are developed to resolve a set of coherent functional requirements.
\item An Application consists of executable software units, additional execution related items (e.\+g. data or parameter files), and descriptive information used for integration and execution (e.\+g. a formal model description based on the A\+U\+T\+O\+S\+AR meta model, test cases).
\item Applications can be located on user level above the middleware or can be implementation of functional clusters of the Adaptive Platform.
\item Applications might use all mechanisms and A\+P\+Is provided by the operating system and other functional clusters of the Adaptive Platform, which in general restricts portability to other Adaptive Platforms.
\item All Applications, including Adaptive Applications, are treated the same by Execution Management.
\end{DoxyItemize}

\subsection*{2.\+2 {\bfseries Adaptive Application}}


\begin{DoxyItemize}
\item An Adaptive Application is a specific type of Application that fully complies with the A\+U\+T\+O\+S\+AR specification, i.\+e. it is restricted to use A\+P\+Is standardized by A\+U\+T\+O\+S\+AR and needs to follow specific coding guidelines to allow reallocation between different Adaptive Platforms.
\item Adaptive Applications are always located above the middleware. To allow portability and reuse, user level Applications should be Adaptive Applications whenever technically possible.
\item An Adaptive Application is the result of functional development and is the unit of delivery for Machine specific configuration and integration.
\item Some contracts and Service Interfaces to interact with other Adaptive Applications need to be agreed on beforehand.
\end{DoxyItemize}

\subsection*{2.\+3 {\bfseries Executable}}


\begin{DoxyItemize}
\item An Executable is a software unit which is part of an Application. It has exactly one entry point (main function). An Application can be implemented in one or more Executables.
\item Executables which belong to the same Adaptive Application might need to be deployed to different Machines, e.\+g. to one high performance Machine and one high safety Machine.
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Process Step }&\textbf{ Software }&\textbf{ Meta Information  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Process Step }&\textbf{ Software }&\textbf{ Meta Information  }\\\cline{1-3}
\endhead
Development and Integration &Linked, configured and calibrated binary for deployment onto the target Machine. The binary might contain code which was generated at integration time. &Application Manifest and Service Instance Manifest (not used by Execution Management) \\\cline{1-3}
Deployment and Removal &Binary installed on the target Machine. &Processed Manifests, stored in a platform-\/specific format which is efficiently readable at Machine startup. \\\cline{1-3}
Execution &Process started as instance of the binary. &The Execution Management uses contents of the Processed Manifests to start up and configure each process individually. \\\cline{1-3}
\end{longtabu}




\subsection*{2.\+4 {\bfseries Process}}


\begin{DoxyItemize}
\item A Process is a forked instance of an Executable. \begin{quote}
{\bfseries Note\+: In the initial release it is assumed, that processes are self contained, i.\+e. that they take care of controlling thread creation and scheduling by calling A\+P\+Is from within the code.} \end{quote}

\item Execution Management only starts and terminates the processes and while the processes are running, Execution Management only interacts with the processes by using State Management mechanisms.
\end{DoxyItemize}

\subsection*{2.\+5 {\bfseries Application Manifest}}


\begin{DoxyItemize}
\item The Application Manifest consists of parts of the Application design information which is provided by the application developer in an application description, and additional machine-\/specific information which is added at integration time.
\item An Application Manifest is created together with a Service Instance Manifest (not used by Execution Management) at integration time and deployed onto a Machine together with the Executable it is attached to.
\item It describes in a standardized way the machine-\/specific configuration of Process properties (startup parameters, resource group assignment, priorities etc.).
\item Each instance of an Executable binary, i.\+e. each started process, is individually configurable, with the option to use a different configuration set per Machine state or per Function Group State.
\end{DoxyItemize}

\subsection*{2.\+6 {\bfseries Machine Manifest}}


\begin{DoxyItemize}
\item The Machine Manifest holds all configuration information which cannot be assigned to a specific Executable, i.\+e. which is not already covered by an Application Manifest or a Service Instance Manifest.
\item The Machine Manifest is also created at integration time for a specific Machine and is deployed like Application Manifests whenever its contents change.
\item The contents of a Machine Manifest includes the configuration of Machine properties and features (resources, safety, security, etc.), e.\+g. configured Machine States and Function Group States, resource groups, access right groups, scheduler configuration, S\+O\+M\+E/\+IP configuration, memory segmentation.
\end{DoxyItemize}

\subsection*{2.\+7 {\bfseries Manifest format}}


\begin{DoxyItemize}
\item The Application Manifests and the Machine Manifest can be transformed into a platform-\/specific format (called Processed Manifest), which is efficiently readable at Machine startup.
\item The format transformation can be done either off board at integration time or at deployment time, or on the Machine (by Update and Configuration management) at installation time.
\end{DoxyItemize}

\subsection*{2.\+8 {\bfseries Execution Management Responsibilities}}


\begin{DoxyItemize}
\item Execution Management is responsible for all aspects of Process execution management. A Process is a loaded instance of an Executable, which is part of an Application.
\item Execution Management is started as part of the Adaptive Platform startup phase and is responsible for starting and terminating Processes.
\item Execution Management determines when, and possibly in which order, to start or stop Processes, i.\+e. instances of the deployed Executables, based on information in the Machine Manifest and Application Manifests.
\item Execution Management will be solely responsible for initiating execution of Processes.
\item Depending on the Machine State or on a Function Group State, deployed Executables are started during Adaptive Platform startup or later.
\item Execution Management is not responsible for run-\/time scheduling of Processes since this is the responsibility of the Operating System.
\item {\bfseries Application Lifecycle Management\+:}
\begin{DoxyItemize}
\item The Execution Management is responsible for the ordered startup and shutdown of the deployed Applications.
\item The Execution Management determines when, and possibly in which order, to start or stop the deployed Applications, based on information in the Machine Manifest and Application Manifests.
\item Depending on the Machine State or on a Function Group State, deployed Applications are started during Adaptive Platform startup or later, however, it is not expected that all will begin active work immediately since many Applications will provide services to other Applications and therefore wait and “listen” for incoming service requests.
\item The Execution Management derives an ordering for startup/shutdown within the State Management framework, based on declared Application dependencies. The dependencies are described in the Application Manifests.
\end{DoxyItemize}
\item The Execution Management is not responsible for run-\/time scheduling of Applications since this is the responsibility of the Operating System. However the Execution Management is responsible for initialization configuration of the OS to enable it to perform the necessary run-\/time scheduling based on information extracted by the Execution Management from the Machine Manifest and Application Manifests.
\end{DoxyItemize}

\subsubsection*{2.\+8.\+1 {\bfseries Process Lifecycle Management}}


\begin{DoxyItemize}
\item {\bfseries Process States\+:} From the execution stand point, Process States characterize the lifecycle of any Process. \begin{quote}
{\bfseries Note that each process is independent and therefore has its own Process State.} \end{quote}

\begin{DoxyItemize}
\item {\bfseries Idle Process State\+:} The Idle Process State will be the Process state prior to creation of the process and resource allocation.
\item {\bfseries Starting Process State\+:} The Starting Process State will apply when the process has been created and resources have been allocated.
\item {\bfseries Running Process State\+:} The Running Process State will apply to a process after it has been scheduled and it has reported Running State to the Execution Manager.
\item {\bfseries Terminating Process State\+:}
\begin{DoxyItemize}
\item The Terminating Process State will apply either after an process has received the termination indication from the Execution Manager or after it has decided to self-\/terminate and informed the Execution Manager.
\item The Terminating and Running Process State indications from Application to Execution Management use the Report\+Application\+State A\+PI. On entering the k\+Terminating\+Process State, the Process is expected to save persistent data, free all used Process internal resources and exit.
\end{DoxyItemize}
\item {\bfseries Terminated Process State\+:}
\begin{DoxyItemize}
\item The Terminated Process State will apply after the process has been terminated and the process resources have been freed. For that, Execution Manager will observe the exit status of all processes, with the P\+O\+S\+IX waitpid() command.
\item From the resource allocation stand point, Terminated state is similar to the Idle state as there is no process running and no resources are allocated anymore.
\item From the execution stand point, Terminated state is different from the Idle state since it tells that the process has already been executed and terminated.
\item This is relevant for one shot Processes which are supposed to run and terminate on their own as once they have reached their Terminated Process State they are to return to the Idle Process State without any external trigger.
\end{DoxyItemize}
\item {\bfseries One-\/shot Process State\+:}
\begin{DoxyItemize}
\item After a one-\/shot Process has terminated, Execution Management shall immediately set its Process State to Idle. 
\end{DoxyItemize}
\end{DoxyItemize}
\item {\bfseries Startup and Shutdown\+:}
\begin{DoxyItemize}
\item {\itshape Ordering\+:}
\begin{DoxyItemize}
\item The Execution Manager can derive an ordering for the startup and shutdown of Processes within the State Management framework based on the declared Execution Dependencies.
\item An Execution Dependency defines the provider of service(s) required by a Process before that Process can provide its own services. Hence Execution Management ensures the dependent Processes are in the state defined by the Execution Dependency before the Process with the dependency is started.
\item Execution Dependencies are described in the Application Manifest.
\item During startup, Execution Management shall respect Execution Dependencies by ensuring that any Processes upon which the Process to be started depends have reached the requested state before starting the Process.
\item The same Execution Dependencies used to define the startup order are also used to define the shutdown order. However the situation is reversed as Execution Management must ensure that dependent processes are shutdown after the process to ensure that the services required remain available until no longer required.
\item During shutdown, Execution Management will respect Execution Dependencies by ensuring that any Processes upon which the Process to be shutdown depends are not terminated before shutting down the Process.
\end{DoxyItemize}
\item {\itshape Arguments \+:}
\begin{DoxyItemize}
\item Execution Manager provides argument passing for a Process contain is gone or more Mode\+Dependent\+Startup\+Config in the role Process.\+mode\+Depen-\/dent\+Startup\+Config. This permits different Processes to be started with different arguments.
\item At the initiation of startup of a Process, the aggregated Startup\+Options of the Startup\+Config referenced by the Mode\+Dependent\+Startup\+Config will be passed to the call of the exec-\/family based P\+O\+S\+IX interface to start the Process by the Operating System.
\item The first argument on the command-\/line passed by Execution Management is the name of the Executable.
\end{DoxyItemize}
\end{DoxyItemize}
\item {\bfseries Startup Sequence\+:}
\begin{DoxyItemize}
\item When the Machine is started, the OS will be initialized first and then Execution Manager is launched as one of the O\+S’s initial Processes. Other functional clusters and platform-\/level Applications of the Adaptive Platform Foundation are then launched by Execution Management. After the Adaptive Platform Foundation is up and running, Execution Management continues to launch userlevel Applications.
\item The startup order of the platform-\/level Processes is determined by the Execution Management, based on Machine Manifest and Application Manifest information. 
\end{DoxyItemize}
\item {\bfseries Execution Dependency\+:}
\begin{DoxyItemize}
\item The Execution Management provides support to the Adaptive Platform for ordered startup and shutdown of Applications.
\item This ensures that Applications are started before dependent Applications use the services that they provide and, likewise, that Process are shutdown only when their provided services are no longer required.
\item The Execution dependencies, are configured in the Application Manifests, which is created at integration time based on information provided by the Application developer.
\item User-\/level applications use service discovery mechanisms of the Communication Management and should not depend on startup dependencies. Which Executable instances are running depends on the current Machine State and on the current Function Group States. The integrator must ensure that all service dependencies are mapped to State Management configuration, i.\+e. that all dependent Executable instances are running when needed.
\item In real life, specifying a simple dependency to an Process might not be sufficient to ensure that the depending service is actually provided. Since some Process will reach a certain Application State to be able to offer their services to other Process, the dependency information will also refer to Process State of the Process specified as dependency. With that in mind, the dependency information may be represented as a pair like\+: \char`\"{}$<$\+Process$>$.$<$\+Application\+State$>$\char`\"{}.
\item The following dependency use-\/cases have been identified\+:
\begin{DoxyItemize}
\item In case Process B has a simple dependency on Process A, the Running Application State of Process A is specified in the dependency section of Process B’s Application Manifest.
\item In case Process B depends on One-\/\+Shot Process A, the Terminated Application State of Process A is specified in the dependency section of Process B’s Application Manifest.
\end{DoxyItemize}
\item Processes are only started by the Execution Manager if they reference a requested Machine State or Function Group State, but not because of configured Execution Dependencies.
\item Execution Dependencies are only used to control a startup or terminate sequence at state transitions or at machine startup/shutdown.
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{2.\+9 {\bfseries State Management}}


\begin{DoxyItemize}
\item State Management provides a mechanism to define the state of the operation for an Adaptive Platform. The Application Manifest allows definition in which states the Process instances have to run . State Management grants full control over the set of Applications to be executed and ensures that Process are only executed (and hence resources allocated) when actually needed.
\item Four different states are relevant for Execution Management\+:
\begin{DoxyItemize}
\item Application State
\item Process State
\begin{DoxyItemize}
\item Process States are managed by an Execution Management internal state machine.
\end{DoxyItemize}
\item Machine State
\item Functional group state.
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+9.\+1 {\bfseries Application State\+:}}


\begin{DoxyItemize}
\item The Application State characterizes the internal lifecycle of any instance of an Process. The states are defined by the Application\+State enumeration.
\item {\bfseries Application State Running\+:}
\begin{DoxyItemize}
\item Execution Management shall consider Process initialization complete when the state k\+Running is reported. \begin{quote}
{\bfseries Please note that Service Discovery can introduce non-\/deterministic delays and thus is advised to be done after reporting k\+Running state thus the Process may not have completed all its initialization when the k\+Runningstate is reported.} \end{quote}

\end{DoxyItemize}
\item {\bfseries Initiation of Process termination\+:}
\begin{DoxyItemize}
\item Execution Management shall initiate termination by sending the S\+I\+G\+T\+E\+RM signal to a Process.
\item Note that from the perspective of Execution Management, requirement only requests the initiation of the steps necessary for termination.
\item On receipt of S\+I\+G\+T\+E\+RM, a Process acknowledges the request (by reporting the new state to Execution Management using the Application-\/\+Client\+:Report\+Application\+Stateinterface) and then commences the actual termination.
\end{DoxyItemize}
\item {\bfseries Acknowledgement of termination request\+:}
\begin{DoxyItemize}
\item On reception of S\+I\+G\+T\+E\+RM, the Process will acknowledge the state change request by reporting k\+Terminating to Execution Management.
\end{DoxyItemize}
\item {\bfseries Initiation of Process self-\/termination\+:}
\begin{DoxyItemize}
\item A Process will initiate self-\/termination by reporting the k\+Terminating state to Execution Management.
\item During the Terminating state, the Process is expected to free internally used resources. The Process indicates completion of the Terminating state by simply exiting (with an appropriate exit code). Execution Management as the parent process can detect termination of the child process and take the appropriate platform-\/specific actions.
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+9.\+2 {\bfseries Machine State}}


\begin{DoxyItemize}
\item Requesting and reaching a Machine State is, besides using Function Group States, one way to define the current set of running Process. It is significantly influenced by vehicle-\/wide events and modes.
\item Each Application can declare in its Application Manifest in which Machine States it has to be running.
\item There are several mandatory machine states specified in this document that have to be present on each machine.
\item Additional Machine States can be defined on a machine specific basis and are therefore not standardized.
\item Machine States\+:
\begin{DoxyItemize}
\item A Mode\+Declaration for each required Machine State has to be defined in the Machine Manifest.
\item The Execution Manager will obtain the Machine States from the Machine Manifest.
\item The A\+PI specification will use the short\+Name for identification of the Machine State.
\item The Machine States are determined and requested by the State Manager.
\end{DoxyItemize}
\item Following are the default Machine state\+:
\item {\bfseries Startup} 
\begin{DoxyItemize}
\item The Startup Machine State will be the first state to be active after the startup of Execution Manager. Therefore, a Mode\+Declaration for the Startup has to be defined in the Machine Manifest.
\item The following behavior apply for the Startup Machine State\+:
\begin{DoxyItemize}
\item All Processes of platform-\/level Applications configured for Startup will be started.
\item Process configured for Startup are based on the reference from the Process to the Mode\+Dependent\+Startup\+Config in the role Process.\+mode\+Dependent\+Startup\+Config with the instance\+Ref to the Mode\+Declaration in the role Mode\+Dependent\+Startup\+Config.\+machine\+Mode that belongs to the Startup Machine State.
\item The Execution Manager will wait for all started Process until their Application State Running is reported.
\item If that is the case, the Execution Manager will notify the State Manager that the Startup Machine State is ready to be changed.
\item The Execution Manager will not change the Machine State by itself until a new state is requested by the State Manager.
\end{DoxyItemize}
\end{DoxyItemize}
\item {\bfseries Shutdown}
\begin{DoxyItemize}
\item The Shutdown Machine State will be active after the Shutdown Machine State is requested by the State Manager. Therefore, a Mode\+Declaration for the Shutdown has to be defined in the Machine Manifest.
\item The following behavior apply for the Shutdown Machine State\+:
\begin{DoxyItemize}
\item All Processes, including the platform-\/level Applications, that have a Process State different than Idle or Terminated will be shutdown.
\item When Process State of all Process is Idle or Terminated, all Process configured for Shutdown will be started.
\item Process configured for Shutdown are based on the reference from the Processes to the Mode\+Dependent\+Startup\+Config in the role Process.\+mode\+De-\/pendent\+Startup\+Config with the instance\+Ref to the Mode\+Declaration in the role Mode\+Dependent\+Startup\+Config.\+machine\+Mode that belongs to the Shutdown Machine State.
\end{DoxyItemize}
\item Shutdown of the Operating System\+:
\begin{DoxyItemize}
\item There will be at least one Process consisting of at least one Process that has a Mode\+Dependent\+Startup\+Config in the role Process.\+mode\+Dependent\+Startup\+Config with the instance\+Ref to the Mode\+Declaration in the role Mode\+Dependent\+Startup\+Config.\+machine\+Mode that belongs to the Shutdown Machine State.
\item This Application will contain the actual mechanism(s) to initiate shutdown of the Operating System.
\end{DoxyItemize}
\end{DoxyItemize}
\item {\bfseries Restart}
\begin{DoxyItemize}
\item The Restart Machine State will be active after the Restart Machine State is requested by the State Manager. Therefore, a Mode\+Declaration for the Restart has to be defined in the Machine Manifest.
\item The following behavior applies for the Restart Machine State\+:
\begin{DoxyItemize}
\item All Process, including the platform-\/level Applications, that have a Process State different than Idle or Terminated will be shutdown.
\item When Process State of all Process is Idle or Terminated, all Process configured for Restart will be started.
\item Process configured for Restart are based on the reference from the Process to the Mode\+Dependent\+Startup\+Config in the role Process.\+mode\+Dependent\+Startup\+Config with the instance\+Ref to the Mode\+Declaration in the role Mode\+Dependent\+Startup\+Config.\+machine\+Mode that belongs to the Restart Machine State.
\end{DoxyItemize}
\item Restart of the Operating System\+:
\begin{DoxyItemize}
\item There will be at least one Application consisting of at least one Process that has a Mode\+Dependent\+Startup\+Config in the role Process.\+mode\+Dependent\+Startup\+Config with the instance\+Ref to the Mode\+Declaration in the role Mode\+Dependent\+Startup\+Config.\+machine\+Mode that belongs to the Restart Machine State.
\item This Application will contain the actual mechanism(s) to initiate restart of the Operating System.
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{2.\+10 {\bfseries State Management Architecture}}


\begin{DoxyItemize}
\item State Management is the functional cluster which is responsible for determining the current set of active Machine State and Function Group States, and for initiating State transitions by requesting them from Execution Management.
\item Execution Management performs the State transitions and controls the actual set of running Processes, depending on the current States.
\item State Management is the central point where new Machine States and Function Group States can be requested and where the requests are arbitrated, including coordination of contradicting requests from different sources. Additional data and events might need to be considered for arbitration.
\item The State change requests can be issued by\+:
\begin{DoxyItemize}
\item Platform Health Management to trigger error recovery, e.\+g. to activate fallback functionality
\item Diagnostics, to switch the system into diagnostic states.
\item Update and Configuration Management to switch the system into states where software or configuration can be updated.
\item Network Management to coordinate required functionality and network state.
\item authorized applications, e.\+g. a vehicle state manager which might be located in a different machine or on a different E\+CU State Change requests can be issued by other.
\end{DoxyItemize}
\item Since State Management functionality is critical, access from other Functional Clusters or Process must be secured, e.\+g. by I\+AM (Identity and Access Management).
\item State Management is monitored and supervised by Platform Health Management.
\item State Management provides interfaces to request information about current states.
\end{DoxyItemize}

\subsubsection*{2.\+10.\+1 {\bfseries State Interaction}}


\begin{DoxyItemize}
\item One can see the state transitions of a Function Group and the Process and Application States of one Process which references one state of this Function Group, ignoring possible delays and dependencies if several Processes were involved.
\item The interaction is identical if the Process references a Machine State instead of a Function Group State.
\end{DoxyItemize}

\subsubsection*{2.\+10.\+2 {\bfseries State Change}}


\begin{DoxyItemize}
\item State Management can request to change one or several Function Group States and/or the Machine State from Execution Management by passing pairs of \char`\"{}\+Function Group\char`\"{} \char`\"{}requested State\char`\"{} as parameters, with Machine State being treated like any Function Group State.
\item A state change request by State Management will lead to immediate state transitions and hereof a state change to the requested Machine State and/or Function Group States.
\item State Management can request multiple Machine State and Function Group State changes sequentially by issuing several individual state change requests, or atomically within the same state change request, which leads to multiple coherent state changes.
\item However, the following restriction applies to avoid undefined behaviour while the state transitions are performed by Execution Management\+:
\item {\bfseries Deny State Change Request\+:}
\begin{DoxyItemize}
\item Execution Management will deny state change requests, that are received before all previously requested Machine State and/or Function Group State transitions are completed. If a request is denied, Execution Management will return an error code to the requester of the state transition.
\end{DoxyItemize}
\item {\bfseries State Transition Timeout\+:}
\begin{DoxyItemize}
\item If a timeout is detected when stopping or starting Processes at a state transition, Execution Management will return an error code to the requester of the state changes.
\item This implies that the state change request blocks until the state transitions are completed or until an error is detected.
\end{DoxyItemize}
\item {\bfseries State Change Failed\+:}
\begin{DoxyItemize}
\item Execution Management will return an error code to the requester of the state changes when other or unspecified errors occur at a state transition.
\end{DoxyItemize}
\item {\bfseries State Change Successful\+:}
\begin{DoxyItemize}
\item When Execution Management succeeds with the requested state transitions, a success code will be returned to the requester of the state changes.
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{2.\+11 {\bfseries Deterministic Execution}}

\subsubsection*{2.\+11.\+1 {\bfseries Determinism}}


\begin{DoxyItemize}
\item In real-\/time systems, deterministic execution often means, that a calculation of a given set of input data always produces a consistent output within a bounded time, i.\+e. the behavior is reproducible.
\item In the context of Execution Management, the term “calculation” can apply to execution of a thread, a Process, or a group of Processes. The calculation can be event-\/driven or cyclic; i.\+e. time-\/driven.
\item There are multiple elements in determinism and here we distinguish them as follows\+:
\begin{DoxyItemize}
\item {\bfseries Time Determinism\+:} The output of the calculation is always produced before a given deadline (a point in time).
\item {\bfseries Data Determinism\+:} Given the same input and internal state, the calculation always produces the same output.
\item {\bfseries Full Determinism\+:} Combination of Time and Data Determinism as defined above.
\end{DoxyItemize}
\item Deterministic behavior is important for safety-\/critical systems, which may not be allowed to deviate from the specified behavior at all.
\item Whether Time Determinism, or in addition Data Determinism is necessary to provide the required functionality depends on the system and on the safety goals.
\item Expected use cases of the Adaptive Platform where such determinism is required include\+:
\begin{DoxyItemize}
\item Software Lockstep\+: To execute A\+S\+IL C/D with high computing performance demands, specific measures, such as software lockstep are required, due to high transient hardware error rates of high performance microprocessors. Software lockstep is a technique where the calculation is done redundantly through two different execution paths and the results are compared. To make the redundant calculations comparable, software lockstep requires a fully deterministic calculation.
\item Reuse of verified software\+: The deterministic subsystem shows the same behavior on different platforms which satisfy the performance and resource needs of the subsystem, regardless of other differences in each environment, such as existence of unrelated applications. Examples include the different development and simulation platforms. Due to reproducible functional behavior, many results of testing, configuration and calibration of the subsystem are valid in each environment where the subsystem is deployed on and don’t need to be repeated.
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+11.\+1.\+1 {\bfseries Time Determinism}}


\begin{DoxyItemize}
\item Each time a calculation is started, its results are guaranteed to be available before a specified deadline. To achieve this, sufficient and guaranteed computing resources (processor time, memory, service response times etc.) must be assigned to the software entities that perform the calculation.
\item Non-\/deterministic “best-\/effort” Processes can request guaranteed minimum resources for basic functionality, and additionally can have maximum resources specified for monitoring. However, if Time Determinism is requested, the resources must be guaranteed at any time, i.\+e. minimum and maximum resources are identical.
\item If the assumptions for deterministic execution are violated, e.\+g. due to a deadline miss, this must be treated as an error and recovery actions must be initiated. In nondeterministic “best-\/effort” subsystems such deadline violations or other deviations from normal behavior sometimes can be tolerated and mitigated without dedicated error management.
\item Fully-\/\+Deterministic behavior additionally requires Data Determinism, however in many cases Time Determinism is sufficient.
\end{DoxyItemize}

\subsubsection*{2.\+11.\+1.\+2 {\bfseries Data Determinism}}


\begin{DoxyItemize}
\item For Data Determinism, each time a calculation is started, its results only depend on the input data. For a specific sequence of input data, the results always need to be exactly the same, assuming the same initial internal state.
\item A common approach to verify Data Determinism in a safety context is the use of lockstep mechanisms, where execution is done simultaneously through two different paths and the result is compared to verify consistency. Hardware lockstep means that the hardware has specific equipment to make this double-\//multi-\/execution transparent. Software lockstep is another technique that allows providing a similar property without requiring the use of dedicated hardware.
\item Depending on the Safety Level, as well as the Safety Concept employed, software lockstep may involve executing multiple times the same software, in parallel or sequentially, but may also involve running multiple separate implementations of the same algorithm.
\end{DoxyItemize}

\subsubsection*{2.\+11.\+1.\+3 {\bfseries Full Determinism}}


\begin{DoxyItemize}
\item For Full Determinism, each time a calculation is started, its results are available before a specified deadline and only depend on the input data, i.\+e. both Time and Data Determinism must be guaranteed.
\item Currently, only Full Deterministic behavior of one Process is specified. Determinism of a cluster of Processes on one or even several machines needs extensions of the Communication Management, which have not been specified yet.
\item Non-\/deterministic behavior may arise from different reasons; for example insufficient computing resources, uncoordinated access of data, potentially by multiple threads running on multiple processor cores. The order in which the threads access such data will affect the result, which makes it non-\/deterministic (“race condition”).
\item A fully deterministic calculation must be designed, implemented and integrated in a way such that it is independent of processor load, sporadic unrelated events, race conditions, etc.
\end{DoxyItemize}

\subsection*{2.\+11.\+2 {\bfseries Redundant Deterministic Execution}}


\begin{DoxyItemize}
\item Future systems need high computing performance in combination with high A\+S\+IL safety goals.
\item Here are some additional rationales behind it\+:
\begin{DoxyItemize}
\item Safety goals for Highly Automated Driving (H\+AD) systems can be up to A\+S\+IL D.
\item High Performance Computing (H\+PC) demands can only be met by non automotive-\/grade, e.\+g. consumer electronics (CE), microprocessors, which have high transient hardware error rates compared to automotive-\/grade microcontrollers. Most likely no such microprocessor is available for A\+S\+IL above B, at least for the parts relevant to the design.
\item To deal with high error rates, A\+S\+IL C/D H\+AD applications require specific measures, in particular software lockstep, where execution is done redundantly through two different paths and the result is compared to detect errors.
\item To make these redundant calculations comparable, software lockstep requires a fully deterministic calculation which must be designed, implemented and integrated in a way such that it is independent of processor load caused by other functions and calculations, sporadic unrelated events, race conditions, deviating random numbers etc, i.\+e. for the same input and initial conditions it always produces the same result within a given time.
\item To meet H\+PC demands, highly predictable and reliable multi-\/threading must be supported.
\end{DoxyItemize}
\item Two redundant Processes, which run in an internal cycle, get in each cycle the same input data via regular interfaces of the Communication Management and produce (in the absence of errors) the same results, due to full deterministic execution.
\end{DoxyItemize}

\subsection*{2.\+12 {\bfseries Resource limitation}}


\begin{DoxyItemize}
\item Despite the correct behavior of a particular Adaptive Application in the system, it is important to ensure any potentially incorrect behavior, as well as any unforeseen interactions cannot cause interference in unrelated parts of the system.
\item it is important to consider that Execution Management is only responsible for the correct configuration of the Machine. However, enforcing the associated restrictions is usually done by either the Operating System or another Application like the Persistency service.
\end{DoxyItemize}

\subsubsection*{2.\+12.\+1 {\bfseries Resource configuration}}


\begin{DoxyItemize}
\item This section provides an overview on resource assignment to Processes, resources like\+:
\begin{DoxyItemize}
\item R\+AM (e.\+g. for code, data, thread stacks, heap)
\item C\+PU time
\end{DoxyItemize}
\item In general, we need to distinguish between two resource demand values\+:
\begin{DoxyItemize}
\item Minimum resources, which need to be guaranteed so the process can reach its Running state and perform its basic functionality.
\item Maximum resources, which might be temporarily needed and will not be exceeded at any time, otherwise it will throw an error.
\end{DoxyItemize}
\item Execution Management will configure the maximum amount of R\+AM available globally for all Processes belonging to each Resource\+Group when defined in the configuration, before loading a Process from this Resource\+Group. If a Resource\+Group does not have a configured R\+AM limit, then the Processes are only bound by their implicit memory limit.
\item Execution Management will configure the maximum amount of C\+PU time available globally for all Processes belonging to each Resource\+Group when defined in the configuration, before loading a Process from this Resource\+Group. If Resource\+Group does not have a configured C\+PU usage limit, then the Processes are only bound by their implicit C\+PU usage limit (priority, scheduling scheme...).
\end{DoxyItemize}

\subsubsection*{2.\+12.\+2 {\bfseries Resource Monitoring}}


\begin{DoxyItemize}
\item The resources which are actually used by a Process should be controlled at any given time.
\item For the entire system, the monitoring part of this activity is fulfilled by the Operating System.
\item Depending on system requirements and safety goals, an appropriate Operating System has to be chosen and configured accordingly, in combination with other monitoring mechanisms (e.\+g. for execution deadlines) which are provided by Platform Health Management.
\item Resource monitoring can serve several purposes, e.\+g.
\begin{DoxyItemize}
\item Detection of misbehavior of the monitored Process to initiate appropriate recovery actions, like Process restart or state change, to maintain the provided functionality and guarantee functional safety.
\item Protection of other parts of the system by isolating the erroneous Processes from unaffected ones to avoid resource shortage.
\end{DoxyItemize}
\item For Processes which are attempting to exceed their configured maximum resource needs, one of the following alternatives\+:
\begin{DoxyItemize}
\item The resource limit violation or deadline miss is considered a failure and recovery actions may need to be initiated. Therefore the specific violation gets reported to the Platform Health Management, which then starts recovery actions which have been configured beforehand. This will be the standard option for deterministic subsystems.
\item For Processes without hard deadlines, resource violations sometimes can be mitigated without dedicated error recovery actions, e.\+g. by interrupting execution and continue at a later point in time.
\item If the OS provides a way to limit resource consumption of a Process or a group of Processes by design, explicit external monitoring is usually not necessary and often not even possible. Instead, the limitation mechanisms make sure that resource availability for other parts of the system is not affected by failures within the enclosed Processes. When such by-\/design limitation is used, monitoring mechanisms may still be used for the benefit of the platform, but are not required. Self-\/monitoring and out-\/of-\/process monitoring is currently out-\/of-\/scope in Adaptive Platform.
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+12.\+3 {\bfseries Application-\/level Resource configuration}}

\subsubsection*{2.\+12.\+3.\+1 {\bfseries C\+PU Usage}}


\begin{DoxyItemize}
\item C\+PU usage is represented in a Process by its threads. Generally speaking, Operating Systems use some properties of each thread’s configuration to determine when to run it, and additionally constrain a group of threads to not use more than a defined amount of C\+PU time. Because threads may be created at runtime, only the first thread can be configured by Execution Management.
\end{DoxyItemize}

\subsubsection*{2.\+12.\+3.\+2 {\bfseries Core Affinity}}


\begin{DoxyItemize}
\item Execution Management will configure the Core affinity of the Process initial thread restricting it to a sub-\/set of cores in the system.
\item Depending on the capabilities of the Operating System the sub-\/set could be a single core.
\item If the Operating System does not support binding to specific cores then the only supported sub-\/set is the entire set of cores.
\end{DoxyItemize}

\subsubsection*{2.\+12.\+3.\+3 {\bfseries Scheduling Policy}}


\begin{DoxyItemize}
\item Currently available P\+O\+S\+I\+X-\/compliant Operating Systems offer the scheduling policies required by P\+O\+S\+IX, and in most cases additional, but different and incompatible scheduling strategies. This means for now, the required scheduling properties need to be configured individually, depending on the chosen OS.
\item Moreover, scheduling strategy is defined per thread and the P\+O\+S\+IX standard allows for modifying the scheduling policy at runtime for a given thread, using pthread\+\_\+setschedparam(). It is therefore not currently possible for the Adaptive Platform to enforce a particular scheduling strategy for an entire Process, but only for its first thread.
\item While scheduling policies are not a sufficient method to guarantee Full Determinism, they contribute to improve it. While the aim is to limit C\+PU time for a Process, scheduling policies apply to threads. \begin{quote}
{\bfseries Note that while Execution Management will ensure the proper configuration for the first thread (that calls the main() function), it is the responsibility of the Process itself to properly configure secondary threads.} \end{quote}

\end{DoxyItemize}

\subsubsection*{2.\+12.\+3.\+4 {\bfseries Resource Management}}


\begin{DoxyItemize}
\item In general, for deterministic behavior the required computing time is guaranteed and violations are treated as error, while best-\/effort subsystems are more robust and might be able to mitigate sporadic violations, e.\+g. by continuing the calculation at the next activation, or by providing a result of lesser quality. This means, if time (e.\+g. deadline or runtime budget) monitoring is in place, the reaction on deviations is different for deterministic and best-\/effort subsystems.
\item In fact, it may not even be necessary to monitor best-\/effort subsystems, since they by definition are doing only a function that may not succeed. This leads to an architecture where monitoring is a voluntary, configured property.
\item The remaining critical property however is to guarantee that a particular process or set of Processes cannot adversely affect the behavior of other Processes.
\item To guarantee Full Determinism for the entire system, it is important to ensure Freedom from Interference, which the Resource\+Group contribute to ensure.
\item Execution Management will configure the Process according to its Resource\+Group membership.
\end{DoxyItemize}

\subsubsection*{2.\+12.\+3.\+5 {\bfseries Memory Budget and Monitoring}}


\begin{DoxyItemize}
\item To render a function, a Process requires the availability of some amount of memory for its usage (mainly code, data, heap, thread stacks). Over the course of its execution however, not all of this memory is required at all times, such that an OS can take advantage of this property to make these ranges of memory available on-\/demand, and provide them to other Processes when the memory is no longer used.
\item While this has clear advantages in terms of system flexibility as well as memory efficiency, it is also in the way of both Time Determinism and Full Determinism\+: when a range of memory that was previously unused must now be made available, the OS may have to execute some amounts of potentially-\/unbounded activities to make this memory available. Often, the reverse may also be happening, removing previously available (but unused) memory from the Process under scope, to make it available to other Processes. This is detrimental to an overall system determinism.
\item Execution Management will ensure that the entire memory range that deterministic Processes may be using is available at the start and for the whole duration of the respective Process execution.
\item In order to provide sufficient memory at the beginning of the execution of a Process, some properties may need to be defined for each Process.
\item {\bfseries Maximum heap\+:}
\begin{DoxyItemize}
\item Execution Management will configure the Maximum heap usage for the Process.
\item Heap memory is used for dynamic memory allocation inside a Process e.\+g. through malloc()/free() and new/delete.
\end{DoxyItemize}
\item {\bfseries Maximum system memory usage\+:}
\begin{DoxyItemize}
\item Execution Management will configure the Maximum system memory usage of the Process.
\item System memory can be used to create extra resources like file handles or semaphores, as well as creating new threads.
\end{DoxyItemize}
\item {\bfseries Process pre-\/mapping\+:}
\begin{DoxyItemize}
\item Execution Management will premap a Process if required by the corresponding Application Manifest.
\item Fully pre-\/mapping a Process ensures that code and data execution is not going to be delayed at its first execution by demand-\/loading. This helps providing Time Determinism during system startup and first execution phases, but also helps with safety where code handling error cases can be preloaded and made guaranteed to be available. In addition, pre-\/mapping avoids late issues where filesystem may be corrupted and part of the Process may not be loadable anymore. 
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{adaptive_configurationmethodology}{}\section{Configuration Methodology}\label{adaptive_configurationmethodology}
The Adaptive Platform is usually not exclusively used within a single A\+U\+T\+O\+S\+AR System as the vehicle is also equipped with a number of E\+C\+Us developed on the A\+U\+T\+O\+S\+AR Classic Platform. The System design for the entire vehicle will therefore cover both E\+C\+Us built using Classic Platform(\+C\+P) as well as Machines using the Adaptive Platform(\+A\+P).


\begin{DoxyItemize}
\item The Function Architecture is composed of a number of function networks. A function network consists of a set of function blocks with their interfaces and corresponding interconnections.
\item Function Architecture is one of the input to deduce Common Software Architecture. The Common Software Architecture provides a dedicated view of all software entities and their communication relation within the E/E vehicle system. In this light, the Common Software Architecture comprises both types, A\+U\+T\+O\+S\+AR software components of the Classic Platform as well as those entities that form later an Adaptive Application Software deployed to an Adaptive Platform-\/based machine.
\item The communication entry and exit points of components are ports typed by a particular interface definition. In case of the Adaptive Platform, interfaces are expressed as Service Interfaces. The Common Software Architecture can be specified by means of the System Description.
\end{DoxyItemize}

 {\bfseries System\+:} Like for the CP methodology, this development domain will cover activities which refine the Common Software Architecture into a system defined by specific E\+C\+Us or machines. The overall system which talk about the refinement of the V\+FB by the definition of a topology of E\+C\+Us and networks and the deployment of software components onto E\+C\+Us, with the extensions necessary for the Common Software Architecture and the additions to specify machines and the corresponding mapping of machines to E\+C\+Us.

\section*{1. Development Workflow}



\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Task Definition }&\textbf{ Responsibility }&\textbf{ Task Description  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Task Definition }&\textbf{ Responsibility }&\textbf{ Task Description  }\\\cline{1-3}
\endhead
Develop a Service Interface Description &O\+EM &This activity describes the definition of the service interfaces, aggregating events, methods and fields, including the definition of data types \\\cline{1-3}
Develop Adaptive Software (Application/\+Platform) &Tier1/\+Tier2 &Develop an Adaptive Application with category application-\/level or platform level. \\\cline{1-3}
Develop the communication structure by means of Machine\+Design &O\+EM &Define and configure network connections and configure the SD message \\\cline{1-3}
Create Diagnostic Mapping &O\+EM &A diagnostic mapping is used to establish relation between adaptive diagnostic management and endpoints in the application software so that SD can connect the corresponding end points correctly \\\cline{1-3}
Design Communication between CP and AP &O\+EM &All activities which are necessary to design communication between two platforms \\\cline{1-3}
Integrate the Software Components &Tier 1 &The compiled Software and one main function are integrated into one executable \\\cline{1-3}
Select OS Distribution &Tier 2 &Select and Assemble an Operating System \\\cline{1-3}
Define and Configure Machine &Tier 1/2 &This includes the configuration of all machine states, function groups and the available hw resources and configure Adaptive Autosar platforms \\\cline{1-3}
Create Application Manifest &Tier 1 &In this activity, processes, startup configuration and execution dependencies for the application will be defined \\\cline{1-3}
Define and Configure Service Instance &O\+E\+M/\+Tier 1 &Define the service instances, configure their search or offer criteria and map service instance to prototype \\\cline{1-3}
Setup initial Machine &Tier 1/2 &Configure and Install OS and other necessary platform modules on the machine \\\cline{1-3}
Create Software Package &Tier 1 &Creation of Software Package \\\cline{1-3}
Provide and Manage Software Packages &O\+EM &Deploy and store software package on a back-\/end server \\\cline{1-3}
\end{longtabu}
\subsection*{1 Software Configuration}

\subsubsection*{1.\+1 Configure Data Types}

The specification of data types on the A\+U\+T\+O\+S\+AR adaptive platform follows the same pattern as the counterpart on the A\+U\+T\+O\+S\+AR classic platform\+: data types are defined on different levels of abstraction that complement each other. ~\newline
 In Adaptive Autosar we focus on two data types.
\begin{DoxyItemize}
\item Implementation\+Datat\+Types
\item Application\+Data\+Types
\end{DoxyItemize}

\paragraph*{1.\+1.\+1 Implementation\+Data\+Types}

A subset of the modeling of Implementation\+Data\+Types that is supported on the A\+U\+T\+O\+S\+AR classic platform can directly be used on the A\+U\+T\+O\+S\+AR adaptive platform as well

 \paragraph*{1.\+1.\+2 Application\+Data\+Types}

Application\+Data\+Type defines a data type from the application point of view. Especially it should be used whenever something \char`\"{}physical\char`\"{} is at stake.~\newline
 An Application\+Data\+Type represents a set of values as seen in the application model,such as measurement units. It does not consider implementation details such as bit-\/size, endianess, etc.

 \subsubsection*{1.\+2 Configure a Service Interface}

This represents the ability to define a Port\+Interface that consists of a heterogeneous collection of methods, events and fields. Service interfaces can consist of events, methods and fields and are the basis for the generation of header files for a software component.  \subsubsection*{Example Service Interface}

 \subsubsection*{1.\+3 Configure Service Interface Deployment}

The different meta-\/class specializations of {\bfseries Service\+Interface\+Deployment} define a binding of a Service\+Interface to a middleware transport layer.~\newline
 In Service\+Interface\+Deployment Configure following Attributes ~\newline

\begin{DoxyItemize}
\item {\bfseries Service\+Method\+Deployment} ~\newline
 The Service\+Method\+Deployment meta-\/class provides the ability to define middleware transport layer specific configuration settings relevant for a method that is defined in the context of a Service\+Interface. ~\newline

\item {\bfseries Service\+Event\+Deployment} ~\newline
 The Service\+Event\+Deployment meta-\/class provides the ability to define middleware transport layer specific configuration settings relevant for an event that is defined in the context of a Service\+Interface. ~\newline

\item {\bfseries Service\+Field\+Deployment} ~\newline
 The Service-\/\+Field\+Deployment meta-\/class provides the ability to define middleware transport layer specific configuration settings relevant for a field that is defined in the context of a Service\+Interface. ~\newline

\end{DoxyItemize}

 \subsubsection*{1.\+4 Configure Provided Some\+Ip Service Instance}

The Provided\+Someip\+Service\+Instance defines the service\+Instance\+Id for the Service Instance of the Someip\+Service\+Interface\+Deployment that is referenced with the service\+Interface reference.~\newline
 It means that the Server on which the Provided\+Someip\+Service\+Instance is deployed offers the Service Instance over S\+O\+M\+E/\+IP with the service\+Instance\+Id and service\+Interface\+Id.

 \subsubsection*{1.\+5 Configure Required Some\+Ip Service Instance}

The Required\+Someip\+Service\+Instance defines the required-\/\+Service\+Instance\+Id of a Someip\+Service\+Interface\+Deployment that the client searches.

 \subsubsection*{1.\+6 Configure Application Manifest}

The purpose of the application manifest is to provide information that is needed for the actual deployment of an application (formally modeled as an Sw\+Component\+Type) onto the A\+U\+T\+O\+S\+AR adaptive platform.
\begin{DoxyItemize}
\item To instantiate the same application software several times on the same machine
\item To deploy the application software to several machines and instantiate the application software per machine
\end{DoxyItemize}

\paragraph*{1.\+6.\+1 Configure Adaptive\+Application\+Sw\+Component}

This meta-\/class represents the ability to support the formal modeling of application. software on the A\+U\+T\+O\+S\+AR adaptive platform. Consequently, it shall only be used on the A\+U\+T\+O\+S\+AR adaptive platform. ~\newline
 In sw Component Configure Following elements ~\newline

\begin{DoxyItemize}
\item R Port Prototype ~\newline
 Provide Required Someip\+Service\+Interface Reference for Service
\item P Port Prototype ~\newline
 Provide Provided Someip\+Service\+Interface Reference for Service
\end{DoxyItemize}

 \paragraph*{1.\+6.\+2 Configure Executable}

This meta-\/class represents an executable program.~\newline
 It should have reference to Adaptive\+Application\+Sw\+Component which needs to be execute

 \paragraph*{1.\+6.\+3 Configure Processes}

This meta-\/class provides information required to execute the referenced executable.

 \subsubsection*{1.\+7 Map Service Instance To Port Prototype}

Configure Which service instance should use which port. Service\+Instance\+To\+Port\+Prototype\+Mapping is used to assign an Adaptive\+Platform\+Service\+Instance to a Port\+Prototype of a Sw\+Component\+Type. This allows to define how specific Port\+Prototypes of a Software Component are represented in the middleware in terms of the service configuration

 \subsection*{2. Hardware Configuration}

\subsubsection*{2.\+1 Configure Ether\+Net Cluster}

It is the main element to describe the topological connection of communicating E\+C\+Us. A cluster describes the ensemble of E\+C\+Us, which are linked by a communication medium of arbitrary topology (bus, star, ring, ...). The nodes within the cluster share the same communication protocol, which may be event-\/triggered, time-\/triggered or a combination of both. ~\newline
 Configure the Following elements In Ethernet Cluster.~\newline
 1)Ether\+Net Physical Channel~\newline
 i) Network Endpoints
\begin{DoxyItemize}
\item Ipv4 Configuration
\item Ipv6 Configuration
\end{DoxyItemize}

ii) Communication Connector Ref Conditional ~\newline
 Provide Reference To The Machine Design Communication Connectors.

 \subsubsection*{2.\+2 Configure Machine Manifest}

The Machine meta-\/class defines the entity on which one Adaptive A\+U\+T\+O\+S\+AR Software Stack is running with an operating system. The Machine may be physical or virtual. In A\+U\+T\+O\+S\+AR adaptive the element Machine is an entity which already represents a specific E\+CU Implementation with dedicated configurations for e.\+g. Processors,machine\+Mode\+Machines, function\+Groups. The Machine is a model entity which is not in the focus of communication designers and should not be used during system design.~\newline
 The Machine Manifest focuses on the following aspects\+:
\begin{DoxyItemize}
\item Configuration of the network connection and defining the basic credentials for the network technology (e.\+g. for Ethernet this involves setting of a static IP address or the definition of D\+H\+CP)
\item Configuration of the service discovery technology (e.\+g. for S\+O\+M\+E/\+IP this involves the definition of the IP port and IP multicast address to be used)
\item Definition of the used machine states
\item Definition of the used function groups
\item Configuration of the adaptive platform functional cluster implementations (e.\+g. the operating system provides a list of OS users with specific rights)
\item Configuration of the Crypto platform Module
\item Configuration of Platform Health Management
\item Configuration of Time Synchronization
\item Documentation of available hardware resources (e.\+g. how much R\+AM is available; how many processor cores are available)
\end{DoxyItemize}

\paragraph*{2.\+2.\+1 Configure Machine Design}

The Machine\+Design has been introduced in order to allow the communication system designer to define a placeholder for an adaptive E\+CU in the scope of the System (the Machine\+Design corresponds to the Ecu\+Instance of A\+U\+T\+O\+S\+AR classic) -\/\+This meta-\/class represents the ability to define requirements on a Machine in the context of designing a system \paragraph*{2.\+2.\+1.\+1 Configure network Connection}

One of the most prominent information defined in the context of the Machine\+Design is the network connectivity. Since the A\+U\+T\+O\+S\+AR adaptive platform focuses on the usage of Ethernet for communication, this boils down to the specification of IP addresses.
\begin{DoxyItemize}
\item Configure Communication connector for Ethernet cluster and provide Network endpoint for using ip address.
\item Configure Service discovery with Some ip service discovery port
\end{DoxyItemize}

\paragraph*{2.\+2.\+2 Configure Machine}

Machine that represents an Adaptive Autosar Software Stack. Provide reference to Machine\+Design.

 \subsection*{3 Map Hardware and Software Configuration}

\subsubsection*{3.\+1 Service Instance to Machine Mapping}

This allows to map Service\+Instances to a Communication\+Connector of a Machine.

 \subsection*{4 Configure Execution Manifest}

The purpose of the execution manifest is to provide information that is needed for the actual deployment of an application (formally modeled as an Sw\+Component\+Type) onto the A\+U\+T\+O\+S\+AR adaptive platform. 

\subsubsection*{4.\+1 Configure Startup}

The configuration of startup behavior is an essential part of the execution manifest.

\subsubsection*{4.\+2 Configure Mode-\/dependent Startup Configuration}

The purpose of meta-\/class Mode\+Dependent\+Startup\+Config is to qualify the startup configuration represented by meta-\/class Startup\+Config for specific Mode\+Declarations. Each Mode\+Dependent\+Startup\+Config of a Process shall reference at least one Mode\+Declaration in the role function\+Group\+Mode or in the role machine\+Mode \hypertarget{adaptive_state_manager}{}\section{State Manager}\label{adaptive_state_manager}

\begin{DoxyItemize}
\item State Management is responsible to determine the operation state, based on information received or gathered from other Adaptive Platform Applications or Adaptive Applications.
\item State Manager functional cluster determine the overall operation of Adaptive platform.
\item It would interact with Execution Manager to change functional group and machine state.
\item Adaptive Platform Functional clusters e.\+g. Diagnostic Manager and, Update and Configuration Manager can request the State Manager to change the state, depending on arbitration State Manager would change the state.
\item State Manager would arbitrate multiple request and signal to decide state change and State Manager implementation would be project spcific.
\end{DoxyItemize}

\subsection*{Glossary of Terms}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Term }&\textbf{ Definition  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Term }&\textbf{ Definition  }\\\cline{1-2}
\endhead
State Management &The element defining modes of operation for A\+U\+T\+O\+S\+AR Adaptive Platform. It allows flexible definition of functions which are active on the platform at any given time. \\\cline{1-2}
Execution Management &Functional Cluster within the Adaptive Platform Foundation. \\\cline{1-2}
Communication Management &A Functional Cluster within the Adaptive Platform Foundation. \\\cline{1-2}
Network Management &A Functional Cluster within the Adaptive Platform Services. Part of Communication Management. \\\cline{1-2}
Adaptive Diagnostics &A Functional Cluster within the Adaptive Platform Services. \\\cline{1-2}
Update And Configuration Management&A Functional Cluster within the Adaptive Platform Services. \\\cline{1-2}
Network Handle &Network Handles are provided by Network Management. A handle represents a set of (partial) networks. \\\cline{1-2}
Process &A process is a loaded instance of an Executable to be executed on a Machine. \\\cline{1-2}
Function Group &A Function Group is a set of coherent Processes, which need to be controlled consistently. Depending on the state of the Function Group, Processes are started or terminated. \\\cline{1-2}
Component &Element of a Process. Processes are comprised of one or more S\+W-\/entities that provide a particular function or group of related functions called Component. \\\cline{1-2}
Function Group State &The element of State Management that characterizes the current status of a set of (functionally coherent) user-\/level Applications. The set of Function Groups and their Function Group States is machine specific and are configured in the Machine Manifest. \\\cline{1-2}
Machine State &The state of Function Group \char`\"{}\+Machine\+State\char`\"{} with some predefined states (Startup/\+Shutdown/\+Restart). \\\cline{1-2}
Operational State &The element of State Management that characterizes the current internal state of the State Management. The Operational State is machine specific and depends on multiple events from somewhere within the system. \\\cline{1-2}
Component State &The element of State Management that characterizes the current state of Components within an Adaptive Application. The Component State is Adaptive Application specific and therefore it has to be described in the respective Execution Manifest. Every Adaptive Application provides at least an \char`\"{}\+On\char`\"{} and an \char`\"{}\+Off\char`\"{} State. \\\cline{1-2}
Execution Manifest &Manifest file to configure execution of an Adaptive Application. \\\cline{1-2}
Machine Manifest &Manifest file to configure a Machine. \\\cline{1-2}
\end{longtabu}
\subsection*{Dependencies of State Management}


\begin{DoxyItemize}
\item Operating System Interface\+:
\begin{DoxyItemize}
\item State Management has no direct interface to the Operating System, all OS dependencies are abstracted by the Execution Management and Persistency.
\end{DoxyItemize}
\item Execution Manager Interface\+:
\begin{DoxyItemize}
\item State Management is dependent on Execution Management to control operation state.
\item Execution Manager will fork or terminate an application depending upon the state requested and state defined in the application manifest.
\end{DoxyItemize}
\item Persistency\+:
\begin{DoxyItemize}
\item State Management is dependent on the Persistency functional cluster to access persistent storage.
\end{DoxyItemize}
\item Adaptive Diagnostics\+:
\begin{DoxyItemize}
\item State Manager will evaluate the information received from the Diagnostic Manager about the ongoing Session and decide the operational states based on the evaluation.
\end{DoxyItemize}
\item Update And Configuration Management\+:
\begin{DoxyItemize}
\item State Manager will interact with Update and Configuration Management to check the ongoing update session and decide the operation states.
\end{DoxyItemize}
\item Network Management\+:
\begin{DoxyItemize}
\item Network Management provides multiple Network\+Handle fields which represents a set of (partial) networks.
\item State Management evaluates this fields to set Function Groups to the corresponding Function Group State defined in Manifest and vice versa.
\item Additionally State Management shall prevent system from shutting down during an update session is ongoing.
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{State Manager Architecture\+:}


\begin{DoxyItemize}
\item State Manager communicate with execution manager for state change through A\+PI provided by execution manager i.\+e Get\+State(), Set\+State() which uses P\+O\+S\+IX F\+I\+FO.
\item It report its internal state i.\+e k\+Running , k\+Terminating back to Execution Manager through exec A\+PI.
\item Platform Health Manager interact with State Manager through service interface, in case State Manager does not respond back Platform Health Manager will also have an interface with Execution Manager to change state for recovery action.
\item It also has service interface defined for other application to interact with State Manager to notify and request for functional group state change as well as for component state.
\end{DoxyItemize}

\subsection*{State Management Responsibility\+:}


\begin{DoxyItemize}
\item State Management is the functional cluster responsible to communicate with the Execution Manager, determine the current operational state and request for transition to different operational state.
\item It ensures that the application are executed when it is actually needed and it also provide necessary resources granting them full control.
\item It is the central point where all events are received, further operational state transition will be decided after the evaluation is done based on event type, event priority and application identifier.
\item If an operational state change is triggered then State Manager will request the Execution Manager for a state change.
\item Operation state change can be triggered by multiple application which are as follows\+: • Platform Health Management to trigger error recovery, e.\+g. to activate fall back Functionality. • Adaptive Diagnostics, to switch the system into diagnostic states. • Update and Configuration Management to switch the system into states where software or configuration can be updated. • Network Management to coordinate required functionality and network state. • Authorized applications, e.\+g. a vehicle State Manager which might be located in a different machine or on a different E\+CU.
\item Autosar Application may trigger the State Manager events through ara-\/com interface where the State Manager will be subscribing.
\item It also provide interface to the Application to request information about the current state through ara-\/com.
\item State Manager has critical functionality, access is secured through the Identity Access Manager.
\item It is monitored and supervised by Platform health Manager which also has direct access to Execution Manager to change operational state when State Manager stops responding.
\item Operational state is the internal state of State Manager upon which decision will be made for next state change.
\end{DoxyItemize}

\subsection*{Machine State\+:}


\begin{DoxyItemize}
\item Machine state is specific type of function group state which refer to the global state of the machine.
\item State Manager will request the Execution Manager to change these state based on vehicle-\/wide event and priority evaluation.
\item Whenever State Manager requests Execution Manager for a state change, Execution Manager will terminate the application belonging to the current state and fork new application.
\item Machine state define the set of process to be forked by execution manager.
\item Each Application would have an application manifest, which defines the machine state in which the application is allowed to execute.
\item Adaptive Autosar Platform will have 3 mandatory machine state i.\+e Startup, Restart and Shutdown along with project specific machine state.
\item Startup will be the default machine state in Execution Manager and State Manager will control the operational flow henceforth.
\item Startup Machine State\+:
\begin{DoxyItemize}
\item Execution Manager will be controlled by State Manager hence it should not be able to change the machine state on its own.
\item Hence State Manager should run in each and every machine state or the Adaptive Platform will not be able to transit to any other machine state.
\item Startup will be the default machine state in Execution Manager and State Manager should also belong to Startup Machine state so that it can control the operational flow.
\end{DoxyItemize}
\item Shutdown State/\+Restart State\+:
\begin{DoxyItemize}
\item State Management will be configured to run in Shutdown/\+Restart.
\item State transition is not a trivial system change and it can fail for a number of reasons. When ever this happens State Management has to be alive, to report an error and wait for further instructions.
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{State Transition}


\begin{DoxyItemize}
\item Execution Manager is initiated after boot up, it will fork all application belonging to startup phase.
\item State Manager has Startup state defined in its execution manifest.
\item After State Manager is initialized it will decide the state change henceforth and request Execution Manager for state change.
\item Executiion Manager on request from State Manager will initiate state change, first it will send S\+I\+G\+T\+E\+RM signal to all application an indication for all application to terminate itself.
\item If the application doesnot terminate within the timeout specified in its execution mnifest execution terminate the application and confirm state change. 
\end{DoxyItemize}

\subsection*{Functional Group State}


\begin{DoxyItemize}
\item Machine state mechanism is not flexible enough to control a group of application which are functionally coherent, in particular if they have to be started and terminated with interleaving life-\/cycle.
\item Hence additional function group and functional group state can be configured.
\item During diagnostic and error recover it is necessary to handle such application using functional group state.
\item Machine state controls machine life-\/cycle and processes of platform level application while function group state control process functionally coherent user application.
\item State Manager will obtain available functional group state and machine state from machine manifest.
\item Processes refers in their execution manifest the state in which they want to execute, state can be functional group state and machine state.
\item Application is provided with communication interface with the State Manager to request functional group state change.
\item If there are multiple request from different application, State Manager would arbitrate based on priority and other factor before requesting Execution Manager for state change. 
\end{DoxyItemize}

\subsection*{State Management and Components state}


\begin{DoxyItemize}
\item Transition from one operational state to another usually require termination of application and forking new application.
\item When execution manager need to change the internal behaviour of process it needs to unload the process from memory and reload the executable, to avoid such overhead component state is used .
\item Component state is basically state inside a process where process can have one or multiple component i.\+e threads. 
\item Late-\/wakeup is an use-\/case of component state, where process can have ON or O\+FF state and threads corresponding to each state.
\item whenever shutting down is invoked process can execute O\+FF state threads, while shutting down new wake-\/up reason is found.
\item Instead of terminating the process and again loading the process, Component state i.\+e ON and O\+FF can be used.
\item O\+FF state would perform all the persistence data and ON state would resume the activity without terminating the process hence avoiding the overhead of unloading process from memory.
\end{DoxyItemize}

 \subsection*{Component state Handling}


\begin{DoxyItemize}
\item State management will calculate component state from current operational state and other requirement and send state to registered process.
\item Process need to register with State Manager via A\+PI interface to receive component state ,when components do not require component state it can unregister from State Manager.
\item Registration done by calling the constructor of component-\/client and un-\/registration is done by calling destructor.
\item Component are allowed to temporarily avoid component state change due ongoing critical execution. component has to send confirmation that it has received the state change request.
\item After certain timeout the State Manager will again request for component state change, this retry count and timeout values are configured in the execution manifest.
\item When maximum retries are over State Manager will force the process to transit into a component state.
\item Components must be able to perform a transition from any Component State into any Component State that they have defined. 
\end{DoxyItemize}

\subsection*{Interaction with Diagnostic Manager}


\begin{DoxyItemize}
\item Adaptive Diagnostics is responsible for diagnosis, configuration and resetting of Function Groups. During any diagnostic request is executed it is necessary to prevent system from shutting down.
\item State Management shall not shutdown the system during an active diagnostic session. Therefore State Management has to register to Adaptive Diagnostics to receive information about active diagnostic session.
\item Adaptive Diagnostic have several reset type i.\+e hard\+Reset, soft\+Reset and key\+Off\+On\+Reset to carry out functionalities of diagnostic.
\item State Manager would translate this reset and send equivalent component state to the process.
\item A hard\+Reset could be interpreted as Hardware reset while soft\+Reset could be interpreted as loading the software configuration and key\+O\+F\+F\+On\+Reset could mean restarting the functional group state.
\item State Manager also has functionality to persist the reset cause while resetting the Machine state.
\item State Manager will also read the last reset cause when spawned by execution manager and set the persist data to default value.
\end{DoxyItemize}

\subsection*{Interaction with the Update and Configuration Management}


\begin{DoxyItemize}
\item State Manager has to register with the update and Configuration Management to receive information about the ongoing update and It will not shutdown the system while the update is going on.
\item Update and verify state should be available to enable the update and Configuration Management to fulfill its functionality.
\item Update and Configuration Management would request for the corresponding state from State Manager.
\item When a platform software is updated which needs a Machine reset State Manager should have means to reset the machine.
\item If an application software is updated which doesn\textquotesingle{}t need system reset the State Manager should have meant to trigger execution manager to re-\/parse the manifest update the application list.
\end{DoxyItemize}

\subsection*{Interaction with Network Management}


\begin{DoxyItemize}
\item State Management interacts with Network Management via a service interface.
\item Network Management provides multiple instances of Network\+Handles, where each represents a set of (partial) networks.
\item The Network\+Handles are defined in the Machine Manifest and are there assigned to a Function Group State.
\item Whenever network is activated or deactivated due outside request corresponding handle is set which is notified to State Manager which in turn would change the corresponding functional group state.
\item Similarly State Manager would change the network handle when functional group is changed and the association between functional group and network handle is available in Machine Manifest.
\item It might be needed that a Function Group stays longer in its Function Group State when the causing (partial) network set has been switched off network is longer available than the causing Function Group has been switched to Function Group State ’\+Off’. This is called ’afterrun’. The corresponding timeoutvalue has to be configured in Machine Manifest. 
\end{DoxyItemize}\hypertarget{Guideline_Document_for_Platform_Health_Management}{}\section{Platform Health Management}\label{Guideline_Document_for_Platform_Health_Management}

\begin{DoxyItemize}
\item \hyperlink{Introduction}{Introduction}
\item \hyperlink{Architecture_Design}{Architecture Design}
\item \hyperlink{Appendix}{Appendix} 
\end{DoxyItemize}\hypertarget{Introduction}{}\subsection{Introduction}\label{Introduction}
Platform Health Management is a functional cluster in Adaptive A\+U\+T\+O\+S\+AR architecture that provides mechanism to detect health status of application and trigger appropriate actions. The P\+HM supervises the execution of a configurable number of so-\/called Supervised Entities. When it detects a violation of the configured temporal and/or logical constraints on program execution, it takes several configurable actions to recover from this failure.

\section*{Abbreviations}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Abbreviation }&\textbf{ Meaning  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Abbreviation }&\textbf{ Meaning  }\\\cline{1-2}
\endhead
A\+PI &Application Programming Interface \\\cline{1-2}
A\+U\+T\+O\+S\+AR &A\+U\+Tomotive Open System Architecture \\\cline{1-2}
C\+PU &Central Processing Unit \\\cline{1-2}
E\+CU &Electronic Control Unit \\\cline{1-2}
OS &Operating System \\\cline{1-2}
R\+AM &Random Access Memory \\\cline{1-2}
R\+OM &Read Only Memory \\\cline{1-2}
AA &Adaptive Application \\\cline{1-2}
A\+RA &A\+U\+T\+O\+S\+AR Runtime for Adaptive Applications \\\cline{1-2}
SE &Supervised Entity \\\cline{1-2}
HW &Hardware \\\cline{1-2}
P\+HM &Platform Health Management \\\cline{1-2}
HC &Health Channel \\\cline{1-2}
I\+PC &Inter Process Communication \\\cline{1-2}
I\+SO &International Organization for Standardization \\\cline{1-2}
HM&Health Monitoring \\\cline{1-2}
\end{longtabu}
\section*{1. P\+HM Features}

P\+HM provides two main features\+:
\begin{DoxyEnumerate}
\item Supervision
\item Health Channel Status (External)
\end{DoxyEnumerate}

 \subsection*{1.\+1 Supervision}

P\+HM has three supervisions.

\subsubsection*{1.\+1.\+1 Alive Supervision}

Alive Supervision offers a mechanism to periodically check the execution reliability of one or more Supervised Entities.

 {\bfseries Example for Alive Supervision\+:} A 2ms task is being monitored at every 10ms. So, after 10ms the counter monitoring the 2ms task should be updated to 5(-\//+). Whether the monitoring counter is being updated to 5(-\//+) is monitored under Alive Supervision.

\subsubsection*{1.\+1.\+2 Deadline Supervision}

Deadline Supervision checks the timing constraints of non-\/cyclic Supervised Entity. It is a kind of supervision that checks if the execution time between two Checkpoints is within minimum/maximum time limit.

 {\bfseries Example for Deadline Supervision\+:} A Supervised Entity is meant to execute within 10ms. Two checkpoints will be placed in this Supervised Entity and time stamps will be taken between the start and the end checkpoint. The time difference between the checkpoints will give the time taken for execution of the Supervised Entity. Time interval between two checkpoints are monitored under Deadline Supervision.

\subsubsection*{1.\+1.\+3 Logical Supervision}

Logical Supervision checks for the correct execution flow of code within a Supervised Entity and also ascertains that different Supervised Entities are executed in order.

{\bfseries Example for Logical Supervision\+:} In the Supervised Entity, there are two conditional paths for execution A and B, wherein one path is correct. Checkpoints are placed in the Supervised Entity. The flow of execution is monitored by monitoring these checkpoints.

\subsection*{1.\+2 Health Channel Status (External)}

Health Channel Status is the result of an environment monitoring, memory integrity test routine, operating system or Kernel and Virtual Machine or E\+CU. (e.\+g. Voltage Monitoring, Temperature Monitoring, R\+AM test, R\+OM test, OS Status, Kernel Status). \hypertarget{Architecture_Design}{}\subsection{Architecture Design}\label{Architecture_Design}
\section*{1. Static View}

\subsection*{1.\+1 Software Architecture}

 The above figure explains Adaptive Platform architecture logical view. The Adaptive Applications (AA) run on top of A\+RA (A\+U\+T\+O\+S\+AR Runtime for Adaptive Applications). A\+RA consists of application interfaces provided by Functional Clusters, which belong to either Adaptive Platform Foundation or Adaptive Platform Services. Adaptive Platform Foundation provides fundamental functionalities whereas Adaptive Platform Services provide platform standard services.

\subsection*{1.\+2 P\+HM Architecture}


\begin{DoxyItemize}
\item {\bfseries The Platform Health Management (P\+HM)} supervises the Applications and could trigger a Recovery Action in case any Supervised Entity fails. The Recovery Actions are defined by the integrator based on the software architecture requirements for the Platform Health Management and configured in Manifests. The P\+HM functionality is divided into two parts\+: P\+HM Library and P\+HM Daemon.

P\+HM Library is built and linked along with Application and executed in the context of Adaptive Application process. P\+HM Daemon is executed as a separate process. Application reports health status or check points to P\+HM Library and P\+HM Library passes this information to P\+HM Daemon using I\+PC Socket Communication. P\+HM Daemon calculates Local Supervision Status based on supervised entities and later computes Global Supervision Status based on one or more Local Supervision Status. It arbitrates one or several Health channel (External and Internal-\/based on Global Supervision Status) and takes several actions to recover from fault.
\end{DoxyItemize}

\section*{Action Table}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\PBS\centering \textbf{ Sl. No. }&\textbf{ Action Name }&\textbf{ Description }&\textbf{ Responsible }&\textbf{ Interface  }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\PBS\centering \textbf{ Sl. No. }&\textbf{ Action Name }&\textbf{ Description }&\textbf{ Responsible }&\textbf{ Interface  }\\\cline{1-5}
\endhead
\PBS\centering 1 &T\+E\+R\+M\+I\+N\+A\+T\+E\+\_\+\+A\+PP &Terminate the running application &State Management &Request\+State \\\cline{1-5}
\PBS\centering 2 &R\+E\+S\+T\+A\+R\+T\+\_\+\+A\+PP &Restart the running application &Execution Management &Process\+Restart \\\cline{1-5}
\PBS\centering 3 &R\+E\+S\+E\+T\+\_\+\+P\+L\+A\+T\+F\+O\+R\+M\+\_\+\+I\+N\+S\+T\+A\+N\+CE &Shutdown and Restart the partition/\+E\+CU, based on the system. &Execution Management &Enter\+Safe\+State, Request\+State \\\cline{1-5}
\PBS\centering 4 &W\+A\+T\+C\+H\+D\+O\+G\+\_\+\+R\+E\+S\+ET &Stop refreshing the watchdog. &So that after the configured (in watchdog driver) timeout the reset occurs. &Watchdog Driver Trigger\+Watchdog (implementation specific) \\\cline{1-5}
\end{longtabu}

\begin{DoxyItemize}
\item {\bfseries State Management} is responsible to determine the operation state, based on information received or gathered from other Adaptive Applications. State Management interacts with Execution Management to request Function Groups and the Machine State to enter specific states that are determined to project requirement.

Platform Health Management requests State Manager to switch to a specified Machine, Function Group or Application state using {\itshape Request\+State()} A\+PI.
\item {\bfseries Execution Management} is responsible for platform initialization and the startup and shutdown of Adaptive Application. It performs these tasks using information contained within one or more Manifest files. Platform Health Management requests Execution Manager to restart a specified process using {\itshape Process\+Restart()} A\+PI and request to force switching to a specified Machine or Function Group state using {\itshape Enter\+Safe\+State()} A\+PI.
\item {\bfseries Diagnostic Management} intended to support an own diagnostic server instance per installed Software Cluster and this server is responsible for processing/dispatching of diagnostic services according to I\+SO 14229-\/1.

Platform Health Management reports error information to Diagnostic Manager. However, interface is not yet defined.
\item {\bfseries HW Watchdog} offers watchdog timers as standalone devices for applications requiring a high security level. It will monitor software code execution, or hardware failures, and can trigger appropriate action, such as system reboot.

Platform Health Management requests the Watchdog driver to perform watchdog reset.
\item {\bfseries The Log and Trace (L\&T)} provides interface to forward logging information onto the communication bus, the console, or to the file system. Platform Health Management requests L\&T to log Local Supervision Status, Global Supervision Status, Arbitration Result etc.
\item {\bfseries Applications} can interact with Platform Health Management Library using {\itshape Report\+Health\+Status()} and {\itshape Report\+Check\+Point()} A\+P\+Is. Safety Application can get the statuses from Platform Health Management Library using {\itshape Get\+Local\+Status()} and {\itshape Get\+Global\+Status()} A\+P\+Is.
\item {\bfseries Manifest file} is an input for Applications and Platform Health Management.
\end{DoxyItemize}

\subsection*{1.\+3 Interface between P\+HM and other functional clusters}

 P\+HM interacts with other Functional Clusters like Execution Manager, State Manager etc. Above diagram shows the way P\+HM communicates with other functional clusters.


\begin{DoxyItemize}
\item P\+HM calls {\itshape Get\+All\+Process\+State()} of Execution Manager to determine if any Supervised Entity is activated or deactivated for specific time and it is notified by the Execution Manager by change in process state using {\itshape Process\+Changed()}.
\item P\+HM requests Execution Manager to restart a specified process using {\itshape Restart\+Process()} A\+PI.
\item Requests the State Manager to switch to a specified Machine, Function\+Group or Application state using {\itshape Request\+State()} A\+PI.
\item Requests the Watchdog driver to perform a watchdog reset (implementation specific A\+PI).
\item Reports error information to the Diagnostic Manager (interface not specified).
\end{DoxyItemize}

\subsection*{1.\+4 Configuration Methodology (Example)}

\subsubsection*{1.\+4.\+1 Application Design Configuration}

 \subsubsection*{1.\+4.\+2 P\+HM Configuration}

 \subsubsection*{1.\+4.\+3 P\+HM Instance Reference}



 \subsubsection*{1.\+4.\+4 Logical Expression}

 \subsubsection*{1.\+4.\+5 Arbitration}

 \section*{2. Dynamic View}

\subsection*{2.\+1 Execution Flow}


\begin{DoxyItemize}
\item {\bfseries External Health Channels\+:} In above example, Voltage Monitoring Application and Temperature Monitoring Application are two External Health Channels. Their respective health status is shown in above figure. External Health Channel Status is used to perform Mode Arbitration.
\item {\bfseries Local Supervision}

The Supervised Entities can be monitored using Local Supervision Status which is the aggregation of three Supervisions (Alive Supervision, Deadline Supervision, Logical Supervision).

During a monitoring cycle, the supervised entities configured in the running process are evaluated and the local status of each entity is updated based on the results of the evaluation. Based on the update in the local status the global status is also updated. If a failure occurs for a Supervised Entity, the failure counters are incremented till they reach the pre-\/configured threshold. If a threshold is reached the local status of the Supervised Entity is updated.

For more details refer \hyperlink{_appendix_Local_Supervision_Status}{Local Supervision Status}.
\item {\bfseries Global Supervision}

Global Supervision is computed based on Local Supervision Status of Supervised Entities. If the pre-\/configured Global Threshold counters exceed due to failure of the supervised entities Global Status is updated. It is mapped with Health Channel Status (Internal).

For more details refer \hyperlink{_appendix_Global_Supervision_Status}{Global Supervision Status}.
\item {\bfseries Mode Arbitration}

In Arbitration Part, Mode Values of one or multiple Health Channels make Logical Expression and depending on this Logical Expression result, configured action will be taken. Possible actions include restart of applications, or a state change within an application, function group or E\+CU.
\end{DoxyItemize}

\subsection*{2.\+2 Sequence Diagram}

 \subsection*{2.\+3 Activity Diagram}


\begin{DoxyItemize}
\item In Supervised Entity any number of checkpoints can be configured for Alive Supervision. For Alive Supervision, Supervise Entity calls {\itshape Report\+Check\+Point()} with appropriate checkpoint id. This increments Alive counter for the checkpoint.
\item Periodic checking of Alive counter happens at every Alive Reference Cycle by Health Monitoring. This Alive Supervision Cycle is defined in attribute of Alive Supervision.
\item Health Monitoring examines the Alive counter if it is within margin (Expected Alive Indication -\/ Min Margin; Expected Alive Indication + Max Margin) or not. These Margin parameters also defined in configuration of Alive Supervision.
\item Expected Alive Indication is amount of expected Alive indication of checkpoint. Min Margin and Max margin are allowed tolerance of expected indication. 
\end{DoxyItemize}\hypertarget{Appendix}{}\subsection{Appendix}\label{Appendix}
\hypertarget{_appendix_Local_Supervision_Status}{}\subsubsection{1. Local Supervision Status}\label{_appendix_Local_Supervision_Status}
\label{_appendix_LocalSupervisionStatus}%
\Hypertarget{_appendix_LocalSupervisionStatus}%
 Local Supervision Status determines the status of specific Supervised Entities. This is done based on the following\+:
\begin{DoxyItemize}
\item Previous value of the Local Supervision Status,
\item Current values of result of Alive\+Supervision, result of Deadline\+Supervision, result of Logical\+Supervision.
\end{DoxyItemize}

{\bfseries Failed\+Supervision\+Cycles\+Tolerance\+:} maximum acceptable amount of Supervision Cycles in the local state L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED before it is considered L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED.

For the transitions between the states of the Local Supervision Status the following rules apply\+:

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\PBS\centering \textbf{ Rule No.}&\textbf{ Present State}&\textbf{ Transition condition }&\textbf{ Next Status}&\PBS\centering \textbf{ Transition No.  }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\PBS\centering \textbf{ Rule No.}&\textbf{ Present State}&\textbf{ Transition condition }&\textbf{ Next Status}&\PBS\centering \textbf{ Transition No.  }\\\cline{1-5}
\endhead
\PBS\centering 1&Initial Supervision Mode&HM Sucessfully Initialized&L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK&\PBS\centering \hyperlink{_appendix_LocalSupervisionStatus}{10} \\\cline{1-5}
\PBS\centering 2&Initial Supervison Mode&HM Sucessfully Initialized but SE not activated in initial mode&L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+D\+E\+A\+C\+T\+I\+V\+A\+T\+ED&\PBS\centering \hyperlink{_appendix_LocalSupervisionStatus}{11} \\\cline{1-5}
\PBS\centering 3&Initial Supervision Mode &HM Sucessfully Initialized and Inital mode of SE not configured to L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+D\+E\+A\+C\+T\+I\+V\+A\+T\+ED&\PBS\centering \hyperlink{_appendix_LocalSupervisionStatus}{11} \\\cline{1-5}
\PBS\centering 4&L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+D\+E\+A\+C\+T\+I\+V\+A\+T\+ED&No Supervision function performed by HM and {\itshape Report\+Check\+Point() } for SE&L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+D\+E\+A\+C\+T\+I\+V\+A\+T\+ED&\PBS\centering \hyperlink{_appendix_LocalSupervisionStatus}{8} \\\cline{1-5}
\end{longtabu}


\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{6}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\PBS\centering \textbf{ Rule No. }&\textbf{ Present Status }&\textbf{ Transistion condition }&\textbf{ Next Status }&\textbf{ failed Supervision reference cycle counter }&\PBS\centering \textbf{ Transition No.  }\\\cline{1-6}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\PBS\centering \textbf{ Rule No. }&\textbf{ Present Status }&\textbf{ Transistion condition }&\textbf{ Next Status }&\textbf{ failed Supervision reference cycle counter }&\PBS\centering \textbf{ Transition No.  }\\\cline{1-6}
\endhead
\PBS\centering 5 &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK &All are correct &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK &-\/&\PBS\centering \hyperlink{_appendix_LocalSupervisionStatus}{1} \\\cline{1-6}
\PBS\centering 6 &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK &Any one is incorrect&L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED &-\/&\PBS\centering \hyperlink{_appendix_LocalSupervisionStatus}{2} \\\cline{1-6}
\PBS\centering 7 &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK &If Alive is incorrect and rest are correct and failed Supervision Cycles Tolerance configured $>$ 0 &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED &Increments&\PBS\centering \hyperlink{_appendix_LocalSupervisionStatus}{3} \\\cline{1-6}
\PBS\centering 8 &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED &At least one SE of Alive is incorrect and rest are correct and failed Supervision Cycles Tolerance configured $>$ failed Supervision reference cycle counter &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED &Increments &\PBS\centering \hyperlink{_appendix_LocalSupervisionStatus}{4} \\\cline{1-6}
\PBS\centering 9 &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED &All Supervisions are correct and failed Supervision reference cycle counter $>$ 1 &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED &Decrements &\PBS\centering \hyperlink{_appendix_LocalSupervisionStatus}{4} \\\cline{1-6}
\PBS\centering 10 &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED &All are correct and failed Supervision reference cycle counter = 1 &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK &Decrements &\PBS\centering \hyperlink{_appendix_LocalSupervisionStatus}{5} \\\cline{1-6}
\PBS\centering 11 &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED &(If Alive is incorrect and failed Supervision reference cycle counter $>$ failed Supervision Cycles Tolerance configured)Or (Deadline and Logical are incorrect) &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED &-\/ &\PBS\centering \hyperlink{_appendix_LocalSupervisionStatus}{6} \\\cline{1-6}
\end{longtabu}
{\bfseries Effect of changing mode\+:} There are two modes of SE Activated and Deactivated mode.

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\PBS\centering \textbf{ Rule No. }&\textbf{ Present Status }&\textbf{ Transition condition }&\textbf{ Next Status }&\PBS\centering \textbf{ Transition no.  }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\PBS\centering \textbf{ Rule No. }&\textbf{ Present Status }&\textbf{ Transition condition }&\textbf{ Next Status }&\PBS\centering \textbf{ Transition no.  }\\\cline{1-5}
\endhead
\PBS\centering 12 &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK &switched to a mode that deactivates SE &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+D\+E\+A\+C\+T\+I\+V\+A\+T\+ED &\PBS\centering \hyperlink{_appendix_LocalSupervisionStatus}{7} \\\cline{1-5}
\PBS\centering 13 &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED &switched to a mode that deactivates SE &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+D\+E\+A\+C\+T\+I\+V\+A\+T\+ED &\PBS\centering \hyperlink{_appendix_LocalSupervisionStatus}{12} \\\cline{1-5}
\PBS\centering 14 &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+D\+E\+A\+C\+T\+I\+V\+A\+T\+ED &switched to a mode that activates SE &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK &\PBS\centering \hyperlink{_appendix_LocalSupervisionStatus}{9} \\\cline{1-5}
\end{longtabu}
\hypertarget{_appendix_Global_Supervision_Status}{}\subsubsection{2. Global Supervision Status}\label{_appendix_Global_Supervision_Status}
\label{_appendix_GlobalSupervisionStatus}%
\Hypertarget{_appendix_GlobalSupervisionStatus}%

\begin{DoxyItemize}
\item Global Supervision Status is calculated based on the Local Supervision Status of all the Supervised Entities.
\item Global Supervision Status provides two variables i.\+e. Supervision cycle and Expire Supervision cycles Tolerance.
\end{DoxyItemize}

{\bfseries Supervision cycle} is the period at which the Health Monitoring is performed. This describes at which cycle the Global Supervision and its contained Local Supervisions are executed.

{\bfseries Expire Supervision cycles Tolerance} is maximum acceptable amount of Supervision Cycles in the global state G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED before it is considered G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+T\+O\+P\+P\+ED.


\begin{DoxyItemize}
\item Health Monitoring has advantage of postponing the error reaction for a configurable value of Supervision Cycle and Expire Supervision Cycles Tolerance.
\item The cyclic update of Global Supervision Status is necessary to trigger the timely transition from G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED to G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+T\+O\+P\+P\+ED.
\end{DoxyItemize}

The following rules apply for the states of the Global Supervision Status.

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\PBS\centering \textbf{ Rule No.}&\textbf{ Present Status}&\textbf{ Transition }&\textbf{ Next Status}&\PBS\centering \textbf{ Transition No.  }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\PBS\centering \textbf{ Rule No.}&\textbf{ Present Status}&\textbf{ Transition }&\textbf{ Next Status}&\PBS\centering \textbf{ Transition No.  }\\\cline{1-5}
\endhead
\PBS\centering 1 &I\+N\+IT &Statically Initalized&G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+D\+E\+A\+C\+T\+I\+V\+A\+T\+ED&\PBS\centering \hyperlink{_appendix_GlobalSupervisionStatus}{18} \\\cline{1-5}
\PBS\centering 2 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+D\+E\+A\+C\+T\+I\+V\+A\+T\+ED&Sucessfully Initalized&G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK&\PBS\centering \hyperlink{_appendix_GlobalSupervisionStatus}{13} \\\cline{1-5}
\PBS\centering 3 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK&HM Deactivted&G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+D\+E\+A\+C\+T\+I\+V\+A\+T\+ED&\PBS\centering \hyperlink{_appendix_GlobalSupervisionStatus}{14},\hyperlink{_appendix_GlobalSupervisionStatus}{15}, \hyperlink{_appendix_GlobalSupervisionStatus}{16}, \hyperlink{_appendix_GlobalSupervisionStatus}{17} \\\cline{1-5}
\PBS\centering 4 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK or G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED&Changing supervision mode fails&G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+T\+O\+P\+P\+ED&\PBS\centering \hyperlink{_appendix_GlobalSupervisionStatus}{12} \\\cline{1-5}
\end{longtabu}
\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{6}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\PBS\centering \textbf{ Rule No. }&\textbf{ Present Status }&\textbf{ Local Supervision Status }&\PBS\centering \textbf{ Expired Supervision Cycle Tolerance }&\textbf{ Next Status }&\PBS\centering \textbf{ Transition No.  }\\\cline{1-6}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\PBS\centering \textbf{ Rule No. }&\textbf{ Present Status }&\textbf{ Local Supervision Status }&\PBS\centering \textbf{ Expired Supervision Cycle Tolerance }&\textbf{ Next Status }&\PBS\centering \textbf{ Transition No.  }\\\cline{1-6}
\endhead
\PBS\centering 5 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK &L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK or L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+D\+E\+A\+C\+T\+I\+V\+A\+T\+ED &\PBS\centering -\/ &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK &\PBS\centering \hyperlink{_appendix_GlobalSupervisionStatus}{1} \\\cline{1-6}
\PBS\centering 6 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK &At least one SE is L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED and no SE is L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED &\PBS\centering -\/ &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED &\PBS\centering \hyperlink{_appendix_GlobalSupervisionStatus}{2} \\\cline{1-6}
\PBS\centering 7 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK &At least one SE is L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED &\PBS\centering Configure value $>$$>$ 0 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED &\PBS\centering \hyperlink{_appendix_GlobalSupervisionStatus}{3} \\\cline{1-6}
\PBS\centering 8 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK &At least one SE is L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED &\PBS\centering Configured value=0 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+T\+O\+P\+P\+ED &\PBS\centering \hyperlink{_appendix_GlobalSupervisionStatus}{4} \\\cline{1-6}
\PBS\centering 9 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED &At least one SE is L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED and no SE is L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED &\PBS\centering -\/ &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED &\PBS\centering \hyperlink{_appendix_GlobalSupervisionStatus}{5} \\\cline{1-6}
\PBS\centering 10 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED &Either all the SE are L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK or L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+D\+E\+A\+C\+T\+I\+V\+A\+T\+ED &\PBS\centering -\/ &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK &\PBS\centering \hyperlink{_appendix_GlobalSupervisionStatus}{6} \\\cline{1-6}
\PBS\centering 11 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED &At least one SE is L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED &\PBS\centering Configure value$>$0 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED &\PBS\centering \hyperlink{_appendix_GlobalSupervisionStatus}{7} \\\cline{1-6}
\PBS\centering 12 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+ED &At least one SE is L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED &\PBS\centering Configure value=0 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+T\+O\+P\+P\+ED &\PBS\centering \hyperlink{_appendix_GlobalSupervisionStatus}{8} \\\cline{1-6}
\PBS\centering 13 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED &At least one SE is L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED &\PBS\centering Expired cycle counter less than or equal to &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED and increment the Expired Cycle Counter &\PBS\centering \hyperlink{_appendix_GlobalSupervisionStatus}{9} \\\cline{1-6}
\PBS\centering 14 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED &At least one SE is L\+O\+C\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+E\+X\+P\+I\+R\+ED &\PBS\centering Expired cycle counter $>$ configured Tolerance value &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+T\+O\+P\+P\+ED &\PBS\centering \hyperlink{_appendix_GlobalSupervisionStatus}{10} \\\cline{1-6}
\PBS\centering 15 &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+T\+O\+P\+P\+ED &-\/ &\PBS\centering -\/ &G\+L\+O\+B\+A\+L\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+T\+O\+P\+P\+ED &\PBS\centering \hyperlink{_appendix_GlobalSupervisionStatus}{11} \\\cline{1-6}
\end{longtabu}
\hypertarget{Performance_parameter}{}\section{Performance Parameter}\label{Performance_parameter}
\subsection*{1. Steps to check communication latency}


\begin{DoxyEnumerate}
\item Communication latency measurement between two machines could be possible only when, both the machines are synchronize to same time.
\item We need to install N\+TP client on both the machines, to synchronize the time between machines.
\item Below link is used to install and configure N\+TP server. We also mentioned steps to install N\+TP server on host machine. ~\newline
 \href{http://www.ubuntugeek.com/install-and-configure-network-time-protocol-ntp-serverclients-on-ubuntu-16-04-server.html}{\tt http\+://www.\+ubuntugeek.\+com/install-\/and-\/configure-\/network-\/time-\/protocol-\/ntp-\/serverclients-\/on-\/ubuntu-\/16-\/04-\/server.\+html }
\item We also need to have a host machine which has N\+TP server installed on it. Below is the command to install N\+TP server on host. 
\begin{DoxyCode}
sudo apt-get install ntp
\end{DoxyCode}

\item On the host machine in /etc/ntp.conf file add the below line. 
\begin{DoxyCode}
restrict 192.168.0.0 mask 255.255.255.0 nomodify notrap
\end{DoxyCode}

\item Image 
\item Use the below command to start the ntp server. 
\begin{DoxyCode}
/etc/init.d/ntp start
\end{DoxyCode}

\item Add the meta-\/networking layer in bblayer.\+conf as it contains .bb file regarding N\+TP. 
\begin{DoxyCode}
bitbake-layers add-layer ../yocto-layers/meta-networking
\end{DoxyCode}

\item Add the following N\+TP image using I\+M\+A\+G\+E\+\_\+\+I\+N\+S\+T\+A\+L\+L\+\_\+append in recipe yocto-\/layers/meta-\/cm-\/use-\/case-\/avin-\/eba/recipes-\/core/image/core-\/image-\/apd-\/cm-\/use-\/case-\/avin.\+inc 
\begin{DoxyCode}
IMAGE\_INSTALL\_append += "\(\backslash\)
        .. \(\backslash\)
        .. \(\backslash\)
        ntp \(\backslash\)
        "
\end{DoxyCode}

\item Bitbake respective images. 
\begin{DoxyCode}
$ bitbake core-image-apd-left-video-provider
$ bitbake core-image-apd-video-adapter
\end{DoxyCode}

\item After bitbake, flash the image into S\+Dcard.
\begin{DoxyEnumerate}
\item We can assign static IP address to target in /etc/network/interface file. 
\begin{DoxyCode}
auto eth0
iface eth0 inet static
      address 192.168.20.53
      netmask 255.255.255.0
      network 192.168.20.0
      gateway 192.168.20.1
\end{DoxyCode}

\end{DoxyEnumerate}
\item After logged in into the board, the /etc/ntp.conf file on the board should have IP address of host machine in the below format.

For Example\+: 
\begin{DoxyCode}
$ server <ip adress of host machine>
$ fudge <ip adress of host machine> stratum 14
\end{DoxyCode}

\item Now restart the respective boards.
\item Use the below command to check whether both the machines have same time. 
\begin{DoxyCode}
date -u
\end{DoxyCode}

\end{DoxyEnumerate}

\subsection*{2. Communication Latecy (Intra and Inter)}

\subsubsection*{2.\+1 Testing Environment \+:}

{\bfseries 1. Classic Platform\+:} A\+V\+IN measured the Intra Communication Latency for Classic Platform with A\+V\+IN OS on R\+H850/\+F1H Hardware with below parameters.


\begin{DoxyItemize}
\item C\+PU Clock Frequency\+: 120 M\+Hz
\item S\+TM Clock Frequency\+: 60 M\+Hz
\end{DoxyItemize}

{\bfseries 2. Adaptive Platform \+:} A\+V\+IN measured the Intra and Inter Communication Latency with Xilinx Z\+C\+U104(Left/\+Right Video Provider) and Xilinx Z\+C\+U102(\+Video Adapter) hardware.


\begin{DoxyItemize}
\item The Communication latency for Classic and Adaptive Platform are as shown in below table(for 1000 bytes data transfer)
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Platform }&\textbf{ Inter Communication Latency(ms) }&\textbf{ Intra Communication Latency(ms)  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Platform }&\textbf{ Inter Communication Latency(ms) }&\textbf{ Intra Communication Latency(ms)  }\\\cline{1-3}
\endhead
Classic Platform &-\/ &0.\+02758 \\\cline{1-3}
Adaptive Platform &0.\+1399 &0.\+04595 \\\cline{1-3}
\end{longtabu}
