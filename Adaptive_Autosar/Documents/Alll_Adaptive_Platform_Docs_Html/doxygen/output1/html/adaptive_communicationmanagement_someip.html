<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptive Platform Demonstrator: SOME/IP(Scalable service-Oriented MiddlewarE over IP)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Platform Demonstrator
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('adaptive_communicationmanagement_someip.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SOME/IP(Scalable service-Oriented MiddlewarE over IP) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>SOME/IP is an abbreviation for "Scalable service-Oriented MiddlewarE over IP". This middleware was designed for typical automotive use cases and for being compatible with AUTOSAR. SOME/IP is an automotive/embedded communication protocol which supports remote procedure calls, event notifications and the underlying serialization/wire format.</p>
<h1>Glossary of Terms</h1>
<table class="doxtable">
<tr>
<th align="left">Term </th><th align="left">Description  </th></tr>
<tr>
<td align="left">Method </td><td align="left">A method, procedure, function, or subroutine that is called/invoked. </td></tr>
<tr>
<td align="left">Parameters </td><td align="left">input, output, or input/output arguments of a method or an event </td></tr>
<tr>
<td align="left">Remote Procedure Call (RPC) </td><td align="left">A method call from one ECU to another that is transmitted using messages </td></tr>
<tr>
<td align="left">Request </td><td align="left">a message of the client to the server invoking a method </td></tr>
<tr>
<td align="left">Response </td><td align="left">a message of the server to the client transporting results of a method invocation </td></tr>
<tr>
<td align="left">Request/Response communication </td><td align="left">a RPC that consists of request and response </td></tr>
<tr>
<td align="left">Event </td><td align="left">A uni-directional data transmission that is only invoked on changes or cyclically and is sent from the producer of data to the consumers. </td></tr>
<tr>
<td align="left">Field </td><td align="left">A field does represent a status and thus has an valid value at all times on which getter, setter and notifier act upon. </td></tr>
<tr>
<td align="left">Notification Event </td><td align="left">An event message of the notifier of a field. </td></tr>
<tr>
<td align="left">Getter </td><td align="left">A Request/Response call that allows read access to a field. </td></tr>
<tr>
<td align="left">Setter </td><td align="left">A Request/Response call that allows write access to a field. </td></tr>
<tr>
<td align="left">Notifier </td><td align="left">Sends out event message with a new value on change of the value of the field. </td></tr>
<tr>
<td align="left">Service </td><td align="left">A logical combination of zero or more methods, zero or more events, and zero or more fields. </td></tr>
<tr>
<td align="left">Service Interface </td><td align="left">the formal specification of the service including its methods, events, and fields </td></tr>
<tr>
<td align="left">Eventgroup </td><td align="left">A logical grouping of events and notification events of fields inside a service in order to allow subscription </td></tr>
<tr>
<td align="left">Service Instance </td><td align="left">Implementation of a service, which can exist more than once in the vehicle and more than once on an ECU </td></tr>
<tr>
<td align="left">Server </td><td align="left">The ECU offering a service instance is called server in the context of this service instance. </td></tr>
<tr>
<td align="left">Client </td><td align="left">The ECU using the service instance of a server is called client in the context of this service instance. </td></tr>
<tr>
<td align="left">Fire and Forget </td><td align="left">Requests without response message are called fire&amp;forget. </td></tr>
<tr>
<td align="left">Union </td><td align="left">A data structure that dynamically assumes different data types. </td></tr>
</table>
<p>The three main parts of the SOME/IP specification is as follows:</p>
<ol type="1">
<li><a class="el" href="adaptive_communicationmanagement_someip.html#on_wire_format">On-wire format</a></li>
<li><a class="el" href="adaptive_communicationmanagement_someip.html#protocol">Protocol</a></li>
<li><a class="el" href="adaptive_communicationmanagement_someip.html#service_discovery">Service Discovery(SOME/IP-SD)</a></li>
</ol>
<h1><a class="anchor" id="on_wire_format"></a>
1. On-wire format</h1>
<div class="image">
<img src="cm_someip_intro.png" alt="cm_someip_intro.png"/>
<div class="caption">
SOME/IP On wire format</div></div>
<ul>
<li>SOME/IP allows applications to communicate.</li>
<li>Packet formats are automatically determined by the specification of the Service.</li>
<li>Server offers a Service Instance that implements the Service Interface.</li>
<li>Client uses the Service Instance using SOME/IP.</li>
</ul>
<h1><a class="anchor" id="protocol"></a>
2. Protocol</h1>
<h2>2.1 SOME/IP Header Format</h2>
<div class="image">
<img src="someip_header_format.png" alt="someip_header_format.png"/>
<div class="caption">
SOME/IP Header Format</div></div>
 <h3>2.1.1 Message ID [32 Bit]</h3>
<ul>
<li>The Message ID is a 32 Bit identifier that is used to identify the RPC call to a method of an application or to identify an event.</li>
<li>Message IDs of method calls will be structured in the ID with 2^16 services with 2^15 methods as shown below. <div class="image">
<img src="messageID.png" alt="messageID.png"/>
<div class="caption">
Structure of Message ID</div></div>
</li>
</ul>
<h3>2.1.2 Length [32 Bit]</h3>
<ul>
<li>Length field contains the length in Byte starting from Request ID/Client ID until the end of the SOME/IP message.</li>
</ul>
<h3>2.1.3 Request ID [32 Bit]</h3>
<ul>
<li>The Request ID allows a provider and subscriber to differentiate multiple parallel uses of the same method, event, getter or setter.</li>
<li>The Request ID is unique for a provider- and subscriber-combination only.</li>
<li>When generating a response message, the provider copies the Request ID from the request to the response message.</li>
<li>Request ID constructed of the Client ID and Session ID as shown below. <div class="image">
<img src="requestID.png" alt="requestID.png"/>
<div class="caption">
Structure of Request ID</div></div>
</li>
<li>The Client ID is the unique identifier for the calling client inside the ECU. The Client ID allows an ECU to differentiate calls from multiple clients to the same method.</li>
<li>The Session ID is a unique identifier that allows to distinguish sequential messages. It also allows to distinguish requests originating from the same sender from each other.</li>
<li>The Client ID supports being unique in the overall vehicle by having a configurable prefix or fixed value (e.g. the most significant byte of Client ID being the diagnostics address or a configured Client ID for a given application/SW-C). <div class="image">
<img src="clientID.png" alt="clientID.png"/>
<div class="caption">
Structure of Request ID</div></div>
</li>
<li>Request/Response methods use session handling with Session IDs. Session ID should be incremented after each call.</li>
<li>When the Session ID reaches 0xFFFF, it wraps around and starts again with 0x01.</li>
<li>For request/response methods, a subscriber has to ignore a response if the Session ID of the response does not match the Session ID of the request.</li>
<li>For notification messages, a receiver ignores the Session ID in case Session Handling is not active.</li>
<li>For notification messages, a receiver treats the Session ID according to the respective use case.</li>
</ul>
<h3>2.1.4 Protocol Version [8 Bit]</h3>
<ul>
<li>The Protocol Version set to 1.</li>
</ul>
<h3>2.1.5 Interface Version [8 Bit]</h3>
<ul>
<li>Interface Version contains the Major Version of the Service Interface.</li>
</ul>
<h3>2.1.6 Message Type [8 Bit]</h3>
<ul>
<li>The Message Type field is used to differentiate different types of messages and contains the following values as shown in Table.</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">Number </th><th align="left">Value </th><th align="left">Description  </th></tr>
<tr>
<td align="left">0x00 </td><td align="left">REQUEST </td><td align="left">A request expecting a response (even void) </td></tr>
<tr>
<td align="left">0x01 </td><td align="left">REQUEST_NO_RETURN </td><td align="left">A fire&amp;forget request </td></tr>
<tr>
<td align="left">0x02 </td><td align="left">NOTIFICATION </td><td align="left">A request of a notification/event callback expecting no response </td></tr>
<tr>
<td align="left">0x80 </td><td align="left">RESPONSE </td><td align="left">The response message </td></tr>
<tr>
<td align="left">0x81 </td><td align="left">ERROR </td><td align="left">The response containing an error </td></tr>
<tr>
<td align="left">0x20 </td><td align="left">TP_REQUEST </td><td align="left">A Transport Protocol request expecting a response (even void) </td></tr>
<tr>
<td align="left">0x21 </td><td align="left">TP_REQUEST_NO_RETURN </td><td align="left">A Transport Protocol fire&amp;forget request </td></tr>
<tr>
<td align="left">0x22 </td><td align="left">TP_NOTIFICATION </td><td align="left">A Transport Protocol request of a notification/event callback expecting no response </td></tr>
<tr>
<td align="left">0x23 </td><td align="left">TP_RESPONSE </td><td align="left">The Transport Protocol response message </td></tr>
<tr>
<td align="left">0x24 </td><td align="left">TP_ERROR </td><td align="left">The Transport Protocol response containing an error </td></tr>
</table>
<ul>
<li>The 3rd highest bit of the Message Type (=0x20) is called as TP-Flag and will be set to 1 to signal that the current SOME/IP message is a segment. The other bits of the Message Type are set as specified in this Section.</li>
</ul>
<h3>2.1.7 Return Code [8 Bit]</h3>
<ul>
<li>The Return Code is used to signal whether a request was successfully processed. For simplification of the header layout, every message transports the field Return Code. The allowed Return Codes for specific message types are shown in Table.</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">Message Type </th><th align="left">Allowed Return Codes  </th></tr>
<tr>
<td align="left">REQUEST </td><td align="left">N/A set to 0x00 (E_OK) </td></tr>
<tr>
<td align="left">REQUEST_NO_RETURN </td><td align="left">N/A set to 0x00 (E_OK) </td></tr>
<tr>
<td align="left">NOTIFICATION </td><td align="left">N/A set to 0x00 (E_OK) </td></tr>
<tr>
<td align="left">RESPONSE </td><td align="left">Please refer 2.2.6.1 section </td></tr>
<tr>
<td align="left">ERROR </td><td align="left">Please refer 2.2.6.1 section </td></tr>
</table>
<h3>2.1.8 Payload [variable size]</h3>
<ul>
<li>In the payload field the parameters are carried. The serialization of the parameters will be specified in the following section.</li>
<li>The size of the SOME/IP payload field depends on the transport protocol used.</li>
<li>The UDP binding of SOME/IP can only transport SOME/IP messages that fit directly into an IP packet. Use TCP only if very large chunks of data need to be transported (&gt; 1400 Bytes) and no hard latency requirements in the case of errors exists</li>
</ul>
<h3>2.1.9 Event, Field and Eventgroup</h3>
<ul>
<li>Eventgroup is a logical grouping of events and notification events of fields inside a service in order to allow subscription.</li>
<li>Events and notifications are transported using RPC. Events will be structured as shown in Table <div class="image">
<img src="eventID.png" alt="eventID.png"/>
<div class="caption">
Structure of Event ID</div></div>
</li>
</ul>
<h3>2.1.10 Endianess</h3>
<ul>
<li>SOME/IP Header will be encoded in network byte order (big endian).</li>
<li>The byte order of the parameters inside the payload is defined by configuration.</li>
</ul>
<h3>2.1.11 Serialization of Data Structures</h3>
<ul>
<li>The serialization is based on the parameter list defined by the interface specification. The interface specification defines the exact position of all data structures in the PDU and has to consider the memory alignment.</li>
<li>Alignment is used to align the beginning of data by inserting padding elements after the data in order to ensure that the aligned data starts at certain memory addresses.</li>
</ul>
<h4>2.1.11.1 Basic Datatypes</h4>
<p>The following basic datatypes as shown in Table are supported:</p>
<table class="doxtable">
<tr>
<th align="left">Type </th><th align="left">Description </th><th align="left">Size [bit] </th><th align="left">Remark  </th></tr>
<tr>
<td align="left">boolean </td><td align="left">TRUE/FALSE value </td><td align="left">8 </td><td align="left">FALSE (0), TRUE (1) </td></tr>
<tr>
<td align="left">uint8 </td><td align="left">unsigned Integer </td><td align="left">8 </td><td align="left"></td></tr>
<tr>
<td align="left">uint16 </td><td align="left">unsigned Integer </td><td align="left">16 </td><td align="left"></td></tr>
<tr>
<td align="left">uint32 </td><td align="left">unsigned Integer </td><td align="left">32 </td><td align="left"></td></tr>
<tr>
<td align="left">sint8 </td><td align="left">signed Integer </td><td align="left">8 </td><td align="left"></td></tr>
<tr>
<td align="left">sint16 </td><td align="left">signed Integer </td><td align="left">16 </td><td align="left"></td></tr>
<tr>
<td align="left">sint32 </td><td align="left">signed Integer </td><td align="left">32 </td><td align="left"></td></tr>
<tr>
<td align="left">float32 </td><td align="left">floating point number </td><td align="left">32 </td><td align="left">IEEE 754 binary32 (Single Precision) </td></tr>
<tr>
<td align="left">float64 </td><td align="left">floating point number </td><td align="left">64 </td><td align="left">IEEE 754 binary64 (Double Precision) </td></tr>
</table>
<h4>2.1.11.2 Structured Datatypes (structs)</h4>
<ul>
<li>The serialization of a struct will be close to the in-memory layout. This means, only the parameters will be serialized sequentially into the buffer. Especially for structs it is important to consider the correct memory alignment. <div class="image">
<img src="serialization_of_structs.png" alt="serialization_of_structs.png"/>
<div class="caption">
Serialization of Structs</div></div>
</li>
</ul>
<h4>2.1.11.3 Strings</h4>
<ul>
<li>All strings always starts with a Byte Order Mark (BOM).<ul>
<li>BOM : The byte order mark (BOM) is a Unicode character, U+FEFF byte order mark (BOM), whose appearance as a magic number at the start of a text stream can signal several things (eg. endianness) to a program consuming the text</li>
</ul>
</li>
<li>The BOM will be included in fixed-length-strings as well as dynamic-length strings.</li>
<li>BOM allows the possibility to detect the used encoding.</li>
</ul>
<h4>2.1.11.4 Arrays (fixed length)</h4>
<ul>
<li>The length of fixed length arrays is defined by the data type definition. They can be seen as repeated elements.Fixed length arrays are easier for use in very small devices. Dynamic length arrays might need more resources on the ECU using them.</li>
</ul>
<h5>2.1.11.4.1 One-dimensional</h5>
<ul>
<li>The one-dimensional arrays with fixed length "n" will carry exactly "n" elements of the same type. <div class="image">
<img src="one_dimension_array_fixedlength.png" alt="one_dimension_array_fixedlength.png"/>
<div class="caption">
One-dimensional array (fixed length)</div></div>
</li>
</ul>
<h5>2.1.11.4.2 Multidimensional</h5>
<ul>
<li>The serialization of multidimensional arrays follows the in-memory layout of multidimensional arrays in the programming language (row-major order) and is shown in Figure below. <div class="image">
<img src="multi_dimension_array_fixedlength.png" alt="multi_dimension_array_fixedlength.png"/>
<div class="caption">
Multidimensional array (fixed length)</div></div>
</li>
</ul>
<h4>2.1.11.5 Dynamic Length Arrays</h4>
<ul>
<li>The layout of arrays with dynamic length will be based on the layout of fixed length arrays.</li>
<li>An optional length field at the beginning of an array should be used to specify the length of the array in Bytes.</li>
</ul>
<h5>2.1.11.5.1 One-dimensional</h5>
<div class="image">
<img src="one_dimension_array_dynamiclength.png" alt="one_dimension_array_dynamiclength.png"/>
<div class="caption">
One-dimensional array (dynamic length)</div></div>
<ul>
<li>In the one-dimensional array one length field is used, which carries the number of bytes used for the array.</li>
</ul>
<h5>2.1.11.5.2 Multidimensional</h5>
<div class="image">
<img src="multi_dimension_array_dynamiclength.png" alt="multi_dimension_array_dynamiclength.png"/>
<div class="caption">
Multidimensional array (dynamic length)</div></div>
<ul>
<li>In multidimensional arrays every sub array of different dimensions will have its own length field.</li>
</ul>
<h4>2.1.11.6 Enumeration</h4>
<ul>
<li>Enumerations are not considered in SOME/IP. Enumerations are transmitted as unsigned integer datatypes.</li>
</ul>
<h4>2.1.11.7 Bitfield</h4>
<ul>
<li>Bitfields are transported as unsigned datatypes uint8/uint16/uint32.</li>
</ul>
<h4>2.1.11.8 Union / Variant</h4>
<ul>
<li>A union (also called variant) is such a parameter that can contain different types of data. For example, if one defines a union of type uint8 and type uint16, the union will carry data which are a uint8 or a uint16.</li>
<li>Which data type will be transmitted in the payload can only be decided during execution. In this case, however, it is necessary to not only send the data itself but add an information about the applicable data type as a form of "meta-data" to the transmission.By the means of the attached meta-data the sender can identify the applicable data type of the union and the receiver can accordingly access the data properly.</li>
<li>A union consists of a length field, type selector and the payload as shown Table below. <div class="image">
<img src="default_serialization_unions.png" alt="default_serialization_unions.png"/>
<div class="caption">
Default Serialization of Unions</div></div>
</li>
<li>The length field defines the size of the data and padding in bytes and does not include the size of the length field and type field.</li>
<li>The type field specifies the data type of the data.</li>
</ul>
<h2>2.2 SOME/IP Protocol specification</h2>
<p>This section describes the Remote Procedure Call(RPC), Event Notifications and Error Handling of SOME/IP.</p>
<h3>2.2.1 Transport Protocol Bindings</h3>
<ul>
<li>In order to transport SOME/IP messages different transport protocols may be used. SOME/IP currently supports UDP and TCP.</li>
<li>If a server runs different instances of the same service, messages belonging to different service instances will be mapped to the service instance by the transport protocol port on the server side.</li>
<li>All Transport Protocol Bindings supports transporting more than one SOME/IP message in a Transport Layer PDU (i.e. UDP packet or TCP segment).</li>
</ul>
<h4>2.2.1.1 UDP Binding</h4>
<ul>
<li>The UDP binding of SOME/IP will be achieved by transporting SOME/IP messages in UDP packets.</li>
<li>The header format allows transporting more than one SOME/IP message in a single UDP packet. The SOME/IP implementation identifies the end of a SOME/IP message by means of the SOME/IP length field. Based on the UDP length field, SOME/IP determines if there are additional SOME/IP messages in the UDP packet.</li>
</ul>
<h4>2.2.1.2 TCP Binding</h4>
<ul>
<li>The TCP binding of SOME/IP is based on the UDP binding. In contrast to the UDP binding, the TCP binding allows much bigger SOME/IP messages and uses the robustness features of TCP (coping with loss, reorder, duplication, etc.).</li>
<li>When the TCP connection is lost, outstanding requests will be handled as timeouts. Since TCP handles reliability, additional means of reliability are not needed.</li>
<li>The client and server uses a single TCP connection for all methods, events, and notifications of a service instance. When having more than one instance of a service a TCP connection per services instance is needed.</li>
<li>The TCP connection will be opened by the client, when the first method call will be transported or the client tries to receive the first notifications. The client is responsible for re-establishing the TCP connection whenever it fails.</li>
<li>The TCP connection will be closed by the client, when the TCP connection is not required anymore.</li>
<li>The TCP connection will be closed by the client, when all Services using the TCP connections are not available anymore (stopped or timed out).</li>
<li>The server will not stop the TCP connection when stopping all services. Give the client enough time to process the control data to shutdown the TCP connection itself.</li>
</ul>
<h4>2.2.1.3 Multiple Service-Instances</h4>
<ul>
<li>Service-Instances of the same Service are identified through different Instance IDs. SOME/IP supports multiple Service-Instances reside on different ECUs as well as multiple Service-Instances of one or more Services reside on one single ECU.</li>
<li>While different Services will be able to share the same port number of the transport layer protocol used, multiple Service-Instances of the same service on one single ECU listens on different ports per Service-Instance.</li>
<li>A Service Instance can be identified through the combination of the Service ID combined with the socket (i.e. IP-address, transport protocol (UDP/TCP), and port number).</li>
</ul>
<h4>2.2.1.4 Transporting large SOME/IP messages of UDP (SOME/IP-TP)</h4>
<ul>
<li>The UDP binding of SOME/IP can only transport SOME/IP messages that fit directly into an IP packet. If larger SOME/IP messages need to be transported over UDP (e.g. of 32 KB) the SOME/IP Transport Protocol (SOME/IP-TP) will be used. The SOME/IP message too big to be transported directly with the UDP binding will be called "original" SOME/IP message. The "pieces" of the original SOME/IP message payload transported in SOME/IP-TP messages will be called "segments".</li>
<li>SOME/IP messages using SOME/IP-TP activates Session Handling (Session ID must be unique for the original message).</li>
<li>All SOME/IP-TP segments carry the Session ID of the original message; thus, they have all the same Session-ID.</li>
<li>SOME/IP-TP segments will have the TP-Flag of the Message Type set to 1.</li>
<li><p class="startli">SOME-IP-TP-Header is as shown in below. SOME/IP-TP segments will have a TP header right after the SOME/IP header (i.e. before the SOME/IP payload) with the following structure (bits from highest to lowest):</p>
<p class="startli"><b>a. Offset [28 bits]</b></p>
<p class="startli"><b>b. Reserved Flag [1 bit]</b></p>
<p class="startli"><b>c. Reserved Flag [1 bit]</b></p>
<p class="startli"><b>d. Reserved Flag [1 bit]</b></p>
<p class="startli"><b>e. More Segments Flag [1 bit]</b></p>
</li>
</ul>
<div class="image">
<img src="someip_tp_header.png" alt="someip_tp_header.png"/>
<div class="caption">
SOME/IP TP header</div></div>
 <h4>2.2.1.4.1 Example</h4>
<ul>
<li>This example describes how an original SOME/IP message of 5880 bytes payload has to be transmitted. The Length field of this original SOME/IP message is set to 8 + 5880 bytes. <div class="image">
<img src="example_header.png" alt="example_header.png"/>
<div class="caption">
Example: Header of Original SOME/IP message</div></div>
</li>
<li>This original SOME/IP message will now be segmented into 5 consecutive SOME/IP segments. Every payload of these segments carries at most 1392 bytes in this example.</li>
<li>For these segments, the SOME/IP TP module adds additional TP fields. The Length field of the SOME/IP carries the overall length of the SOME/IP segment including 8 bytes for the Request ID, Protocol Version, Interface Version, Message Type and Return Code. Because of the added TP fields (4 bytes), this Length information is extended by 4 additional SOME/IP TP bytes.</li>
<li>The following figure provides an overview of the relevant SOME/IP header settings for every SOME/IP segment: <div class="image">
<img src="someiptp.png" alt="someiptp.png"/>
<div class="caption">
Example: Overview of relevant SOME/IP TP headers</div></div>
</li>
<li>Please note that the value provided within the Offset Field is given in units of 16 bytes, i.e.: The Offset Value of 87 correspond to 1392 bytes Payload.</li>
<li>The first 4 segments contain 1392 Payload bytes each with "More Segments Flag" set to ’1’: <div class="image">
<img src="someipsegment.png" alt="someipsegment.png"/>
<div class="caption">
Example: Header of the SOME/IP segments</div></div>
</li>
<li>The last segment (i.e. 5) contains the remaining 312 Payload bytes of the original 5880 bytes payload. This last segment is marked with "More Segments flag" set to ’0’. <div class="image">
<img src="someiptplastsegmen.png" alt="someiptplastsegmen.png"/>
<div class="caption">
Example: Header of the SOME/IP segments</div></div>
</li>
</ul>
<h3>2.2.2 Request/Response Communication</h3>
<ul>
<li>One of the most common communication patterns is the request/response pattern. One communication partner (Client) sends a request message, which is answered by another communication partner (Server). <div class="image">
<img src="request_response.png" alt="request_response.png"/>
</div>
</li>
<li>For the SOME/IP request message the client has to do the following for payload and header:<ul>
<li>Construct the payload</li>
<li>Set the Message ID based on the method the client wants to call</li>
<li>Set the Length field to 8 bytes (for the part of the SOME/IP header after the length field) + length of the serialized payload</li>
<li>Optionally set the Request ID to a unique number (unique for client only)</li>
<li>Set the Protocol Version according</li>
<li>Set the Interface Version according to the interface definition</li>
<li>Set the Message Type to REQUEST (i.e. 0x00)</li>
<li>Set the Return Code to 0x00</li>
</ul>
</li>
<li>The server builds the header of the response based on the header of the client’s request and does in addition:<ul>
<li>Construct the payload</li>
<li>Take over the Message ID from the corresponding request</li>
<li>Set the length to the 8 Bytes + new payload size</li>
<li>Take over the Request ID from the corresponding request</li>
<li>Set the Message Type to RESPONSE (i.e. 0x80) or ERROR (i.e. 0x81)</li>
<li>Set Return Code to the return code of called method or in case of an Error message to a valid error code</li>
</ul>
</li>
</ul>
<h3>2.2.3 Fire&amp;Forget Communication</h3>
<ul>
<li>Requests without response message are called fire&amp;forget. <div class="image">
<img src="fire_forgot.png" alt="fire_forgot.png"/>
</div>
</li>
<li>For the SOME/IP request-no-return message the client has to do the following for payload and header:<ul>
<li>Construct the payload</li>
<li>Set the Message ID based on the method the client wants to call</li>
<li>Set the Length field to 8 bytes (for the part of the SOME/IP header after the length field) + length of the serialized payload</li>
<li>Optionally set the Request ID to a unique number (unique for client only)</li>
<li>Set the Protocol Version according</li>
<li>Set the Interface Version according to the interface definition</li>
<li>Set the Message Type to REQUEST_NO_RETURN (i.e. 0x01)</li>
<li>Set the Return Code to 0x00</li>
</ul>
</li>
</ul>
<h3>2.2.4 Notification Events</h3>
<ul>
<li>Notifications describe a general Publish/Subscribe-Concept. Usually the server publishes a service to which a client subscribes. On certain cases the server will send the client an event, which could be for example an updated value or an event that occurred. <div class="image">
<img src="events.png" alt="events.png"/>
</div>
</li>
<li>SOME/IP is used only for transporting the updated value and not for the publishing and subscription mechanisms. These mechanisms are implemented by SOME/IP-SD.</li>
<li>For the SOME/IP notification message the client has to do the following for payload and header:<ul>
<li>Construct the payload</li>
<li>Set the Message ID based on the event the server wants to send</li>
<li>Set the Length field to 8 bytes (for the part of the SOME/IP header after the length field) + length of the serialized payload</li>
<li>Set the Client ID to 0x00. In case of active Session Handling the Session ID will be incremented upon each transmission.</li>
<li>Set the Protocol Version according</li>
<li>Set the Interface Version according to the interface definition</li>
<li>Set the Message Type to NOTIFICATION (i.e. 0x02)</li>
<li>Set the Return Code to 0x00</li>
</ul>
</li>
</ul>
<h4>2.2.4.1 Strategy for sending notifications</h4>
<ul>
<li><p class="startli">For different use cases different strategies for sending notifications are possible. The following examples are common:</p>
<p class="startli"><b>a. Cyclic update</b> — send an updated value in a fixed interval (e.g. every 100 ms for safety relevant messages with Alive)</p>
<p class="startli"><b>b. Update on change</b> — send an update as soon as a "value" changes (e.g. door open)</p>
<p class="startli"><b>c. Epsilon change</b> — only send an update when the difference to the last value is greater than a certain epsilon. This concept may be adaptive, i.e. the prediction is based on a history; thus, only when the difference between prediction and current value is greater than epsilon an update is transmitted.</p>
</li>
</ul>
<h3>2.2.5 Fields</h3>
<ul>
<li>A field represents a status and has a valid value. The consumers subscribing for the field instantly after subscription get the field value as an initial event. <div class="image">
<img src="field.png" alt="field.png"/>
</div>
</li>
<li>A field is a combination of getter, setter and notification event.</li>
<li>The getter of a field is a request/response call that has an empty payload in the request message and the value of the field in the payload of the response message.</li>
<li>The setter of a field is a request/response call that has the desired value of the field in the payload of the request message and the value that was set to the field in the payload of the response message.</li>
<li>The notifier sends an event message that transports the value of the field to the client when the client subscribes to the field.</li>
</ul>
<h3>2.2.6 Error Handling</h3>
<ul>
<li>Error handling can be done in the application or the communication layer below. Therefore SOME/IP supports two different mechanisms explained below:</li>
</ul>
<h4>2.2.6.1 Error Handling Return Codes in the Response Messages of methods</h4>
<ul>
<li>Return Codes in the Response Messages of methods is used to transport application errors and the response data of a method from the provider to the caller of a method.</li>
</ul>
<div class="image">
<img src="return_codes.png" alt="return_codes.png"/>
<div class="caption">
Return Codes</div></div>
<h4>2.2.6.2 Explicit Error Messages</h4>
<ul>
<li>Explicit Error Messages are used to transport application errors and the response data or generic SOME/IP errors from the provider to the caller of a method.</li>
<li>If more detailed error information need to be transmitted, the payload of the Error Message (Message Type 0x81) will be filled with error specific data, e.g. an exception string. Error Messages will be sent instead of Response Messages.</li>
<li>This can be used to handle all different application errors that might occur in the server. In addition, problems with the communication medium or intermediate components (e.g. switches) may occur, which have to be handled e.g. by means of reliable transport.</li>
<li>For more flexible error handling, SOME/IP allows a different message layout specific for Error Messages instead of using the message layout of Response Messages. The recommended layout for the exception message is the following: a. Union of specific exceptions. At least a generic exception without fields needs to exist. b. Dynamic Length String for exception description.</li>
<li>The union gives the flexibility to add new exceptions in the future in a typesafe manner. The string is used to transport human readable exception descriptions to ease testing and debugging.</li>
</ul>
<h4>2.2.6.3 Error Processing Overview</h4>
<p>Error handling is based on the message type received (e.g. only methods can be answered with a return code) and will be checked in a defined order shown below.</p>
<div class="image">
<img src="error_handling.png" alt="error_handling.png"/>
<div class="caption">
Message Validation and Error Handling in SOME/IP</div></div>
 <h1><a class="anchor" id="service_discovery"></a>
3. Service Discovery(SOME/IP-SD)</h1>
<ul>
<li>SOME/IP-SD is used to<ul>
<li>Locate service instances.</li>
<li>Detect if service instances are running.</li>
<li>Implement the Publish/Subscribe handling.</li>
</ul>
</li>
<li>SOME/IP-SD depends on SOME/IP. SOME/IP itself supports both TCP and UDP communications but SOME/IP SD uses SOME/IP only over UDP</li>
</ul>
<div class="image">
<img src="dependancy_someipsd.png" alt="dependancy_someipsd.png"/>
<div class="caption">
SOME/IP-SD Dependencies to other protocol layers</div></div>
 <h2>3.1 SOME/IP-SD Message Format</h2>
<div class="image">
<img src="someipsd_header.png" alt="someipsd_header.png"/>
<div class="caption">
SOME/IP-SD Header Format</div></div>
<p>We can divide the above mention figure into two parts.</p>
<h3>3.1.1 SOME/IP header</h3>
<table class="doxtable">
<tr>
<th align="left">Field() </th><th align="left">Description(Default Value)  </th></tr>
<tr>
<td align="left">Service-ID(16 bits) </td><td align="left">0xFFFF </td></tr>
<tr>
<td align="left">Method-ID(16 bits) </td><td align="left">0x8100 </td></tr>
<tr>
<td align="left">length(32 bits) </td><td align="left">length is measured in bytes and starts with the first byte after the length field and ends with the last byte of the SOME/IP-SD message. </td></tr>
<tr>
<td align="left">Client-ID(16 bits) </td><td align="left">Set to 0x0000 </td></tr>
<tr>
<td align="left">Session-ID (16 Bits) </td><td align="left">The Session-ID (SOME/IP header) will be incremented for every SOME/IP-SD message sent.The Session-ID (SOME/IP header) starts with 1 and be 1 even after wrapping. </td></tr>
<tr>
<td align="left">Protocol- Version (8 Bits) </td><td align="left">0x01 </td></tr>
<tr>
<td align="left">Interface- Version (8 Bits) </td><td align="left">0x01 </td></tr>
<tr>
<td align="left">Message Type (8 bits) </td><td align="left">0x02 (Notification) </td></tr>
<tr>
<td align="left">Return Code(8 bits) </td><td align="left">Return Code(8 bits) </td></tr>
</table>
<h3>3.1.2 SOME/IP-SD Header</h3>
<div class="image">
<img src="someip_sd_pdu.png" alt="someip_sd_pdu.png"/>
<div class="caption">
SOME/IP-SD Example PDU</div></div>
<ul>
<li>The SOME/IP-SD Header starts with an 8 Bit field called Flags as shown in the Figure below. <div class="image">
<img src="someipsd_flags.png" alt="someipsd_flags.png"/>
<div class="caption">
Flags in SOME/IP-SD</div></div>
</li>
<li>The Reboot Flag of the SOME/IP-SD Header is set to 1 for all messages after reboot until the Session-ID in the SOME/IP-Header wraps around and thus starts with 1 again. After this wrap around the Reboot Flag is set to 0.</li>
<li>The information for the reboot flag and the Session ID will be kept for multicast, unicast and every sender-receiver relation (i.e. source address and destination address) separately.</li>
<li>This means there will be separate counters for sending and receiving.</li>
<li><b>Sending</b><ul>
<li>There will be a counter for multicast.</li>
<li>There will be a separate counter for each peer for unicast.</li>
</ul>
</li>
<li><b>Receiving</b><ul>
<li>There will be a counter for each peer for multicast.</li>
<li>There will be a counter for each peer for unicast.</li>
</ul>
</li>
<li>The Unicast Flag of the SOME/IP-SD Header is set to Unicast (that means 1) for all SD Messages since this means that receiving using unicast is supported.</li>
<li>The third flag of the SOME/IP-SD Flags (third highest order bit) will be called Explicit Initial Data Control Flag and means that the ECU supports explicit initial data control.</li>
<li>After the SOME/IP-SD Header the Entries Array follows. The entries will be processed exactly in the order they arrive.</li>
<li>After the Entries Array in the SOME/IP-SD Header an Option Array will follow.</li>
</ul>
<h4>3.1.2.1 Entry Format</h4>
<ul>
<li>The service discovery supports multiple entries that are combined in one service discovery message. The entries are used to synchronize the state of services instances and the Publish/Subscribe handling.</li>
<li>Two types of entries exist: A Service Entry Type for Services and an Eventgroup Entry Type for Eventgroups.</li>
</ul>
<h5>3.1.2.1.1 Service Entry Type for Services</h5>
<div class="image">
<img src="someip_sd_serviceentry.png" alt="someip_sd_serviceentry.png"/>
<div class="caption">
SOME/IP-SD Service Entry Type</div></div>
<ul>
<li>Type Field [uint8]: encodes FindService (0x00) and OfferService (0x01).</li>
<li>Index First Option Run [uint8]: Index of this runs first option in the option array.</li>
<li>Index Second Option Run [uint8]: Index of this runs second option in the option array.</li>
<li>Number of Options 1 [uint4]: Describes the number of options the first option run uses.</li>
<li>Number of Options 2 [uint4]: Describes the number of options the second option run uses.</li>
<li>Service-ID [uint16]: Describes the Service ID of the Service or Service-Instance this entry is concerned with.</li>
<li>Instance ID [uint16]: Describes the Service Instance ID of the Service Instance this entry is concerned with or is set to 0xFFFF if all service instances of a service are meant.</li>
<li>Major Version [uint8]: Encodes the major version of the service (instance).</li>
<li>TTL [uint24]: Describes the lifetime of the entry in seconds.</li>
<li>Minor Version [uint32]: Encodes the minor version of the service.</li>
</ul>
<h5>3.1.2.1.2 Eventgroup Entry Type for Eventgroups</h5>
<div class="image">
<img src="someip_sd_eventgroupentry.png" alt="someip_sd_eventgroupentry.png"/>
<div class="caption">
SOME/IP-SD Eventgroup Entry Type</div></div>
<ul>
<li>Type Field [uint8]: encodes Subscribe (0x06), and SubscribeAck (0x07).</li>
<li>Index First Option Run [uint8]: Index of this runs first option in the option array.</li>
<li>Index Second Option Run [uint8]: Index of this runs second option in the option array.</li>
<li>Number of Options 1 [uint4]: Describes the number of options the first option run uses.</li>
<li>Number of Options 2 [uint4]: Describes the number of options the second option run uses.</li>
<li>Service-ID [uint16]: Describes the Service ID of the Service or Service Instance this entry is concerned with.</li>
<li>Instance ID [uint16]: Describes the Service Instance ID of the Service Instance this entry is concerned with or is set to 0xFFFF if all service instances of a service are meant.</li>
<li>Major Version [uint8]: Encodes the major version of the service instance this eventgroup is part of.</li>
<li>TTL [uint24]: Descibes the lifetime of the entry in seconds.</li>
<li>Reserved [uint8]: Set to 0x00.</li>
<li>Initial Data Requested Flag [1 bit] (I Flag): Set to 1, if initial data will sent by Server</li>
<li>Reserved2 [uint3]: Set to 0x0.</li>
<li>Counter [uint4]: Is used to differentiate identical Subscribe Eventgroups of the same subscriber. Set to 0x0 if not used.</li>
<li>Eventgroup ID [uint16]: Transports the ID of an Eventgroup.</li>
</ul>
<h5>3.1.2.1.3 Referencing Options from Entries</h5>
<ul>
<li>Index First Option Run: Index into array of options for first option run. Index 0 means first of SOME/IP-SD packet.</li>
<li>Index Second Option Run: Index into array of options for second option run. Index 0 means first of SOME/IP-SD packet.</li>
<li>Number of Options 1: Length of first option run. Length 0 means no option in option run.</li>
<li>Number of Options 2: Length of second option run. Length 0 means no option in option run.</li>
<li>Two different option runs exist: First Option Run and Second Option Run. Two different types of options are expected: options common between multiple SOME/IP-SD entries and options different for each SOME/IP-SD entry. Supporting to different options runs is the most efficient way to support these two types of options, while keeping the wire format highly efficient.</li>
<li>Each option run will reference the first option and the number of options for this run.</li>
<li>If the number of options is set to zero, the option run is considered empty.</li>
<li>For empty runs the Index (i.e. Index First Option Run and/or Index Second Option Run) will set to zero.</li>
</ul>
<h4>3.1.2.2 Options Format</h4>
<ul>
<li>Options are used to transport additional information to the entries. This includes for instance the information how a service instance is reachable (IP-Address, Transport Protocol, Port Number).</li>
<li>In order to identify the option type every option starts with:<ul>
<li>Length [uint16]: Specifies the length of the option in Bytes.</li>
<li>Type [uint8]: Specifying the type of the option.</li>
</ul>
</li>
<li>The length field covers all bytes of the option except the length field and type field.</li>
</ul>
<h5>3.1.2.2.1 Configuration Option</h5>
<ul>
<li>The configuration option is used to transport arbitrary configuration strings. This allows to encode additional information like the name of a service or its configuration. <div class="image">
<img src="SOMEIPSDConfigurationOption.png" alt="SOMEIPSDConfigurationOption.png"/>
<div class="caption">
SOME/IP-SD Configuration Option</div></div>
</li>
</ul>
<h5>3.1.2.2.2 Load Balancing Option</h5>
<ul>
<li>The Load Balancing option is used to prioritize different instances of a service, so that a client chooses the service instance based on these settings. This option will be attached to Offer Service entries.</li>
<li>The Load Balancing Option carry a Priority and Weight, which is used for load balancing different service instances. <div class="image">
<img src="SOMEIPSDLoadBalancingOption.png" alt="SOMEIPSDLoadBalancingOption.png"/>
<div class="caption">
SOME/IP-SD Load Balancing Option</div></div>
</li>
</ul>
<h5>3.1.2.2.3 IPv4 Endpoint Option</h5>
<ul>
<li>The IPv4 Endpoint Option is used by a SOME/IP-SD instance to signal the relevant endpoint(s).</li>
<li>Endpoints include the local IP address, the transport layer protocol (e.g. UDP or TCP), and the port number of the sender.</li>
<li>These ports are used for the events and notification events as well. <div class="image">
<img src="SOMEIPSDIPv4EndpointOption.png" alt="SOMEIPSDIPv4EndpointOption.png"/>
<div class="caption">
SOME/IP-SD IPv4 Endpoint Option</div></div>
</li>
<li>This option is used by the server for its OfferService entry and by client for Subscribe Eventgroup entry.</li>
</ul>
<h5>3.1.2.2.4 IPv6 Endpoint Option</h5>
<ul>
<li>The IPv6 Endpoint Option is used by a SOME/IP-SD instance to signal the relevant endpoint(s).</li>
<li>Endpoints include the local IP address, the transport layer protocol (e.g. UDP or TCP), and the port number of the sender.</li>
<li>ports are used for the events and notification events as well.</li>
<li>This option is used by the server for its OfferService entry and by client for Subscribe Eventgroup entry. <div class="image">
<img src="SOMEIPSDIPv6EndpointOption.png" alt="SOMEIPSDIPv6EndpointOption.png"/>
<div class="caption">
SOME/IP-SD IPv6 Endpoint Option</div></div>
</li>
</ul>
<h5>3.1.2.2.5 IPv4 Multicast Option</h5>
<ul>
<li>The IPv4 Multicast Option is used by the server to announce the IPv4 multicast address, the transport layer protocol (ISO/OSI layer 4), and the port number the multicast events and multicast notification events are sent to.</li>
<li>As transport layer protocol currently only UDP is supported.</li>
<li>The IPv4 Multicast Option is referenced by Subscribe Eventgroup Ack entries.</li>
<li>The server reference the IPv4 Multicast Option, which encodes the IPv4 Multicast Address and Port Number the server will send multicast events and notification events to. <div class="image">
<img src="SOMEIPSDIPv4MulticastOption.png" alt="SOMEIPSDIPv4MulticastOption.png"/>
<div class="caption">
SOME/IP-SD IPv4 Multicast Option</div></div>
</li>
</ul>
<h5>3.1.2.2.6 IPv6 Multicast Option</h5>
<ul>
<li>The IPv6 Multicast Option is used by the server to announce the IPv6 multicast address, the layer 4 protocol, and the port number the multicast events and multicast notifications events are sent to.</li>
<li>For the transport layer protocol (ISO/OSI layer 4) currently only UDP is supported.</li>
<li>The IPv6 Multicast Option, referenced by Subscribe Eventgroup Ack messages.</li>
<li>The server references the IPv6 Multicast Option, which encodes the IPv6 Multicast Address and Port Number the server will send multicast events and notification events to. <div class="image">
<img src="SOMEIPSDIPv6MulticastOption.png" alt="SOMEIPSDIPv6MulticastOption.png"/>
<div class="caption">
SOME/IP-SD IPv6 Multicast Option</div></div>
</li>
</ul>
<h5>3.1.2.2.7 IPv4 SD Endpoint Option</h5>
<ul>
<li>The IPv4 SD Endpoint Option is used to transport the endpoint (i.e. IP-Address and Port) of the senders SD implementation.</li>
<li>This is used to identify the SOME/IP-SD Instance even in cases in which the IP-Address and/or Port Number cannot be used.</li>
<li>A use case would be a proxy service discovery on one ECU which handles the multicast traffic for another ECU. <div class="image">
<img src="SOMEIPSDIPv4SDEndpointOption.png" alt="SOMEIPSDIPv4SDEndpointOption.png"/>
<div class="caption">
SOME/IP-SD IPv4 SD Endpoint Option</div></div>
</li>
</ul>
<h5>3.1.2.2.8 IPv6 SD Endpoint Option</h5>
<ul>
<li>The Ipv6 SD Endpoint Option is used to transport the endpoint (i.e. IP-Address and Port) of the senders SD implementation.</li>
<li>This is used to identify the SOME/IP-SD Instance even in cases in which the IP-Address and/or Port Number cannot be used.</li>
<li>A use case would be a proxy service discovery on one ECU which handles the multicast traffic for another ECU. <div class="image">
<img src="SOMEIPSDIPv6SDEndpointOption.png" alt="SOMEIPSDIPv6SDEndpointOption.png"/>
<div class="caption">
SOME/IP-SD IPv6 SD Endpoint Option</div></div>
</li>
<li>Example:Below Figure shows an example with the different Endpoint and a Multicast Option:</li>
<li>The Server offers the Service Instance on Server UDP-Endpoint SU and Server TCP-Endpoint ST</li>
<li>The Client sends a Subscribe Eventgroup entry with Client UDP-Endpoint CU (unicast) and a Client TCP-Endpoint CT. <div class="image">
<img src="Endpoints.png" alt="Endpoints.png"/>
<div class="caption">
Publish/Subscribe Example for Endpoint Options and the usage of ports</div></div>
</li>
</ul>
<h3>3.1.3 Service Entries</h3>
<h4>3.1.3.1 Find Service Entry</h4>
<ul>
<li>The Find Service entry type is used for finding service instances and will only be sent if the current state of a service is unknown.(no current Service Offer was received and is still valid).</li>
<li>Find Service entries sets the entry fields in the following way: <table class="doxtable">
<tr>
<th align="left">Field </th><th align="left">Description(Default Value)  </th></tr>
<tr>
<td align="left">Type </td><td align="left">0x00 (FindService) </td></tr>
<tr>
<td align="left">Service ID </td><td align="left">Set to the Service ID of the service </td></tr>
<tr>
<td align="left">Instance ID </td><td align="left">0xFFFF(all service instances) or Instance ID of a specific service instance </td></tr>
<tr>
<td align="left">Major Version </td><td align="left">0xFF </td></tr>
<tr>
<td align="left">Minor Version </td><td align="left">0xFFFFFFFF(services with any version will be returned) or set to a value different to 0xFFFF FFFF, services with this specific minor version will be returned only </td></tr>
<tr>
<td align="left">TTL </td><td align="left">Set to the lifetime of the Find Service entry. After this lifetime the Find Service entry is considered not existing. If TTL is set to 0xFFFFFF, the Find Service entry is considered valid until the next reboot. TTL will not be set to 0x000000 since this is considered to be the Stop Find Service Entry. </td></tr>
</table>
</li>
<li>Find the wireshark output for FindService service below.</li>
<li>Consider IP address 192.168.7.4 for consumer application, 192.168.7.2 for producer application and 224.244.224.245 as a multicast address.</li>
</ul>
<div class="image">
<img src="FindService_Wireshark.png" alt="FindService_Wireshark.png"/>
<div class="caption">
Wireshark output for FindService()</div></div>
 <h4>3.1.3.2 Offer Service Entry</h4>
<ul>
<li>The Offer Service entry type is used to offer a service to other communication partners.</li>
<li>Offer Service entries sets the entry fields in the following way: <table class="doxtable">
<tr>
<th align="left">Field </th><th align="left">Description(Default Value)  </th></tr>
<tr>
<td align="left">Type </td><td align="left">0x01 (OfferService) </td></tr>
<tr>
<td align="left">Service ID </td><td align="left">Set to the Service ID of the service instance offered. </td></tr>
<tr>
<td align="left">Instance ID </td><td align="left">Set to the Instance ID of the service instance that is offered </td></tr>
<tr>
<td align="left">Major Version </td><td align="left">Set to the Major Version of the service instance that is offered. </td></tr>
<tr>
<td align="left">Minor Version </td><td align="left">Set to the Minor Version of the service instance that is offered. </td></tr>
<tr>
<td align="left">TTL </td><td align="left">Set to the lifetime of the Offer Service entry. After this lifetime the Offer Service entry is considered not existing. If TTL is set to 0xFFFFFF, the Offer Service entry will be considered valid until the next reboot. TTL will not be set to 0x000000 since this is considered to be the Stop Offer Service Entry. </td></tr>
</table>
</li>
<li>Find the wireshark output for OfferService service below.</li>
<li>Consider IP address 192.168.7.4 for consumer application, 192.168.7.2 for producer application and 224.244.224.245 as a multicast address.</li>
</ul>
<div class="image">
<img src="OfferService_Wireshark.png" alt="OfferService_Wireshark.png"/>
<div class="caption">
Wireshark output for OfferService()</div></div>
 <h3>3.1.4 Eventgroup Entry</h3>
<h4>3.1.4.1 Subscribe Eventgroup Entry</h4>
<ul>
<li>The Subscribe Eventgroup entry type is used to subscribe to an eventgroup. <table class="doxtable">
<tr>
<th align="left">Field </th><th align="left">Description(Default Value)  </th></tr>
<tr>
<td align="left">Type </td><td align="left">0x06 (SubscribeEventgroup) </td></tr>
<tr>
<td align="left">Service ID </td><td align="left">set to the Service ID of the service instance that includes the eventgroup subscribed to. </td></tr>
<tr>
<td align="left">Instance ID </td><td align="left">set to the Instance ID of the service instance that includes the eventgroup subscribed to. </td></tr>
<tr>
<td align="left">Major Version </td><td align="left">set to the Major Version of the service instance of the eventgroup subscribed to. </td></tr>
<tr>
<td align="left">Eventgroup ID </td><td align="left">set to the Eventgroup ID of the eventgroup subscribed to. </td></tr>
<tr>
<td align="left">Minor Version </td><td align="left">set to the Minor Version of the service instance of the eventgroup subscribed to. </td></tr>
<tr>
<td align="left">TTL </td><td align="left">If set to 0xFFFFFF, the Subscribe Eventgroup entry considered as valid until the next reboot. TTL will not be set to 0x000000 since this is considered to be the Stop </td></tr>
<tr>
<td align="left">Reserved </td><td align="left">set to 0x00 </td></tr>
<tr>
<td align="left">Initial Data Requested Flag </td><td align="left">set to 1, if the client sends the first subscribe in sequence to trigger the sending of initial events. Set to 0 otherwise </td></tr>
<tr>
<td align="left">Reserved2 </td><td align="left">set to three 0 bits </td></tr>
<tr>
<td align="left">Counter </td><td align="left">used to differentiate between parallel subscribes to the same eventgroup of the same service (only difference in endpoint). If not used, set to 0x0. </td></tr>
</table>
<div class="image">
<img src="SubscribeEG_Wireshark.png" alt="SubscribeEG_Wireshark.png"/>
<div class="caption">
Wireshark output for SubscribeEventgroup()</div></div>
</li>
</ul>
<h4>3.1.4.2 Subscribe Eventgroup Acknowledgement (Subscribe Eventgroup Ack) Entry</h4>
<ul>
<li>The Subscribe Eventgroup Acknowledgment entry type is used to indicate that Subscribe Eventgroup entry was accepted.</li>
<li>Type: 0x07 (SubscribeEventgroupAck).</li>
<li>Service ID, Instance ID, Major Version, Eventgroup ID, Counter, and Reserved are same value as in the Subscribe that is being answered. <div class="image">
<img src="SubscribeEgAck_Wireshark.png" alt="SubscribeEgAck_Wireshark.png"/>
<div class="caption">
Wireshark output for SubscribeEventgroupAck()</div></div>
</li>
</ul>
<h3>3.1.5 Service Discovery Communication Behavior</h3>
<ul>
<li>SOME/IP Service Discovery reduces the number of Service Discovery messages by packing entries together whenever possible.</li>
</ul>
<h4>3.1.5.1 Startup Behavior</h4>
<ul>
<li>For each Service Instance or Eventgroup the Service Discovery have at least these three phases in regard to sending entries:<ul>
<li>Initial Wait Phase</li>
<li>Repetition Phase</li>
<li>Main Phase</li>
</ul>
</li>
<li>The service discovery enters the InitialWait Phase for a client service instance when the link on the interface needed for this service instance is up and the client service is requested by the application.</li>
<li>The service discovery enters the Initial Wait Phase for a server service instance when the link on the interface needed for this service instance is up and the server service is available.</li>
<li>The Service Discovery waits based on the INITIAL_DELAY after entering the Initial Wait Phase and before sending the first messages for the Service Instance.</li>
<li>INITIAL_DELAY defined as a minimum and a maximum delay.</li>
</ul>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">INITIAL-DELAY-MAX-VALUE</span>&gt;0.1&lt;/<span class="keywordtype">INITIAL-DELAY-MAX-VALUE</span>&gt;</div><div class="line">&lt;<span class="keywordtype">INITIAL-DELAY-MIN-VALUE</span>&gt;0.01&lt;/<span class="keywordtype">INITIAL-DELAY-MIN-VALUE</span>&gt;</div></div><!-- fragment --><ul>
<li>The wait time will be determined by choosing a random value between the minimum and maximum of INITIAL_DELAY.</li>
<li>After sending the first message the Repetition Phase of this Service Instance/these Service Instances is entered.</li>
<li>The Service Discovery waits in the Repetitions Phase based on REPETITIONS_BASE_DELAY.</li>
<li>After each message sent in the Repetition Phase the delay is doubled.</li>
<li>The Service Discovery sends out only up to REPETITIONS_MAX entries during the Repetition Phase.</li>
</ul>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">INITIAL-REPETITIONS-BASE-DELAY</span>&gt;0.2&lt;/<span class="keywordtype">INITIAL-REPETITIONS-BASE-DELAY</span>&gt;</div><div class="line">&lt;<span class="keywordtype">INITIAL-REPETITIONS-MAX</span>&gt;3&lt;/<span class="keywordtype">INITIAL-REPETITIONS-MAX</span>&gt;</div></div><!-- fragment --><ul>
<li>After the Repetition Phase the Main Phase is being entered for a Service Instance.</li>
<li>After entering the Main Phase, the provider waits 1*CYCLIC_OFFER_DELAY before sending the first offer entry message.</li>
<li>In the Main Phase Offer Messages is sent cyclically if a CYCLIC_OFFER_DELAY is configured.</li>
<li>After a message for a specific Service Instance the Service Discovery waits for 1*CYCLIC_OFFER_DELAY before sending the next message for this Service Instance. <div class="fragment"><div class="line">&lt;<span class="keywordtype">OFFER-CYCLIC-DELAY</span>&gt;2.0&lt;/<span class="keywordtype">OFFER-CYCLIC-DELAY</span>&gt;</div></div><!-- fragment --></li>
<li>Example:</li>
<li>A. Initial Wait Phase:<ul>
<li>1. Wait for random_delay in Range(INITIAL_DELAY_MIN, _MAX)</li>
<li>2. Send message (Find Service and Offer Service entries)</li>
</ul>
</li>
<li>B. Repetition Phase (REPETITIONS_BASE_DELAY=100ms, REPETITIONS_MAX=2):<ul>
<li>1. Wait 2^0 * 100ms</li>
<li>Send message (Find Service and Offer Service entries)</li>
<li>Wait 2^1 * 100ms</li>
<li>Send message (Find Service and Offer Service entries)</li>
</ul>
</li>
<li>C. Main Phase (as long message is active and CYCLIC_OFFER_DELAY is defined):<ul>
<li>Wait CYCLIC_OFFER_DELAY</li>
<li>Send message (Offer Service entries)</li>
</ul>
</li>
</ul>
<h4>3.1.5.2 Server Answer Behavior</h4>
<ul>
<li>The Service Discovery delay answers to entries that were received in multicast SOME/IP-SD messages using the configuration item REQUEST_RESPONSE_DELAY.</li>
<li>The REQUEST_RESPONSE_DELAY will not apply if unicast messages are answered with unicast messages.</li>
<li>REQUEST_RESPONSE_DELAY will be specified by a minimum and a maximum.</li>
<li>The actual delay is randomly chosen between minimum and maximum of REQUEST_RESPONSE_DELAY. <div class="fragment"><div class="line">&lt;<span class="keywordtype">REQUEST-RESPONSE-DELAY</span>&gt;</div><div class="line">  &lt;<span class="keywordtype">MAX-VALUE</span>&gt;1.5&lt;/<span class="keywordtype">MAX-VALUE</span>&gt;</div><div class="line">  &lt;<span class="keywordtype">MIN-VALUE</span>&gt;1.5&lt;/<span class="keywordtype">MIN-VALUE</span>&gt;</div><div class="line">&lt;/<span class="keywordtype">REQUEST-RESPONSE-DELAY</span>&gt;</div></div><!-- fragment --></li>
</ul>
<h4>3.1.5.3 Shutdown Behavior</h4>
<ul>
<li>When a server service instance of an ECU is in the Repetition and Main Phase and is being stopped, a Stop Offer Service entry will be sent out.</li>
<li>When a server sends out a Stop Offer Service entry all subscriptions for this service instance get deleted on the server side.\</li>
<li>When the whole ECUs is being shut down Stop Offer Service entries will be sent out for all service entries and Stop Subscribe Eventgroup entries for Eventgroups.</li>
<li>TTL(Time to live) : Describes the lifetime of the entry in seconds</li>
</ul>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">SERVICE-OFFER-TIME-TO-LIVE</span>&gt;10&lt;/<span class="keywordtype">SERVICE-OFFER-TIME-TO-LIVE</span>&gt;</div></div><!-- fragment --> <h3>3.1.6 Generation of vsomeip.json</h3>
<ul>
<li>In case of adaptive platform, vsomeip.json will get generated from system_manifest.arxml file by using jsongen.py scripts.</li>
</ul>
<div class="image">
<img src="jsongen.png" alt="jsongen.png"/>
<div class="caption">
Generated Output(vsomeip.json)</div></div>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="adaptiveplatform_root.html">Adaptive Platform Tutorials</a></li><li class="navelem"><a class="el" href="adaptive_communicationmanagement.html">Communication Management</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
