
\begin{DoxyItemize}
\item \hyperlink{revision_history}{Revision History}
\item \hyperlink{adaptive_platform_introduction}{Introduction to Adaptive Platform}
\item \hyperlink{adaptive_communicationmanagement}{Communication Management}
\item \hyperlink{adaptive_executionmanagement}{Execution Management}
\item \hyperlink{adaptive_update_configurationmanagement}{Update \& Configuration Management}
\item \hyperlink{adaptive_configurationmethodology}{Configuration Methodology}
\item \hyperlink{adaptive_persistency}{Persistency}
\item \hyperlink{adaptive_state_manager}{State Manager}
\item \hyperlink{Porting_rocko}{Porting Adaptive Platform to Rocko}
\item \hyperlink{Debug_App}{Debug Adaptive Platform Application Using Eclipse}
\item \hyperlink{Performance_parameter}{Performance Parameter} 
\end{DoxyItemize}\hypertarget{revision_history}{}\section{Revision History}\label{revision_history}
\subsection*{Revision Version 1.\+0.\+0}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*4{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Sl.\+No. }&{\bf Date }&{\bf Version }&{\bf Change Description  }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Sl.\+No. }&{\bf Date }&{\bf Version }&{\bf Change Description  }\\\cline{1-4}
\endhead
1 &30-\/\+Nov-\/2018 &1.\+0.\+0 &Initial version \\\cline{1-4}
\end{longtabu}
\subsection*{Revision Version 1.\+0.\+1}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*4{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Sl.\+No. }&{\bf Date }&{\bf Version }&{\bf Change Description  }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Sl.\+No. }&{\bf Date }&{\bf Version }&{\bf Change Description  }\\\cline{1-4}
\endhead
1 &31-\/\+Jan-\/2019 &1.\+0.\+1 &State Manager has been added. \\\cline{1-4}
2 &31-\/\+Jan-\/2019 &1.\+0.\+1 &C\+Make command for debugging has been updated. \\\cline{1-4}
3 &31-\/\+Jan-\/2019 &1.\+0.\+1 &Performance Parameter updated for installing N\+TP server. \\\cline{1-4}
\end{longtabu}
\hypertarget{adaptive_platform_introduction}{}\section{Introduction to Adaptive Platform}\label{adaptive_platform_introduction}
To understand, why we need an Adaptive Platform, let\textquotesingle{}s start to understand current {\bfseries In-\/\+Vehicle Network Infrastructure}. Current generation E\+C\+Us mainly implement functionality that replaces or augments electromechanical systems. Software in those deeply-\/embedded E\+C\+Us, controls electrical output signals based on input signals and information from other E\+C\+Us connected to vehicle network. Much of the control software is designed and implemented for the target vehicle and does not change fundamentally during vehicle life-\/time. 
\begin{DoxyItemize}
\item Deeply Embedded with real time, safe and secure system
\item Static Network Configuration
\item Static deployment of Application S\+W\+Cs
\item Low Computing Power
\item Not scalable, Limited Bandwidth
\item No standardized solution available for fail operational systems and updates over the air
\end{DoxyItemize}

Future vehicle functions/applications such as Autonomous Car, Car-\/2-\/X, software updates over the air, or vehicles as part of the IoT, will introduce highly complex and computing resource demanding software into the vehicles and must fulfill strict integrity and security requirements. Such software realizes functions, such as environment perception, behavior planning, integrates the vehicle into external backend and infrastructure systems. The software in the vehicle needs to be changed during the life cycle of the vehicle, due to evolving external systems or improved functionality. However, the generic automotive M\+C\+Us of today are not focused on high-\/performance and are therefore not capable of handling such tasks. A trend towards having a larger, central and more computational heavy core can be seen, making high-\/performance hardware an interesting option. This compels A\+U\+T\+O\+S\+AR to adopt the idea of utilizing either V\+Ms or more powerful hardware. The A\+U\+T\+O\+S\+AR Classic Platform (CP) standard addresses the needs of deeply-\/embedded E\+C\+Us, while the needs of E\+C\+Us described above cannot be fulfilled well. Therefore, A\+U\+T\+O\+S\+AR specifies a second software platform, the A\+U\+T\+O\+S\+AR Adaptive Platform (AP). AP provides mainly high-\/performance computing and communication mechanisms and offers flexible software configuration, e.\+g. to support software update over-\/the-\/air.  {\bfseries Comparison between A\+U\+T\+O\+S\+AR Classic Platform and Adaptive Platform}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Classic Platform }&{\bf Adaptive Platform  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Classic Platform }&{\bf Adaptive Platform  }\\\cline{1-2}
\endhead
Based on O\+S\+EK OS (Real time Embedded System) and Generally Developed in “\+C” &Based on P\+O\+S\+IX (P\+S\+E51 – Minimal Real time Embedded System) and Developed in C++ \\\cline{1-2}
Signal based communication &Service based communication \\\cline{1-2}
Static Network, Task and Application S\+WC Configuration and Scheduling Strategy. Whole Stack compiled and linked to generate the full target image for the hardware &Thread and not runnable based communication, Flexible Configuration, Dynamic Deployment of new functionalities without the need to generate the full target image for the hardware \\\cline{1-2}
Same Address space for all the applications (M\+PU Support) &Each Application run in it’s own protected address space (M\+MU Support) \\\cline{1-2}
Execution of code directly from R\+OM &Application is loaded from persistence memory to R\+AM \\\cline{1-2}
Real time (High in the range of micro second), Safety critical (up to A\+S\+IL D), Low computing power &Not so real time (in the range of milli second), High Computing Power, Fail Safe Operational System, Highly secured \\\cline{1-2}
\end{longtabu}




While the communication protocols of the classical platform are based on signal based paradigm that is statically pre-\/configured before run-\/time (operation), while the adaptive platform is based service-\/oriented communication allowing dynamic initiation of communication paths. Similarly, the dynamic scheduling of applications would allow dynamic deployment of application during runtime. Another important characteristic is the Memory Management Unit, through which each process (task) executed by the operating system have its own virtual address and doesn’t recognize the existence of others. This assists the achievement of freedom from interference between applications, even after their deployment during runtime. All this is realized through a P\+O\+S\+IX complaint operating system, to allow the compatibility between other applications.

{\bfseries Types of Adaptive Platform\+:} Machine term has been newly introduced with the A\+U\+T\+O\+S\+AR Adaptive Platform. A machine is resembled to virtualized E\+CU, an entity where software can be deployed to. In this context, one real E\+CU could run several machines. In the simplest case the term machine is nothing but an E\+CU. 

\begin{quote}
{\bfseries Existence of Classic Platform\+:} A\+U\+T\+O\+S\+AR has no intention of replacing the Classical Platform with the Adaptive Platform, but the aim is to have both platforms coexisting and functioning together on the same network without risking the stability of the existing classical architecture that has been proven over the years. The introduction of the Adaptive Platform intends to complement the automotive specific functionalities and sustain the domain’s fundamental attributes such as reliability, availability, maintainability and safety. \end{quote}


{\bfseries Integration of Classic, Adaptive and Non-\/\+A\+U\+T\+O\+S\+AR E\+C\+Us\+:} A\+U\+T\+O\+S\+AR Adaptive Architecture uses the S\+O\+M\+E/\+IP to integrate with A\+U\+T\+O\+S\+AR CP and other Non-\/\+A\+U\+T\+O\+S\+AR Platforms like G\+E\+N\+I\+VI  \section*{1. Technology Drivers}

There are two major groups of technology drivers behind. One is Ethernet, and the other is processors.
\begin{DoxyItemize}
\item {\itshape Ethernet}
\begin{DoxyItemize}
\item High bandwidth
\item Communication system is not a limiting aspect any more
\item Switched network
\item Efficient point-\/to-\/point communication
\item Efficient transfer of long messages
\end{DoxyItemize}
\item {\itshape Processor}
\begin{DoxyItemize}
\item Switch from microcontroller to processors with external memory (and maybe filesystems)
\item Many core processors
\item Parallel computing
\item \char`\"{}\+Cheap\char`\"{} availability of computing power
\item Special purpose processors
\end{DoxyItemize}
\end{DoxyItemize}

\section*{2. Adaptive Platform Characteristics}


\begin{DoxyItemize}
\item {\itshape Language C++}
\item {\itshape S\+OA}
\item {\itshape Parallel processing}
\item {\itshape Leveraging existing standard}
\item {\itshape Safety and security}
\item {\itshape Planned dynamics}
\item {\itshape Agile}
\end{DoxyItemize}

\subsection*{2.\+1 Service Oriented Architecture (S\+OA)}

A service-\/oriented architecture (S\+OA) is an approach used to create a software architecture based on the use of services that is exchanged between application software components. It enables the idea of service reuse, no need to start from scratch when upgrades and other modifications are needed; which creates an efficient and flexible way to interconnect systems to perform a specific job increasing the system scalability and re-\/usability, and simultaneously eases the coexistence of different applications.  The exchange of services is based on a Service-\/\+Oriented Communication (S\+OC) paradigm, where “an application is interpreted as a set of data providing (sensors), data processing (application logic), and data consuming (actuators) services. As shown in the above figure, the communication paths follow a producer/consumer or client/server model, where some applications offer their services as producers, while other applications subscribe for services as consumers. This allows the introduction of new services independent of vendors, products, technologies, and without introducing changes in the underlying program, which further support the establishment of communication paths at run-\/time.

Only the needed data is subscribed for and reaches the client; unlike the classical way where all the data is broadcasted regardless of the receiver. Moreover, S\+O\+M\+E/\+IP can be implemented on different operating system and even embedded devices without an operating system; serving the intention of providing compatibility, and allowing stronger interactions with off-\/board systems and non-\/\+A\+U\+T\+O\+S\+AR applications.

A service consists of a combination of
\begin{DoxyItemize}
\item Events
\item Methods
\item Fields
\end{DoxyItemize}

\subsection*{2.\+2 Parallel Processing}

The distributed computing is inherently parallel. The S\+OA, as different applications uses different set of services, shares this characteristic. The advancement or many core processors and heterogeneous computing that offer parallel processing capability offers technological opportunities to harness the compute power to match the inherent parallelism. Thus, the AP possesses the architectural capability to scale its functionality and performance as the manycore-\/heterogeneous computing technologies advance.

\subsection*{2.\+3 Leveraging existing standard}


\begin{DoxyItemize}
\item Reuse existing (non-\/automotive) standards
\item Ease software development
\item Support automotive use-\/cases and protocols 
\end{DoxyItemize}

\subsection*{2.\+4 Safety and Security}

The systems that AP targets often require highest level of safety and security. To cope with the challenge, AP combines architectural, functional, and procedural approaches. The architecture is based on distributed computing based on S\+OA, which inherently makes each component more independent and free of unintended interferences, dedicated functionalities to assist achieving safety and security.

\subsection*{2.\+5 Planned Dynamics}

The AP supports incremental deployment of applications, where resources and communications are managed dynamically to reduce the effort for software development and integration, enabling short iteration cycles. Incremental deployment also supports explorative software development phases. AP allows the system integrator to carefully limit dynamic behavior to reduce the risk of unwanted or adverse effects allowing safety qualification. Dynamic behavior of an application will be limited by constraints stated in the Application Manifest.  Configuration of communication paths can happen at design-\/, at startup-\/ or at run-\/time and is therefore considered either static or dynamic.
\begin{DoxyItemize}
\item {\bfseries Full static configuration\+:} service discovery is not needed at all as the server knows all clients and clients know the server.
\item {\bfseries No discovery by application code\+:} the clients know the server but the server does not know the clients. Event subscription is the only dynamic communication pattern in the application.
\item {\bfseries Full service discovery in the application\+:} No communication paths are known at configuration time. An A\+PI for Service discovery allows the application code to choose the service instance at runtime.
\end{DoxyItemize}

Examples of Planned Dynamics are
\begin{DoxyItemize}
\item Pre-\/determination of service discovery process
\item Restriction of dynamic memory allocation to startup phase only
\item Fair scheduling policy in addition to priority-\/based scheduling
\item Fixed allocation of processes to C\+PU cores
\item Access to pre-\/existing files in the file-\/system only
\item Constraints for AP A\+PI usage by Applications
\item Execution of authenticated code only
\end{DoxyItemize}

\subsection*{2.\+6 Agile}

To support Agile Development process, it is important that underlying architecture e.\+g. Adaptive Platform is scalable with the possibility of updating the system after its deployment.

\section*{3 Adaptive Platform Architecture}

The A\+U\+T\+O\+S\+AR Adaptive architecture organizes the software of the A\+U\+T\+O\+S\+AR Adaptive foundation as functional clusters. These clusters offer common functionality as services to the applications. The Adaptive Application (AA) run on top of A\+RA, A\+U\+T\+O\+S\+AR Runtime for Adaptive applications. A\+RA consists of application interfaces provided by Functional Clusters, which belong to either Adaptive Platform Foundation or Adaptive Platform Services. Adaptive Platform Foundation provides fundamental functionalities of AP, and Adaptive Platform Services provide platform standard services of AP. The interface of Functional Clusters, either they are those of Adaptive Platform Foundation or Adaptive Platform Services, are indifferent from AA point of view. \subsection*{3.\+1 Adaptive Platform Foundation}

Adaptive Platform Foundation consists of following functional clusters\+:
\begin{DoxyItemize}
\item {\bfseries Communication Management}
\item {\bfseries A\+RA Core Types}
\item {\bfseries Execution Management}
\item {\bfseries R\+E\+S\+Tful Communication}
\item {\bfseries Time Synchronization}
\item {\bfseries Persistency}
\item {\bfseries Log\+And\+Trace}
\item {\bfseries Platform Health Management}
\item {\bfseries Identify Access Management}
\item {\bfseries Crypto}
\item {\bfseries Operating System with P\+O\+S\+IX Interface (P\+SE 51)}
\end{DoxyItemize}

\subsubsection*{3.\+1.\+1 Communication Management}

The Communication Management (CM) for A\+U\+T\+O\+S\+AR Adaptive is a functional cluster and is part of \char`\"{}\+A\+U\+T\+O\+S\+A\+R Runtime for Adaptive Applications\char`\"{} -\/ A\+RA. It is responsible for the construction and supervision of communication paths between applications, both local and remote. The CM provides the infrastructure that enables communication between Adaptive A\+U\+T\+O\+S\+AR Applications within one machine and with software entities on other machines, e.\+g. other Adaptive A\+U\+T\+O\+S\+AR applications or Classic A\+U\+T\+O\+S\+AR S\+W\+Cs. All communication paths can be established at design-\/ , start-\/up-\/ or run-\/time.  The Communication management of A\+U\+T\+O\+S\+AR Adaptive can be logically divided into the following sub-\/parts\+:
\begin{DoxyItemize}
\item Language binding
\item End-\/to-\/end communication protection
\item Communication / Network binding
\item Communication Management software
\end{DoxyItemize}

The Communication Management provides standardized means how a defined service is presented to the application implementer (upper layer, Language Binding) as well as the respective representation of the service’s data on the network (lower layer, Network Binding). This assures portability of source code and compatibility of compiled services across different implementations of the platform.

Service-\/\+Oriented Communication (SoC) is the main communication pattern for Adaptive A\+U\+T\+O\+S\+AR Applications. It allows establishing communication paths both at design-\/time and run-\/time. Hence, it can be used to build up both static communication with known numbers of participants and dynamic communication with unknown number of participants.

The service class is the central element of the Service-\/\+Oriented Communication pattern applied in Adaptive A\+U\+T\+O\+S\+AR. It represents the service by collecting the methods and events which are provided or requested by the applications implementing the concrete service functionality.

Regarding interaction between A\+As, P\+S\+E51 do not include I\+PC (Inter-\/\+Process-\/\+Communication), so there is no direct interface to interact between A\+As. The Communication Management (CM) is the only explicit interface. CM also provides Service Oriented Communication for both intra-\/machine and inter-\/machine, which are transparent to applications. CM handles routing of Service requests/replies regardless of the topological deployment of Service and client applications.

\begin{quote}
{\bfseries Note\+: The Communication Management software using Service-\/\+Oriented Communication will not achieve hard real time requirements, as the implementation will behave like a virtual ethernet including latencies of communication. This behavior must be respected with the design of the overall E\+CU and SW system.} \end{quote}


\subsubsection*{3.\+1.\+2 Execution Management}

Execution Management is responsible for all aspects of system execution management including platform initialization and startup / shutdown of Applications. Execution Management works in conjunction with the Operating System to perform run-\/time scheduling of Applications. 

When the Machine is started, the OS will be initialized first and then Execution Management is launched as one of the O\+S’s initial processes. Other functional clusters and platform-\/level Applications of the Adaptive Platform Foundation are then launched by Execution Management. After the Adaptive Platform Foundation is up and running, Execution Management continues launching Adaptive Applications. The startup order of the platform-\/level Applications and the Adaptive Applications are determined by the Execution Management, based on Machine Manifest and Application Manifest information.  Execution Management is responsible for all aspects of Adaptive Platform execution management and Application execution management including\+:


\begin{DoxyItemize}
\item Machine State Management
\item Start-\/up and shutdown of Applications, including platform-\/level Applications and Adaptive Applications.
\item The Execution Management is the initial (“boot”) process of the operating system and is responsible for Machine start-\/up.
\item The Execution Management enforces process isolation with each Executable managed as a single process.
\item Privileges and use of access control
\end{DoxyItemize}

\begin{quote}
{\bfseries Note\+: The Execution Management is not responsible for run-\/time scheduling of Applications since this is the responsibility of the Operating System. However, the Execution Management is responsible for initialization / configuration of the OS to enable it to perform the necessary run-\/time scheduling based on information extracted by the Execution Management from the Machine Manifest and Application Manifests.} \end{quote}


\subsubsection*{3.\+1.\+3 Persistency}

Persistency offers mechanisms to applications and other functional clusters of the Adaptive Platform to store information in the non-\/volatile memory of an Adaptive Machine. The data is available over boot and ignition cycles. Persistency offers standard interfaces to access the non-\/volatile memory. The Persistency A\+P\+Is take storage location identifiers as parameters from the application to address different storage locations. The available storage locations fall into two categories. Every application may use a combination of these storage types.
\begin{DoxyItemize}
\item {\bfseries Key-\/\+Value Storage}
\item {\bfseries File-\/\+Proxy Storage}
\end{DoxyItemize}

\begin{quote}
{\bfseries Note\+: Persistent data is always private to one application. There is no mechanism available to share data between different applications using the Persistency} \end{quote}


\subsubsection*{3.\+1.\+4 Operating System with P\+O\+S\+IX Interface (P\+SE 51)}

The Operating System is responsible for run-\/time resource management (including time) for all Applications on the Adaptive Platform. It offers the foundation for dynamic behavior of the software applications. It manages the scheduling of processes and events, the data exchange and synchronization between different processes and provides features for monitoring and error handling. The AP Operating System is required to provide multi-\/process P\+O\+S\+IX OS capability. Each AA is implemented as an independent process, with its own logical memory space and name space.

G\+N\+U/\+Linux is an operating system that uses a combination of G\+NU software and Linux as its kernel, hence named \char`\"{}\+G\+N\+U/\+Linux\char`\"{}. G\+N\+U/\+Linux is used to refer to the whole operating system and the term Linux would be used to refer to the kernel itself. Linux -\/the kernel-\/ is the most important part of the operating system, as it manages access to the hardware resources required by the programs of the operating system run as User Applications. It operates in what is called “the kernel space”; interacting with these applications through its system call interface

On the other hand, G\+N\+U/\+Linux consists of many programs other than the kernel, which may include for example the graphical user interfaces, compilers, specific libraries and many other services. However, without the kernel the operating system can’t provide these services  \begin{quote}
{\bfseries Note\+: Adaptive Platform does not specify a new Operating System for highly performant processors. Rather, it defines an execution context and Operating System Interface (O\+SI) for use by Adaptive Applications.} \end{quote}


{\bfseries P\+O\+S\+IX (P\+S\+E51)}\+:Minimal Real-\/\+Time System (P\+S\+E51) offers functions for
\begin{DoxyEnumerate}
\item basic synchronized I/O,
\item high-\/resolution timer,
\item signals,
\item semaphores,
\item shared memory and threads.
\end{DoxyEnumerate}

 Scheduling\+: The operating system provides multi-\/threading and multi-\/process support. The standard scheduling policies are S\+C\+H\+E\+D\+\_\+\+F\+I\+FO and S\+C\+H\+E\+D\+\_\+\+RR, which are defined by the P\+O\+S\+IX standard.

\begin{quote}
{\bfseries Note\+: As the envisioned application software components for Adaptive Platform will not require to fork new processes themselves, and only need limited direct access to files, the P\+S\+E51 profile is thought to be sufficient.} \end{quote}


\subsubsection*{3.\+1.\+5 Platform Health Management}

Health Monitoring is required by \mbox{[}5, I\+SO 26262\mbox{]} under the terms control flow monitoring, external monitoring facility, watchdog, logical monitoring, temporal monitoring, program sequence monitoring.

The Platform Health Management supervises the execution of software. It offers the following supervision functionalities\+:
\begin{DoxyItemize}
\item {\bfseries Alive supervision} \+: Alive Supervision checks that a Supervised Entity is not running too frequently and not too rarely
\item {\bfseries Deadline supervision} \+: Deadline supervision checks that step in a Supervised Entity are executed in a time that is within the configured minimum and maximum limits.
\item {\bfseries Logical supervision} \+: Logical supervision checks that the control flow during execution matches the designed control flow.
\item {\bfseries Health Channel Supervision} \+: Health channel supervision provides the possibility to hook external supervision results (like R\+AM test, voltage monitoring, …) to the Platform Health Management
\end{DoxyItemize}

\subsection*{3.\+2 Adaptive Platform Services}


\begin{DoxyItemize}
\item {\bfseries Update and Configuration Management}
\item {\bfseries Signal to Service Mapping}
\item {\bfseries State Management}
\item {\bfseries Diagnostic}
\item {\bfseries Network Management}
\end{DoxyItemize}

\subsubsection*{3.\+2.\+1 Update and Configuration Management}

One of the declared goals of Adaptive A\+U\+T\+O\+S\+AR is the ability to flexibly update the software and its configuration through over-\/the-\/air updates. To support changes in the software on an Adaptive Platform the Update and Configuration Manager(\+U\+C\+M) provides an Adaptive Platform service that handles software update requests.  U\+CM is responsible for updating, installing, removing and keeping a record of the software on an Adaptive Platform. Its role is similar to known package management systems like dpkg or Y\+UM in Linux, with additional functionality to ensure a safe and secure way to update or modify software on the Adaptive Platform.

\subsubsection*{3.\+2.\+2 State Management}

State Management is the Functional Cluster which is responsible for defining the current set of Machine State and Function Group States, and for initiating State transitions by requesting them from Execution Management. Execution Management performs the State transitions and controls the actual set of running Processes, depending on the current States.

State Management is the central point where new Machine States and the Function Group States can be requested and where the requests are arbitrated, including coordination of contradicting requests from different sources. Additional data and events might need to be considered for arbitration.

The State change requests can be issued by\+:
\begin{DoxyItemize}
\item Platform Health Management to trigger error recovery, e.\+g. to activate fallback functionality
\item Diagnostics, to switch the system into diagnostic states
\item Update and Config Management to switch the system into states where software or configuration can be updated
\item Network Management to coordinate required functionality and network state
\item authorized applications, e.\+g. a vehicle state manager which might be located in a different machine or on a different E\+CU
\end{DoxyItemize}

State Change requests can be issued by other Functional Clusters via ara\+::com service interfaces. Since State Management functionality is critical, access from other Functional Clusters or Applications must be secured, e.\+g. by I\+AM (Identity and Access Management). State Management is monitored and supervised by Platform Health Management. State Management provides interfaces to request information about current states.  Four different states are relevant for Execution Management\+:
\begin{DoxyItemize}
\item {\bfseries Machine State\+:} Machine States are mainly used to control machine life cycle (startup/shutdown/restart), platform level processes and other infrastructure. There are several mandatory Machine states that must be present on each machine. Additional machine specific Machine States can be defined in the Machine Manifest.
\item {\bfseries Function Group State\+:} Function Group States are mainly used to individually start and stop groups of functionally coherent user level Application processes. They can be configured in the Machine Manifest.
\item {\bfseries Process State\+:} Process States are used for Application Life cycle Management and are implemented by an Execution Management internal state machine.
\item {\bfseries Application State\+:} The Application State characterizes the internal life cycle of any instance of an Application Executable, i.\+e. process. Each process must report Application State changes to Execution Management.
\end{DoxyItemize}

\section*{4 Configuration Methodology}

In contrast to the A\+U\+T\+O\+S\+AR Classic Platform, instances of Adaptive Applications, for example, are executed within the context of processes, entities managed by the operating system. If permitted by the configuration of the operating system, processes may be started, executed or stopped, at any time during the life cycle of a machine. As a consequence, the way of configuration (by the means of Manifests) or when and how software packages are deployed (e.\+g., by software updates over-\/the-\/air) clearly differ from the concepts of the A\+U\+T\+O\+S\+AR Classic Platform.

A Manifest represents a piece of A\+U\+T\+O\+S\+AR model description that is created to support the configuration of an A\+U\+T\+O\+S\+AR AP product and which is uploaded to the A\+U\+T\+O\+S\+AR AP product, potentially in combination with other artifacts (like binary files) that contain executable code to which the Manifest applies.  Development Work flow is mainly divided into four parts\+:


\begin{DoxyItemize}
\item {\bfseries Application Design\+:} This kind of description specifies all design-\/related aspects e.\+g. data types, service interfaces, persistency interfaces etc.. that apply to the creation of application software for the A\+U\+T\+O\+S\+AR AP. It is not necessarily required to be deployed to the adaptive platform machine, but the application design aids the definition of the deployment of application software in the Application Manifest and Service Instance Manifest.
\item {\bfseries Application Manifest\+:} This kind of Manifest is used to specify the deployment-\/related information of applications running on the A\+U\+T\+O\+S\+AR AP e.\+g how the application instance shall be started with startup options and access roles. An Application Manifest is bundled with the actual executable code to support the integration of the executable code onto the machine.
\item {\bfseries Service Instance Manifest\+:} This kind of Manifest is used to specify how service-\/oriented communication is configured in terms of the requirements of the underlying transport protocols. A Service Instance Manifest is bundled with the actual executable code that implements the respective usage of service-\/oriented communication.
\item {\bfseries Machine Manifest\+:} This kind of Manifest is supposed to describe deployment-\/related content that applies to the configuration of just the underlying machine (i.\+e. without any applications running on the machine) e.\+g. Configuration of the service discovery technology, Definition of the used machine states, Definition of the used function groups that runs an A\+U\+T\+O\+S\+AR AP. A Machine Manifest is bundled with the software taken to establish an instance of the A\+U\+T\+O\+S\+AR AP. 
\end{DoxyItemize}\hypertarget{adaptive_communicationmanagement}{}\section{Communication Management}\label{adaptive_communicationmanagement}

\begin{DoxyItemize}
\item \hyperlink{adaptive_communicationmanagement_introduction}{Introduction}
\item \hyperlink{adaptive_communicationmanagement_someip}{S\+O\+M\+E/\+IP(Scalable service-\/\+Oriented MiddlewarE over IP)}
\item \hyperlink{adaptive_communicationmanagement_aracom}{A\+RA Com A\+PI}
\item \hyperlink{adaptive_communicationmanagement_ararest}{A\+RA R\+E\+ST} 
\end{DoxyItemize}\hypertarget{adaptive_communicationmanagement_introduction}{}\subsection{Introduction}\label{adaptive_communicationmanagement_introduction}
The A\+U\+T\+O\+S\+AR Adaptive architecture organizes the software of the A\+U\+T\+O\+S\+AR Adaptive foundation as functional clusters. These clusters offer common functionality as services to the applications. The Communication Management (CM) for A\+U\+T\+O\+S\+AR Adaptive is such a functional cluster and also part of \char`\"{}\+A\+U\+T\+O\+S\+A\+R Runtime for Adaptive Applications\char`\"{} -\/ A\+RA. It is responsible for the construction and supervision of communication paths between applications, both local and remote. The CM provides the infrastructure that enables communication between Adaptive A\+U\+T\+O\+S\+AR Applications within one machine and with software entities on other machines, e.\+g. other Adaptive A\+U\+T\+O\+S\+AR applications or Classic A\+U\+T\+O\+S\+AR S\+W\+Cs. All communication paths can be established at design-\/ , start-\/up-\/ or run-\/time.

 \subsection*{1. Architectural concepts}

The Communication management of A\+U\+T\+O\+S\+AR Adaptive can be logically divided into the following sub-\/parts\+:
\begin{DoxyEnumerate}
\item Language binding
\item End-\/to-\/end communication protection
\item Communication / Network binding
\item Communication Management software
\end{DoxyEnumerate}

\subsection*{2. Design of the A\+RA A\+PI}


\begin{DoxyItemize}
\item The (service) proxy is the representative of the possibly remote (i.\+e. other process, other core, other node) service. It is an instance of a C++ class local to the application/client, which uses the service.
\item The (service) skeleton is the connection of the user provided service implementation to the middleware transport infrastructure. Service implementation is sub-\/classing the (service) skeleton.
\item Beside proxies/skeletons, there might exist a so-\/called \char`\"{}\+Runtime\char`\"{} (singleton) class to provide some essentials to manage proxies and skeletons.
\item Client/\+Server Communication uses concepts introduced by C++11 language, e.\+g. std\+::future, std\+::promise, to fully support method calls between different contexts. Future and Promise are the two separate sides of an asynchronous operation.
\begin{DoxyItemize}
\item std\+::promise is used by the \char`\"{}producer/writer\char`\"{} of the asynchronous operation.
\item std\+::future is used by the \char`\"{}consumer/reader\char`\"{} of the asynchronous operation.
\item The reason it is separated into these two separate \char`\"{}interfaces\char`\"{} is to hide the \char`\"{}write/set\char`\"{} functionality from the \char`\"{}consumer/reader\char`\"{}
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+1 Communication paradigms}

Service-\/\+Oriented Communication (SoC) is the main communication pattern for Adaptive A\+U\+T\+O\+S\+AR Applications. It allows establishing communication paths both at design-\/ and run-\/time, so it can be used to build up both static communication with known numbers of participants and dynamic communication with unknown number of participants.

 Service Discovery decides whether external and/or internal service-\/oriented communication is established. The discovery strategy allows either returning a specific service instance or all available instances providing the requested service at the time of the request, no matter if they are available locally or remote. \hypertarget{adaptive_communicationmanagement_someip}{}\subsection{S\+O\+M\+E/\+IP(Scalable service-\/\+Oriented MiddlewarE over IP)}\label{adaptive_communicationmanagement_someip}
S\+O\+M\+E/\+IP is an abbreviation for \char`\"{}\+Scalable service-\/\+Oriented Middlewar\+E over I\+P\char`\"{}. This middleware was designed for typical automotive use cases and for being compatible with A\+U\+T\+O\+S\+AR. S\+O\+M\+E/\+IP is an automotive/embedded communication protocol which supports remote procedure calls, event notifications and the underlying serialization/wire format.

\section*{Glossary of Terms}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Term }&{\bf Description  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Term }&{\bf Description  }\\\cline{1-2}
\endhead
Method &A method, procedure, function, or subroutine that is called/invoked. \\\cline{1-2}
Parameters &input, output, or input/output arguments of a method or an event \\\cline{1-2}
Remote Procedure Call (R\+PC) &A method call from one E\+CU to another that is transmitted using messages \\\cline{1-2}
Request &a message of the client to the server invoking a method \\\cline{1-2}
Response &a message of the server to the client transporting results of a method invocation \\\cline{1-2}
Request/\+Response communication &a R\+PC that consists of request and response \\\cline{1-2}
Event &A uni-\/directional data transmission that is only invoked on changes or cyclically and is sent from the producer of data to the consumers. \\\cline{1-2}
Field &A field does represent a status and thus has an valid value at all times on which getter, setter and notifier act upon. \\\cline{1-2}
Notification Event &An event message of the notifier of a field. \\\cline{1-2}
Getter &A Request/\+Response call that allows read access to a field. \\\cline{1-2}
Setter &A Request/\+Response call that allows write access to a field. \\\cline{1-2}
Notifier &Sends out event message with a new value on change of the value of the field. \\\cline{1-2}
Service &A logical combination of zero or more methods, zero or more events, and zero or more fields. \\\cline{1-2}
Service Interface &the formal specification of the service including its methods, events, and fields \\\cline{1-2}
Eventgroup &A logical grouping of events and notification events of fields inside a service in order to allow subscription \\\cline{1-2}
Service Instance &Implementation of a service, which can exist more than once in the vehicle and more than once on an E\+CU \\\cline{1-2}
Server &The E\+CU offering a service instance is called server in the context of this service instance. \\\cline{1-2}
Client &The E\+CU using the service instance of a server is called client in the context of this service instance. \\\cline{1-2}
Fire and Forget &Requests without response message are called fire\&forget. \\\cline{1-2}
Union &A data structure that dynamically assumes different data types. \\\cline{1-2}
\end{longtabu}


The three main parts of the S\+O\+M\+E/\+IP specification is as follows\+:


\begin{DoxyEnumerate}
\item \hyperlink{adaptive_communicationmanagement_someip_on_wire_format}{On-\/wire format}
\item \hyperlink{adaptive_communicationmanagement_someip_protocol}{Protocol}
\item \hyperlink{adaptive_communicationmanagement_someip_service_discovery}{Service Discovery(S\+O\+M\+E/\+I\+P-\/\+SD)}
\end{DoxyEnumerate}\hypertarget{adaptive_communicationmanagement_someip_on_wire_format}{}\subsubsection{1. On-\/wire format}\label{adaptive_communicationmanagement_someip_on_wire_format}

\begin{DoxyItemize}
\item S\+O\+M\+E/\+IP allows applications to communicate.
\item Packet formats are automatically determined by the specification of the Service.
\item Server offers a Service Instance that implements the Service Interface.
\item Client uses the Service Instance using S\+O\+M\+E/\+IP.
\end{DoxyItemize}\hypertarget{adaptive_communicationmanagement_someip_protocol}{}\subsubsection{2. Protocol}\label{adaptive_communicationmanagement_someip_protocol}
\subsection*{2.\+1 S\+O\+M\+E/\+IP Header Format}

 \subsubsection*{2.\+1.\+1 Message ID \mbox{[}32 Bit\mbox{]}}


\begin{DoxyItemize}
\item The Message ID is a 32 Bit identifier that is used to identify the R\+PC call to a method of an application or to identify an event.
\item Message I\+Ds of method calls will be structured in the ID with 2$^\wedge$16 services with 2$^\wedge$15 methods as shown below. 
\end{DoxyItemize}

\subsubsection*{2.\+1.\+2 Length \mbox{[}32 Bit\mbox{]}}


\begin{DoxyItemize}
\item Length field contains the length in Byte starting from Request I\+D/\+Client ID until the end of the S\+O\+M\+E/\+IP message.
\end{DoxyItemize}

\subsubsection*{2.\+1.\+3 Request ID \mbox{[}32 Bit\mbox{]}}


\begin{DoxyItemize}
\item The Request ID allows a provider and subscriber to differentiate multiple parallel uses of the same method, event, getter or setter.
\item The Request ID is unique for a provider-\/ and subscriber-\/combination only.
\item When generating a response message, the provider copies the Request ID from the request to the response message.
\item Request ID constructed of the Client ID and Session ID as shown below. 
\item The Client ID is the unique identifier for the calling client inside the E\+CU. The Client ID allows an E\+CU to differentiate calls from multiple clients to the same method.
\item The Session ID is a unique identifier that allows to distinguish sequential messages. It also allows to distinguish requests originating from the same sender from each other.
\item The Client ID supports being unique in the overall vehicle by having a configurable prefix or fixed value (e.\+g. the most significant byte of Client ID being the diagnostics address or a configured Client ID for a given application/\+S\+W-\/C). 
\item Request/\+Response methods use session handling with Session I\+Ds. Session ID should be incremented after each call.
\item When the Session ID reaches 0x\+F\+F\+FF, it wraps around and starts again with 0x01.
\item For request/response methods, a subscriber has to ignore a response if the Session ID of the response does not match the Session ID of the request.
\item For notification messages, a receiver ignores the Session ID in case Session Handling is not active.
\item For notification messages, a receiver treats the Session ID according to the respective use case.
\end{DoxyItemize}

\subsubsection*{2.\+1.\+4 Protocol Version \mbox{[}8 Bit\mbox{]}}


\begin{DoxyItemize}
\item The Protocol Version set to 1.
\end{DoxyItemize}

\subsubsection*{2.\+1.\+5 Interface Version \mbox{[}8 Bit\mbox{]}}


\begin{DoxyItemize}
\item Interface Version contains the Major Version of the Service Interface.
\end{DoxyItemize}

\subsubsection*{2.\+1.\+6 Message Type \mbox{[}8 Bit\mbox{]}}


\begin{DoxyItemize}
\item The Message Type field is used to differentiate different types of messages and contains the following values as shown in Table.
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*3{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Number }&{\bf Value }&{\bf Description  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Number }&{\bf Value }&{\bf Description  }\\\cline{1-3}
\endhead
0x00 &R\+E\+Q\+U\+E\+ST &A request expecting a response (even void) \\\cline{1-3}
0x01 &R\+E\+Q\+U\+E\+S\+T\+\_\+\+N\+O\+\_\+\+R\+E\+T\+U\+RN &A fire\&forget request \\\cline{1-3}
0x02 &N\+O\+T\+I\+F\+I\+C\+A\+T\+I\+ON &A request of a notification/event callback expecting no response \\\cline{1-3}
0x80 &R\+E\+S\+P\+O\+N\+SE &The response message \\\cline{1-3}
0x81 &E\+R\+R\+OR &The response containing an error \\\cline{1-3}
0x20 &T\+P\+\_\+\+R\+E\+Q\+U\+E\+ST &A Transport Protocol request expecting a response (even void) \\\cline{1-3}
0x21 &T\+P\+\_\+\+R\+E\+Q\+U\+E\+S\+T\+\_\+\+N\+O\+\_\+\+R\+E\+T\+U\+RN &A Transport Protocol fire\&forget request \\\cline{1-3}
0x22 &T\+P\+\_\+\+N\+O\+T\+I\+F\+I\+C\+A\+T\+I\+ON &A Transport Protocol request of a notification/event callback expecting no response \\\cline{1-3}
0x23 &T\+P\+\_\+\+R\+E\+S\+P\+O\+N\+SE &The Transport Protocol response message \\\cline{1-3}
0x24 &T\+P\+\_\+\+E\+R\+R\+OR &The Transport Protocol response containing an error \\\cline{1-3}
\end{longtabu}

\begin{DoxyItemize}
\item The 3rd highest bit of the Message Type (=0x20) is called as T\+P-\/\+Flag and will be set to 1 to signal that the current S\+O\+M\+E/\+IP message is a segment. The other bits of the Message Type are set as specified in this Section.
\end{DoxyItemize}

\subsubsection*{2.\+1.\+7 Return Code \mbox{[}8 Bit\mbox{]}}


\begin{DoxyItemize}
\item The Return Code is used to signal whether a request was successfully processed. For simplification of the header layout, every message transports the field Return Code. The allowed Return Codes for specific message types are shown in Table.
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Message Type }&{\bf Allowed Return Codes  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Message Type }&{\bf Allowed Return Codes  }\\\cline{1-2}
\endhead
R\+E\+Q\+U\+E\+ST &N/A set to 0x00 (E\+\_\+\+OK) \\\cline{1-2}
R\+E\+Q\+U\+E\+S\+T\+\_\+\+N\+O\+\_\+\+R\+E\+T\+U\+RN &N/A set to 0x00 (E\+\_\+\+OK) \\\cline{1-2}
N\+O\+T\+I\+F\+I\+C\+A\+T\+I\+ON &N/A set to 0x00 (E\+\_\+\+OK) \\\cline{1-2}
R\+E\+S\+P\+O\+N\+SE &Please refer 2.\+2.\+6.\+1 section \\\cline{1-2}
E\+R\+R\+OR &Please refer 2.\+2.\+6.\+1 section \\\cline{1-2}
\end{longtabu}
\subsubsection*{2.\+1.\+8 Payload \mbox{[}variable size\mbox{]}}


\begin{DoxyItemize}
\item In the payload field the parameters are carried. The serialization of the parameters will be specified in the following section.
\item The size of the S\+O\+M\+E/\+IP payload field depends on the transport protocol used.
\item The U\+DP binding of S\+O\+M\+E/\+IP can only transport S\+O\+M\+E/\+IP messages that fit directly into an IP packet. Use T\+CP only if very large chunks of data need to be transported ($>$ 1400 Bytes) and no hard latency requirements in the case of errors exists
\end{DoxyItemize}

\subsubsection*{2.\+1.\+9 Event, Field and Eventgroup}


\begin{DoxyItemize}
\item Eventgroup is a logical grouping of events and notification events of fields inside a service in order to allow subscription.
\item Events and notifications are transported using R\+PC. Events will be structured as shown in Table 
\end{DoxyItemize}

\subsubsection*{2.\+1.\+10 Endianess}


\begin{DoxyItemize}
\item S\+O\+M\+E/\+IP Header will be encoded in network byte order (big endian).
\item The byte order of the parameters inside the payload is defined by configuration.
\end{DoxyItemize}

\subsubsection*{2.\+1.\+11 Serialization of Data Structures}


\begin{DoxyItemize}
\item The serialization is based on the parameter list defined by the interface specification. The interface specification defines the exact position of all data structures in the P\+DU and has to consider the memory alignment.
\item Alignment is used to align the beginning of data by inserting padding elements after the data in order to ensure that the aligned data starts at certain memory addresses.
\end{DoxyItemize}

\paragraph*{2.\+1.\+11.\+1 Basic Datatypes}

The following basic datatypes as shown in Table are supported\+:

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*4{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Type }&{\bf Description }&{\bf Size \mbox{[}bit\mbox{]} }&{\bf Remark  }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Type }&{\bf Description }&{\bf Size \mbox{[}bit\mbox{]} }&{\bf Remark  }\\\cline{1-4}
\endhead
boolean &T\+R\+U\+E/\+F\+A\+L\+SE value &8 &F\+A\+L\+SE (0), T\+R\+UE (1) \\\cline{1-4}
uint8 &unsigned Integer &8 &\\\cline{1-4}
uint16 &unsigned Integer &16 &\\\cline{1-4}
uint32 &unsigned Integer &32 &\\\cline{1-4}
sint8 &signed Integer &8 &\\\cline{1-4}
sint16 &signed Integer &16 &\\\cline{1-4}
sint32 &signed Integer &32 &\\\cline{1-4}
float32 &floating point number &32 &I\+E\+EE 754 binary32 (Single Precision) \\\cline{1-4}
float64 &floating point number &64 &I\+E\+EE 754 binary64 (Double Precision) \\\cline{1-4}
\end{longtabu}
\paragraph*{2.\+1.\+11.\+2 Structured Datatypes (structs)}


\begin{DoxyItemize}
\item The serialization of a struct will be close to the in-\/memory layout. This means, only the parameters will be serialized sequentially into the buffer. Especially for structs it is important to consider the correct memory alignment. 
\end{DoxyItemize}

\paragraph*{2.\+1.\+11.\+3 Strings}


\begin{DoxyItemize}
\item All strings always starts with a Byte Order Mark (B\+OM).
\begin{DoxyItemize}
\item B\+OM \+: The byte order mark (B\+OM) is a Unicode character, U+\+F\+E\+FF byte order mark (B\+OM), whose appearance as a magic number at the start of a text stream can signal several things (eg. endianness) to a program consuming the text
\end{DoxyItemize}
\item The B\+OM will be included in fixed-\/length-\/strings as well as dynamic-\/length strings.
\item B\+OM allows the possibility to detect the used encoding.
\end{DoxyItemize}

\paragraph*{2.\+1.\+11.\+4 Arrays (fixed length)}


\begin{DoxyItemize}
\item The length of fixed length arrays is defined by the data type definition. They can be seen as repeated elements.\+Fixed length arrays are easier for use in very small devices. Dynamic length arrays might need more resources on the E\+CU using them.
\end{DoxyItemize}

\subparagraph*{2.\+1.\+11.\+4.\+1 One-\/dimensional}


\begin{DoxyItemize}
\item The one-\/dimensional arrays with fixed length \char`\"{}n\char`\"{} will carry exactly \char`\"{}n\char`\"{} elements of the same type. 
\end{DoxyItemize}

\subparagraph*{2.\+1.\+11.\+4.\+2 Multidimensional}


\begin{DoxyItemize}
\item The serialization of multidimensional arrays follows the in-\/memory layout of multidimensional arrays in the programming language (row-\/major order) and is shown in Figure below. 
\end{DoxyItemize}

\paragraph*{2.\+1.\+11.\+5 Dynamic Length Arrays}


\begin{DoxyItemize}
\item The layout of arrays with dynamic length will be based on the layout of fixed length arrays.
\item An optional length field at the beginning of an array should be used to specify the length of the array in Bytes.
\end{DoxyItemize}

\subparagraph*{2.\+1.\+11.\+5.\+1 One-\/dimensional}


\begin{DoxyItemize}
\item In the one-\/dimensional array one length field is used, which carries the number of bytes used for the array.
\end{DoxyItemize}

\subparagraph*{2.\+1.\+11.\+5.\+2 Multidimensional}


\begin{DoxyItemize}
\item In multidimensional arrays every sub array of different dimensions will have its own length field.
\end{DoxyItemize}

\paragraph*{2.\+1.\+11.\+6 Enumeration}


\begin{DoxyItemize}
\item Enumerations are not considered in S\+O\+M\+E/\+IP. Enumerations are transmitted as unsigned integer datatypes.
\end{DoxyItemize}

\paragraph*{2.\+1.\+11.\+7 Bitfield}


\begin{DoxyItemize}
\item Bitfields are transported as unsigned datatypes uint8/uint16/uint32.
\end{DoxyItemize}

\paragraph*{2.\+1.\+11.\+8 Union / Variant}


\begin{DoxyItemize}
\item A union (also called variant) is such a parameter that can contain different types of data. For example, if one defines a union of type uint8 and type uint16, the union will carry data which are a uint8 or a uint16.
\item Which data type will be transmitted in the payload can only be decided during execution. In this case, however, it is necessary to not only send the data itself but add an information about the applicable data type as a form of \char`\"{}meta-\/data\char`\"{} to the transmission.\+By the means of the attached meta-\/data the sender can identify the applicable data type of the union and the receiver can accordingly access the data properly.
\item A union consists of a length field, type selector and the payload as shown Table below. 
\item The length field defines the size of the data and padding in bytes and does not include the size of the length field and type field.
\item The type field specifies the data type of the data.
\end{DoxyItemize}

\subsection*{2.\+2 S\+O\+M\+E/\+IP Protocol specification}

This section describes the Remote Procedure Call(\+R\+P\+C), Event Notifications and Error Handling of S\+O\+M\+E/\+IP.

\subsubsection*{2.\+2.\+1 Transport Protocol Bindings}


\begin{DoxyItemize}
\item In order to transport S\+O\+M\+E/\+IP messages different transport protocols may be used. S\+O\+M\+E/\+IP currently supports U\+DP and T\+CP.
\item If a server runs different instances of the same service, messages belonging to different service instances will be mapped to the service instance by the transport protocol port on the server side.
\item All Transport Protocol Bindings supports transporting more than one S\+O\+M\+E/\+IP message in a Transport Layer P\+DU (i.\+e. U\+DP packet or T\+CP segment).
\end{DoxyItemize}

\paragraph*{2.\+2.\+1.\+1 U\+DP Binding}


\begin{DoxyItemize}
\item The U\+DP binding of S\+O\+M\+E/\+IP will be achieved by transporting S\+O\+M\+E/\+IP messages in U\+DP packets.
\item The header format allows transporting more than one S\+O\+M\+E/\+IP message in a single U\+DP packet. The S\+O\+M\+E/\+IP implementation identifies the end of a S\+O\+M\+E/\+IP message by means of the S\+O\+M\+E/\+IP length field. Based on the U\+DP length field, S\+O\+M\+E/\+IP determines if there are additional S\+O\+M\+E/\+IP messages in the U\+DP packet.
\end{DoxyItemize}

\paragraph*{2.\+2.\+1.\+2 T\+CP Binding}


\begin{DoxyItemize}
\item The T\+CP binding of S\+O\+M\+E/\+IP is based on the U\+DP binding. In contrast to the U\+DP binding, the T\+CP binding allows much bigger S\+O\+M\+E/\+IP messages and uses the robustness features of T\+CP (coping with loss, reorder, duplication, etc.).
\item When the T\+CP connection is lost, outstanding requests will be handled as timeouts. Since T\+CP handles reliability, additional means of reliability are not needed.
\item The client and server uses a single T\+CP connection for all methods, events, and notifications of a service instance. When having more than one instance of a service a T\+CP connection per services instance is needed.
\item The T\+CP connection will be opened by the client, when the first method call will be transported or the client tries to receive the first notifications. The client is responsible for re-\/establishing the T\+CP connection whenever it fails.
\item The T\+CP connection will be closed by the client, when the T\+CP connection is not required anymore.
\item The T\+CP connection will be closed by the client, when all Services using the T\+CP connections are not available anymore (stopped or timed out).
\item The server will not stop the T\+CP connection when stopping all services. Give the client enough time to process the control data to shutdown the T\+CP connection itself.
\end{DoxyItemize}

\paragraph*{2.\+2.\+1.\+3 Multiple Service-\/\+Instances}


\begin{DoxyItemize}
\item Service-\/\+Instances of the same Service are identified through different Instance I\+Ds. S\+O\+M\+E/\+IP supports multiple Service-\/\+Instances reside on different E\+C\+Us as well as multiple Service-\/\+Instances of one or more Services reside on one single E\+CU.
\item While different Services will be able to share the same port number of the transport layer protocol used, multiple Service-\/\+Instances of the same service on one single E\+CU listens on different ports per Service-\/\+Instance.
\item A Service Instance can be identified through the combination of the Service ID combined with the socket (i.\+e. I\+P-\/address, transport protocol (U\+D\+P/\+T\+CP), and port number).
\end{DoxyItemize}

\paragraph*{2.\+2.\+1.\+4 Transporting large S\+O\+M\+E/\+IP messages of U\+DP (S\+O\+M\+E/\+I\+P-\/\+TP)}


\begin{DoxyItemize}
\item The U\+DP binding of S\+O\+M\+E/\+IP can only transport S\+O\+M\+E/\+IP messages that fit directly into an IP packet. If larger S\+O\+M\+E/\+IP messages need to be transported over U\+DP (e.\+g. of 32 KB) the S\+O\+M\+E/\+IP Transport Protocol (S\+O\+M\+E/\+I\+P-\/\+TP) will be used. The S\+O\+M\+E/\+IP message too big to be transported directly with the U\+DP binding will be called \char`\"{}original\char`\"{} S\+O\+M\+E/\+IP message. The \char`\"{}pieces\char`\"{} of the original S\+O\+M\+E/\+IP message payload transported in S\+O\+M\+E/\+I\+P-\/\+TP messages will be called \char`\"{}segments\char`\"{}.
\item S\+O\+M\+E/\+IP messages using S\+O\+M\+E/\+I\+P-\/\+TP activates Session Handling (Session ID must be unique for the original message).
\item All S\+O\+M\+E/\+I\+P-\/\+TP segments carry the Session ID of the original message; thus, they have all the same Session-\/\+ID.
\item S\+O\+M\+E/\+I\+P-\/\+TP segments will have the T\+P-\/\+Flag of the Message Type set to 1.
\item S\+O\+M\+E-\/\+I\+P-\/\+T\+P-\/\+Header is as shown in below. S\+O\+M\+E/\+I\+P-\/\+TP segments will have a TP header right after the S\+O\+M\+E/\+IP header (i.\+e. before the S\+O\+M\+E/\+IP payload) with the following structure (bits from highest to lowest)\+:

{\bfseries a. Offset \mbox{[}28 bits\mbox{]}}

{\bfseries b. Reserved Flag \mbox{[}1 bit\mbox{]}}

{\bfseries c. Reserved Flag \mbox{[}1 bit\mbox{]}}

{\bfseries d. Reserved Flag \mbox{[}1 bit\mbox{]}}

{\bfseries e. More Segments Flag \mbox{[}1 bit\mbox{]}}
\end{DoxyItemize}

 \paragraph*{2.\+2.\+1.\+4.\+1 Example}


\begin{DoxyItemize}
\item This example describes how an original S\+O\+M\+E/\+IP message of 5880 bytes payload has to be transmitted. The Length field of this original S\+O\+M\+E/\+IP message is set to 8 + 5880 bytes. 
\item This original S\+O\+M\+E/\+IP message will now be segmented into 5 consecutive S\+O\+M\+E/\+IP segments. Every payload of these segments carries at most 1392 bytes in this example.
\item For these segments, the S\+O\+M\+E/\+IP TP module adds additional TP fields. The Length field of the S\+O\+M\+E/\+IP carries the overall length of the S\+O\+M\+E/\+IP segment including 8 bytes for the Request ID, Protocol Version, Interface Version, Message Type and Return Code. Because of the added TP fields (4 bytes), this Length information is extended by 4 additional S\+O\+M\+E/\+IP TP bytes.
\item The following figure provides an overview of the relevant S\+O\+M\+E/\+IP header settings for every S\+O\+M\+E/\+IP segment\+: 
\item Please note that the value provided within the Offset Field is given in units of 16 bytes, i.\+e.\+: The Offset Value of 87 correspond to 1392 bytes Payload.
\item The first 4 segments contain 1392 Payload bytes each with \char`\"{}\+More Segments Flag\char`\"{} set to ’1’\+: 
\item The last segment (i.\+e. 5) contains the remaining 312 Payload bytes of the original 5880 bytes payload. This last segment is marked with \char`\"{}\+More Segments flag\char`\"{} set to ’0’. 
\end{DoxyItemize}

\subsubsection*{2.\+2.\+2 Request/\+Response Communication}


\begin{DoxyItemize}
\item One of the most common communication patterns is the request/response pattern. One communication partner (Client) sends a request message, which is answered by another communication partner (Server). 
\item For the S\+O\+M\+E/\+IP request message the client has to do the following for payload and header\+:
\begin{DoxyItemize}
\item Construct the payload
\item Set the Message ID based on the method the client wants to call
\item Set the Length field to 8 bytes (for the part of the S\+O\+M\+E/\+IP header after the length field) + length of the serialized payload
\item Optionally set the Request ID to a unique number (unique for client only)
\item Set the Protocol Version according
\item Set the Interface Version according to the interface definition
\item Set the Message Type to R\+E\+Q\+U\+E\+ST (i.\+e. 0x00)
\item Set the Return Code to 0x00
\end{DoxyItemize}
\item The server builds the header of the response based on the header of the client’s request and does in addition\+:
\begin{DoxyItemize}
\item Construct the payload
\item Take over the Message ID from the corresponding request
\item Set the length to the 8 Bytes + new payload size
\item Take over the Request ID from the corresponding request
\item Set the Message Type to R\+E\+S\+P\+O\+N\+SE (i.\+e. 0x80) or E\+R\+R\+OR (i.\+e. 0x81)
\item Set Return Code to the return code of called method or in case of an Error message to a valid error code
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+2.\+3 Fire\&Forget Communication}


\begin{DoxyItemize}
\item Requests without response message are called fire\&forget. 
\item For the S\+O\+M\+E/\+IP request-\/no-\/return message the client has to do the following for payload and header\+:
\begin{DoxyItemize}
\item Construct the payload
\item Set the Message ID based on the method the client wants to call
\item Set the Length field to 8 bytes (for the part of the S\+O\+M\+E/\+IP header after the length field) + length of the serialized payload
\item Optionally set the Request ID to a unique number (unique for client only)
\item Set the Protocol Version according
\item Set the Interface Version according to the interface definition
\item Set the Message Type to R\+E\+Q\+U\+E\+S\+T\+\_\+\+N\+O\+\_\+\+R\+E\+T\+U\+RN (i.\+e. 0x01)
\item Set the Return Code to 0x00
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+2.\+4 Notification Events}


\begin{DoxyItemize}
\item Notifications describe a general Publish/\+Subscribe-\/\+Concept. Usually the server publishes a service to which a client subscribes. On certain cases the server will send the client an event, which could be for example an updated value or an event that occurred. 
\item S\+O\+M\+E/\+IP is used only for transporting the updated value and not for the publishing and subscription mechanisms. These mechanisms are implemented by S\+O\+M\+E/\+I\+P-\/\+SD.
\item For the S\+O\+M\+E/\+IP notification message the client has to do the following for payload and header\+:
\begin{DoxyItemize}
\item Construct the payload
\item Set the Message ID based on the event the server wants to send
\item Set the Length field to 8 bytes (for the part of the S\+O\+M\+E/\+IP header after the length field) + length of the serialized payload
\item Set the Client ID to 0x00. In case of active Session Handling the Session ID will be incremented upon each transmission.
\item Set the Protocol Version according
\item Set the Interface Version according to the interface definition
\item Set the Message Type to N\+O\+T\+I\+F\+I\+C\+A\+T\+I\+ON (i.\+e. 0x02)
\item Set the Return Code to 0x00
\end{DoxyItemize}
\end{DoxyItemize}

\paragraph*{2.\+2.\+4.\+1 Strategy for sending notifications}


\begin{DoxyItemize}
\item For different use cases different strategies for sending notifications are possible. The following examples are common\+:

{\bfseries a. Cyclic update} — send an updated value in a fixed interval (e.\+g. every 100 ms for safety relevant messages with Alive)

{\bfseries b. Update on change} — send an update as soon as a \char`\"{}value\char`\"{} changes (e.\+g. door open)

{\bfseries c. Epsilon change} — only send an update when the difference to the last value is greater than a certain epsilon. This concept may be adaptive, i.\+e. the prediction is based on a history; thus, only when the difference between prediction and current value is greater than epsilon an update is transmitted.
\end{DoxyItemize}

\subsubsection*{2.\+2.\+5 Fields}


\begin{DoxyItemize}
\item A field represents a status and has a valid value. The consumers subscribing for the field instantly after subscription get the field value as an initial event. 
\item A field is a combination of getter, setter and notification event.
\item The getter of a field is a request/response call that has an empty payload in the request message and the value of the field in the payload of the response message.
\item The setter of a field is a request/response call that has the desired value of the field in the payload of the request message and the value that was set to the field in the payload of the response message.
\item The notifier sends an event message that transports the value of the field to the client when the client subscribes to the field.
\end{DoxyItemize}

\subsubsection*{2.\+2.\+6 Error Handling}


\begin{DoxyItemize}
\item Error handling can be done in the application or the communication layer below. Therefore S\+O\+M\+E/\+IP supports two different mechanisms explained below\+:
\end{DoxyItemize}

\paragraph*{2.\+2.\+6.\+1 Error Handling Return Codes in the Response Messages of methods}


\begin{DoxyItemize}
\item Return Codes in the Response Messages of methods is used to transport application errors and the response data of a method from the provider to the caller of a method.
\end{DoxyItemize}



\paragraph*{2.\+2.\+6.\+2 Explicit Error Messages}


\begin{DoxyItemize}
\item Explicit Error Messages are used to transport application errors and the response data or generic S\+O\+M\+E/\+IP errors from the provider to the caller of a method.
\item If more detailed error information need to be transmitted, the payload of the Error Message (Message Type 0x81) will be filled with error specific data, e.\+g. an exception string. Error Messages will be sent instead of Response Messages.
\item This can be used to handle all different application errors that might occur in the server. In addition, problems with the communication medium or intermediate components (e.\+g. switches) may occur, which have to be handled e.\+g. by means of reliable transport.
\item For more flexible error handling, S\+O\+M\+E/\+IP allows a different message layout specific for Error Messages instead of using the message layout of Response Messages. The recommended layout for the exception message is the following\+: a. Union of specific exceptions. At least a generic exception without fields needs to exist. b. Dynamic Length String for exception description.
\item The union gives the flexibility to add new exceptions in the future in a typesafe manner. The string is used to transport human readable exception descriptions to ease testing and debugging.
\end{DoxyItemize}

\paragraph*{2.\+2.\+6.\+3 Error Processing Overview}

Error handling is based on the message type received (e.\+g. only methods can be answered with a return code) and will be checked in a defined order shown below.

 \hypertarget{adaptive_communicationmanagement_someip_service_discovery}{}\subsubsection{3. Service Discovery(\+S\+O\+M\+E/\+I\+P-\/\+S\+D)}\label{adaptive_communicationmanagement_someip_service_discovery}

\begin{DoxyItemize}
\item S\+O\+M\+E/\+I\+P-\/\+SD is used to
\begin{DoxyItemize}
\item Locate service instances.
\item Detect if service instances are running.
\item Implement the Publish/\+Subscribe handling.
\end{DoxyItemize}
\item S\+O\+M\+E/\+I\+P-\/\+SD depends on S\+O\+M\+E/\+IP. S\+O\+M\+E/\+IP itself supports both T\+CP and U\+DP communications but S\+O\+M\+E/\+IP SD uses S\+O\+M\+E/\+IP only over U\+DP
\end{DoxyItemize}

 \subsection*{3.\+1 S\+O\+M\+E/\+I\+P-\/\+SD Message Format}

We can divide the above mention figure into two parts.

\subsubsection*{3.\+1.\+1 S\+O\+M\+E/\+IP header}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Field() }&{\bf Description(\+Default Value)  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Field() }&{\bf Description(\+Default Value)  }\\\cline{1-2}
\endhead
Service-\/\+ID(16 bits) &0x\+F\+F\+FF \\\cline{1-2}
Method-\/\+ID(16 bits) &0x8100 \\\cline{1-2}
length(32 bits) &length is measured in bytes and starts with the first byte after the length field and ends with the last byte of the S\+O\+M\+E/\+I\+P-\/\+SD message. \\\cline{1-2}
Client-\/\+ID(16 bits) &Set to 0x0000 \\\cline{1-2}
Session-\/\+ID (16 Bits) &The Session-\/\+ID (S\+O\+M\+E/\+IP header) will be incremented for every S\+O\+M\+E/\+I\+P-\/\+SD message sent.\+The Session-\/\+ID (S\+O\+M\+E/\+IP header) starts with 1 and be 1 even after wrapping. \\\cline{1-2}
Protocol-\/ Version (8 Bits) &0x01 \\\cline{1-2}
Interface-\/ Version (8 Bits) &0x01 \\\cline{1-2}
Message Type (8 bits) &0x02 (Notification) \\\cline{1-2}
Return Code(8 bits) &Return Code(8 bits) \\\cline{1-2}
\end{longtabu}


\subsubsection*{3.\+1.\+2 S\+O\+M\+E/\+I\+P-\/\+SD Header}


\begin{DoxyItemize}
\item The S\+O\+M\+E/\+I\+P-\/\+SD Header starts with an 8 Bit field called Flags as shown in the Figure below. 
\item The Reboot Flag of the S\+O\+M\+E/\+I\+P-\/\+SD Header is set to 1 for all messages after reboot until the Session-\/\+ID in the S\+O\+M\+E/\+I\+P-\/\+Header wraps around and thus starts with 1 again. After this wrap around the Reboot Flag is set to 0.
\item The information for the reboot flag and the Session ID will be kept for multicast, unicast and every sender-\/receiver relation (i.\+e. source address and destination address) separately.
\item This means there will be separate counters for sending and receiving.
\item {\bfseries Sending}
\begin{DoxyItemize}
\item There will be a counter for multicast.
\item There will be a separate counter for each peer for unicast.
\end{DoxyItemize}
\item {\bfseries Receiving}
\begin{DoxyItemize}
\item There will be a counter for each peer for multicast.
\item There will be a counter for each peer for unicast.
\end{DoxyItemize}
\item The Unicast Flag of the S\+O\+M\+E/\+I\+P-\/\+SD Header is set to Unicast (that means 1) for all SD Messages since this means that receiving using unicast is supported.
\item The third flag of the S\+O\+M\+E/\+I\+P-\/\+SD Flags (third highest order bit) will be called Explicit Initial Data Control Flag and means that the E\+CU supports explicit initial data control.
\item After the S\+O\+M\+E/\+I\+P-\/\+SD Header the Entries Array follows. The entries will be processed exactly in the order they arrive.
\item After the Entries Array in the S\+O\+M\+E/\+I\+P-\/\+SD Header an Option Array will follow.
\end{DoxyItemize}

\paragraph*{3.\+1.\+2.\+1 Entry Format}


\begin{DoxyItemize}
\item The service discovery supports multiple entries that are combined in one service discovery message. The entries are used to synchronize the state of services instances and the Publish/\+Subscribe handling.
\item Two types of entries exist\+: A Service Entry Type for Services and an Eventgroup Entry Type for Eventgroups.
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+1.\+1 Service Entry Type for Services}


\begin{DoxyItemize}
\item Type Field \mbox{[}uint8\mbox{]}\+: encodes Find\+Service (0x00) and Offer\+Service (0x01).
\item Index First Option Run \mbox{[}uint8\mbox{]}\+: Index of this runs first option in the option array.
\item Index Second Option Run \mbox{[}uint8\mbox{]}\+: Index of this runs second option in the option array.
\item Number of Options 1 \mbox{[}uint4\mbox{]}\+: Describes the number of options the first option run uses.
\item Number of Options 2 \mbox{[}uint4\mbox{]}\+: Describes the number of options the second option run uses.
\item Service-\/\+ID \mbox{[}uint16\mbox{]}\+: Describes the Service ID of the Service or Service-\/\+Instance this entry is concerned with.
\item Instance ID \mbox{[}uint16\mbox{]}\+: Describes the Service Instance ID of the Service Instance this entry is concerned with or is set to 0x\+F\+F\+FF if all service instances of a service are meant.
\item Major Version \mbox{[}uint8\mbox{]}\+: Encodes the major version of the service (instance).
\item T\+TL \mbox{[}uint24\mbox{]}\+: Describes the lifetime of the entry in seconds.
\item Minor Version \mbox{[}uint32\mbox{]}\+: Encodes the minor version of the service.
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+1.\+2 Eventgroup Entry Type for Eventgroups}


\begin{DoxyItemize}
\item Type Field \mbox{[}uint8\mbox{]}\+: encodes Subscribe (0x06), and Subscribe\+Ack (0x07).
\item Index First Option Run \mbox{[}uint8\mbox{]}\+: Index of this runs first option in the option array.
\item Index Second Option Run \mbox{[}uint8\mbox{]}\+: Index of this runs second option in the option array.
\item Number of Options 1 \mbox{[}uint4\mbox{]}\+: Describes the number of options the first option run uses.
\item Number of Options 2 \mbox{[}uint4\mbox{]}\+: Describes the number of options the second option run uses.
\item Service-\/\+ID \mbox{[}uint16\mbox{]}\+: Describes the Service ID of the Service or Service Instance this entry is concerned with.
\item Instance ID \mbox{[}uint16\mbox{]}\+: Describes the Service Instance ID of the Service Instance this entry is concerned with or is set to 0x\+F\+F\+FF if all service instances of a service are meant.
\item Major Version \mbox{[}uint8\mbox{]}\+: Encodes the major version of the service instance this eventgroup is part of.
\item T\+TL \mbox{[}uint24\mbox{]}\+: Descibes the lifetime of the entry in seconds.
\item Reserved \mbox{[}uint8\mbox{]}\+: Set to 0x00.
\item Initial Data Requested Flag \mbox{[}1 bit\mbox{]} (I Flag)\+: Set to 1, if initial data will sent by Server
\item Reserved2 \mbox{[}uint3\mbox{]}\+: Set to 0x0.
\item Counter \mbox{[}uint4\mbox{]}\+: Is used to differentiate identical Subscribe Eventgroups of the same subscriber. Set to 0x0 if not used.
\item Eventgroup ID \mbox{[}uint16\mbox{]}\+: Transports the ID of an Eventgroup.
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+1.\+3 Referencing Options from Entries}


\begin{DoxyItemize}
\item Index First Option Run\+: Index into array of options for first option run. Index 0 means first of S\+O\+M\+E/\+I\+P-\/\+SD packet.
\item Index Second Option Run\+: Index into array of options for second option run. Index 0 means first of S\+O\+M\+E/\+I\+P-\/\+SD packet.
\item Number of Options 1\+: Length of first option run. Length 0 means no option in option run.
\item Number of Options 2\+: Length of second option run. Length 0 means no option in option run.
\item Two different option runs exist\+: First Option Run and Second Option Run. Two different types of options are expected\+: options common between multiple S\+O\+M\+E/\+I\+P-\/\+SD entries and options different for each S\+O\+M\+E/\+I\+P-\/\+SD entry. Supporting to different options runs is the most efficient way to support these two types of options, while keeping the wire format highly efficient.
\item Each option run will reference the first option and the number of options for this run.
\item If the number of options is set to zero, the option run is considered empty.
\item For empty runs the Index (i.\+e. Index First Option Run and/or Index Second Option Run) will set to zero.
\end{DoxyItemize}

\paragraph*{3.\+1.\+2.\+2 Options Format}


\begin{DoxyItemize}
\item Options are used to transport additional information to the entries. This includes for instance the information how a service instance is reachable (I\+P-\/\+Address, Transport Protocol, Port Number).
\item In order to identify the option type every option starts with\+:
\begin{DoxyItemize}
\item Length \mbox{[}uint16\mbox{]}\+: Specifies the length of the option in Bytes.
\item Type \mbox{[}uint8\mbox{]}\+: Specifying the type of the option.
\end{DoxyItemize}
\item The length field covers all bytes of the option except the length field and type field.
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+2.\+1 Configuration Option}


\begin{DoxyItemize}
\item The configuration option is used to transport arbitrary configuration strings. This allows to encode additional information like the name of a service or its configuration. 
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+2.\+2 Load Balancing Option}


\begin{DoxyItemize}
\item The Load Balancing option is used to prioritize different instances of a service, so that a client chooses the service instance based on these settings. This option will be attached to Offer Service entries.
\item The Load Balancing Option carry a Priority and Weight, which is used for load balancing different service instances. 
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+2.\+3 I\+Pv4 Endpoint Option}


\begin{DoxyItemize}
\item The I\+Pv4 Endpoint Option is used by a S\+O\+M\+E/\+I\+P-\/\+SD instance to signal the relevant endpoint(s).
\item Endpoints include the local IP address, the transport layer protocol (e.\+g. U\+DP or T\+CP), and the port number of the sender.
\item These ports are used for the events and notification events as well. 
\item This option is used by the server for its Offer\+Service entry and by client for Subscribe Eventgroup entry.
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+2.\+4 I\+Pv6 Endpoint Option}


\begin{DoxyItemize}
\item The I\+Pv6 Endpoint Option is used by a S\+O\+M\+E/\+I\+P-\/\+SD instance to signal the relevant endpoint(s).
\item Endpoints include the local IP address, the transport layer protocol (e.\+g. U\+DP or T\+CP), and the port number of the sender.
\item ports are used for the events and notification events as well.
\item This option is used by the server for its Offer\+Service entry and by client for Subscribe Eventgroup entry. 
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+2.\+5 I\+Pv4 Multicast Option}


\begin{DoxyItemize}
\item The I\+Pv4 Multicast Option is used by the server to announce the I\+Pv4 multicast address, the transport layer protocol (I\+S\+O/\+O\+SI layer 4), and the port number the multicast events and multicast notification events are sent to.
\item As transport layer protocol currently only U\+DP is supported.
\item The I\+Pv4 Multicast Option is referenced by Subscribe Eventgroup Ack entries.
\item The server reference the I\+Pv4 Multicast Option, which encodes the I\+Pv4 Multicast Address and Port Number the server will send multicast events and notification events to. 
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+2.\+6 I\+Pv6 Multicast Option}


\begin{DoxyItemize}
\item The I\+Pv6 Multicast Option is used by the server to announce the I\+Pv6 multicast address, the layer 4 protocol, and the port number the multicast events and multicast notifications events are sent to.
\item For the transport layer protocol (I\+S\+O/\+O\+SI layer 4) currently only U\+DP is supported.
\item The I\+Pv6 Multicast Option, referenced by Subscribe Eventgroup Ack messages.
\item The server references the I\+Pv6 Multicast Option, which encodes the I\+Pv6 Multicast Address and Port Number the server will send multicast events and notification events to. 
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+2.\+7 I\+Pv4 SD Endpoint Option}


\begin{DoxyItemize}
\item The I\+Pv4 SD Endpoint Option is used to transport the endpoint (i.\+e. I\+P-\/\+Address and Port) of the senders SD implementation.
\item This is used to identify the S\+O\+M\+E/\+I\+P-\/\+SD Instance even in cases in which the I\+P-\/\+Address and/or Port Number cannot be used.
\item A use case would be a proxy service discovery on one E\+CU which handles the multicast traffic for another E\+CU. 
\end{DoxyItemize}

\subparagraph*{3.\+1.\+2.\+2.\+8 I\+Pv6 SD Endpoint Option}


\begin{DoxyItemize}
\item The Ipv6 SD Endpoint Option is used to transport the endpoint (i.\+e. I\+P-\/\+Address and Port) of the senders SD implementation.
\item This is used to identify the S\+O\+M\+E/\+I\+P-\/\+SD Instance even in cases in which the I\+P-\/\+Address and/or Port Number cannot be used.
\item A use case would be a proxy service discovery on one E\+CU which handles the multicast traffic for another E\+CU. 
\item Example\+:Below Figure shows an example with the different Endpoint and a Multicast Option\+:
\item The Server offers the Service Instance on Server U\+D\+P-\/\+Endpoint SU and Server T\+C\+P-\/\+Endpoint ST
\item The Client sends a Subscribe Eventgroup entry with Client U\+D\+P-\/\+Endpoint CU (unicast) and a Client T\+C\+P-\/\+Endpoint CT. 
\end{DoxyItemize}

\subsubsection*{3.\+1.\+3 Service Entries}

\paragraph*{3.\+1.\+3.\+1 Find Service Entry}


\begin{DoxyItemize}
\item The Find Service entry type is used for finding service instances and will only be sent if the current state of a service is unknown.(no current Service Offer was received and is still valid).
\item Find Service entries sets the entry fields in the following way\+: \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Field }&{\bf Description(\+Default Value)  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Field }&{\bf Description(\+Default Value)  }\\\cline{1-2}
\endhead
Type &0x00 (Find\+Service) \\\cline{1-2}
Service ID &Set to the Service ID of the service \\\cline{1-2}
Instance ID &0x\+F\+F\+FF(all service instances) or Instance ID of a specific service instance \\\cline{1-2}
Major Version &0x\+FF \\\cline{1-2}
Minor Version &0x\+F\+F\+F\+F\+F\+F\+FF(services with any version will be returned) or set to a value different to 0x\+F\+F\+FF F\+F\+FF, services with this specific minor version will be returned only \\\cline{1-2}
T\+TL &Set to the lifetime of the Find Service entry. After this lifetime the Find Service entry is considered not existing. If T\+TL is set to 0x\+F\+F\+F\+F\+FF, the Find Service entry is considered valid until the next reboot. T\+TL will not be set to 0x000000 since this is considered to be the Stop Find Service Entry. \\\cline{1-2}
\end{longtabu}

\item Find the wireshark output for Find\+Service service below.
\item Consider IP address 192.\+168.\+7.\+4 for consumer application, 192.\+168.\+7.\+2 for producer application and 224.\+244.\+224.\+245 as a multicast address.
\end{DoxyItemize}

 \paragraph*{3.\+1.\+3.\+2 Offer Service Entry}


\begin{DoxyItemize}
\item The Offer Service entry type is used to offer a service to other communication partners.
\item Offer Service entries sets the entry fields in the following way\+: \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Field }&{\bf Description(\+Default Value)  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Field }&{\bf Description(\+Default Value)  }\\\cline{1-2}
\endhead
Type &0x01 (Offer\+Service) \\\cline{1-2}
Service ID &Set to the Service ID of the service instance offered. \\\cline{1-2}
Instance ID &Set to the Instance ID of the service instance that is offered \\\cline{1-2}
Major Version &Set to the Major Version of the service instance that is offered. \\\cline{1-2}
Minor Version &Set to the Minor Version of the service instance that is offered. \\\cline{1-2}
T\+TL &Set to the lifetime of the Offer Service entry. After this lifetime the Offer Service entry is considered not existing. If T\+TL is set to 0x\+F\+F\+F\+F\+FF, the Offer Service entry will be considered valid until the next reboot. T\+TL will not be set to 0x000000 since this is considered to be the Stop Offer Service Entry. \\\cline{1-2}
\end{longtabu}

\item Find the wireshark output for Offer\+Service service below.
\item Consider IP address 192.\+168.\+7.\+4 for consumer application, 192.\+168.\+7.\+2 for producer application and 224.\+244.\+224.\+245 as a multicast address.
\end{DoxyItemize}

 \subsubsection*{3.\+1.\+4 Eventgroup Entry}

\paragraph*{3.\+1.\+4.\+1 Subscribe Eventgroup Entry}


\begin{DoxyItemize}
\item The Subscribe Eventgroup entry type is used to subscribe to an eventgroup. \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Field }&{\bf Description(\+Default Value)  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Field }&{\bf Description(\+Default Value)  }\\\cline{1-2}
\endhead
Type &0x06 (Subscribe\+Eventgroup) \\\cline{1-2}
Service ID &set to the Service ID of the service instance that includes the eventgroup subscribed to. \\\cline{1-2}
Instance ID &set to the Instance ID of the service instance that includes the eventgroup subscribed to. \\\cline{1-2}
Major Version &set to the Major Version of the service instance of the eventgroup subscribed to. \\\cline{1-2}
Eventgroup ID &set to the Eventgroup ID of the eventgroup subscribed to. \\\cline{1-2}
Minor Version &set to the Minor Version of the service instance of the eventgroup subscribed to. \\\cline{1-2}
T\+TL &If set to 0x\+F\+F\+F\+F\+FF, the Subscribe Eventgroup entry considered as valid until the next reboot. T\+TL will not be set to 0x000000 since this is considered to be the Stop \\\cline{1-2}
Reserved &set to 0x00 \\\cline{1-2}
Initial Data Requested Flag &set to 1, if the client sends the first subscribe in sequence to trigger the sending of initial events. Set to 0 otherwise \\\cline{1-2}
Reserved2 &set to three 0 bits \\\cline{1-2}
Counter &used to differentiate between parallel subscribes to the same eventgroup of the same service (only difference in endpoint). If not used, set to 0x0. \\\cline{1-2}
\end{longtabu}

\end{DoxyItemize}

\paragraph*{3.\+1.\+4.\+2 Subscribe Eventgroup Acknowledgement (Subscribe Eventgroup Ack) Entry}


\begin{DoxyItemize}
\item The Subscribe Eventgroup Acknowledgment entry type is used to indicate that Subscribe Eventgroup entry was accepted.
\item Type\+: 0x07 (Subscribe\+Eventgroup\+Ack).
\item Service ID, Instance ID, Major Version, Eventgroup ID, Counter, and Reserved are same value as in the Subscribe that is being answered. 
\end{DoxyItemize}

\subsubsection*{3.\+1.\+5 Service Discovery Communication Behavior}


\begin{DoxyItemize}
\item S\+O\+M\+E/\+IP Service Discovery reduces the number of Service Discovery messages by packing entries together whenever possible.
\end{DoxyItemize}

\paragraph*{3.\+1.\+5.\+1 Startup Behavior}


\begin{DoxyItemize}
\item For each Service Instance or Eventgroup the Service Discovery have at least these three phases in regard to sending entries\+:
\begin{DoxyItemize}
\item Initial Wait Phase
\item Repetition Phase
\item Main Phase
\end{DoxyItemize}
\item The service discovery enters the Initial\+Wait Phase for a client service instance when the link on the interface needed for this service instance is up and the client service is requested by the application.
\item The service discovery enters the Initial Wait Phase for a server service instance when the link on the interface needed for this service instance is up and the server service is available.
\item The Service Discovery waits based on the I\+N\+I\+T\+I\+A\+L\+\_\+\+D\+E\+L\+AY after entering the Initial Wait Phase and before sending the first messages for the Service Instance.
\item I\+N\+I\+T\+I\+A\+L\+\_\+\+D\+E\+L\+AY defined as a minimum and a maximum delay.
\end{DoxyItemize}


\begin{DoxyCode}
1 <\textcolor{keywordtype}{INITIAL-DELAY-MAX-VALUE}>0.1</\textcolor{keywordtype}{INITIAL-DELAY-MAX-VALUE}>
2 <\textcolor{keywordtype}{INITIAL-DELAY-MIN-VALUE}>0.01</\textcolor{keywordtype}{INITIAL-DELAY-MIN-VALUE}>
\end{DoxyCode}

\begin{DoxyItemize}
\item The wait time will be determined by choosing a random value between the minimum and maximum of I\+N\+I\+T\+I\+A\+L\+\_\+\+D\+E\+L\+AY.
\item After sending the first message the Repetition Phase of this Service Instance/these Service Instances is entered.
\item The Service Discovery waits in the Repetitions Phase based on R\+E\+P\+E\+T\+I\+T\+I\+O\+N\+S\+\_\+\+B\+A\+S\+E\+\_\+\+D\+E\+L\+AY.
\item After each message sent in the Repetition Phase the delay is doubled.
\item The Service Discovery sends out only up to R\+E\+P\+E\+T\+I\+T\+I\+O\+N\+S\+\_\+\+M\+AX entries during the Repetition Phase.
\end{DoxyItemize}


\begin{DoxyCode}
1 <\textcolor{keywordtype}{INITIAL-REPETITIONS-BASE-DELAY}>0.2</\textcolor{keywordtype}{INITIAL-REPETITIONS-BASE-DELAY}>
2 <\textcolor{keywordtype}{INITIAL-REPETITIONS-MAX}>3</\textcolor{keywordtype}{INITIAL-REPETITIONS-MAX}>
\end{DoxyCode}

\begin{DoxyItemize}
\item After the Repetition Phase the Main Phase is being entered for a Service Instance.
\item After entering the Main Phase, the provider waits 1$\ast$\+C\+Y\+C\+L\+I\+C\+\_\+\+O\+F\+F\+E\+R\+\_\+\+D\+E\+L\+AY before sending the first offer entry message.
\item In the Main Phase Offer Messages is sent cyclically if a C\+Y\+C\+L\+I\+C\+\_\+\+O\+F\+F\+E\+R\+\_\+\+D\+E\+L\+AY is configured.
\item After a message for a specific Service Instance the Service Discovery waits for 1$\ast$\+C\+Y\+C\+L\+I\+C\+\_\+\+O\+F\+F\+E\+R\+\_\+\+D\+E\+L\+AY before sending the next message for this Service Instance. 
\begin{DoxyCode}
1 <\textcolor{keywordtype}{OFFER-CYCLIC-DELAY}>2.0</\textcolor{keywordtype}{OFFER-CYCLIC-DELAY}>
\end{DoxyCode}

\item Example\+:
\item A. Initial Wait Phase\+:
\begin{DoxyItemize}
\item 1. Wait for random\+\_\+delay in Range(\+I\+N\+I\+T\+I\+A\+L\+\_\+\+D\+E\+L\+A\+Y\+\_\+\+M\+I\+N, \+\_\+\+M\+A\+X)
\item 2. Send message (Find Service and Offer Service entries)
\end{DoxyItemize}
\item B. Repetition Phase (R\+E\+P\+E\+T\+I\+T\+I\+O\+N\+S\+\_\+\+B\+A\+S\+E\+\_\+\+D\+E\+L\+AY=100ms, R\+E\+P\+E\+T\+I\+T\+I\+O\+N\+S\+\_\+\+M\+AX=2)\+:
\begin{DoxyItemize}
\item 1. Wait 2$^\wedge$0 $\ast$ 100ms
\item Send message (Find Service and Offer Service entries)
\item Wait 2$^\wedge$1 $\ast$ 100ms
\item Send message (Find Service and Offer Service entries)
\end{DoxyItemize}
\item C. Main Phase (as long message is active and C\+Y\+C\+L\+I\+C\+\_\+\+O\+F\+F\+E\+R\+\_\+\+D\+E\+L\+AY is defined)\+:
\begin{DoxyItemize}
\item Wait C\+Y\+C\+L\+I\+C\+\_\+\+O\+F\+F\+E\+R\+\_\+\+D\+E\+L\+AY
\item Send message (Offer Service entries)
\end{DoxyItemize}
\end{DoxyItemize}

\paragraph*{3.\+1.\+5.\+2 Server Answer Behavior}


\begin{DoxyItemize}
\item The Service Discovery delay answers to entries that were received in multicast S\+O\+M\+E/\+I\+P-\/\+SD messages using the configuration item R\+E\+Q\+U\+E\+S\+T\+\_\+\+R\+E\+S\+P\+O\+N\+S\+E\+\_\+\+D\+E\+L\+AY.
\item The R\+E\+Q\+U\+E\+S\+T\+\_\+\+R\+E\+S\+P\+O\+N\+S\+E\+\_\+\+D\+E\+L\+AY will not apply if unicast messages are answered with unicast messages.
\item R\+E\+Q\+U\+E\+S\+T\+\_\+\+R\+E\+S\+P\+O\+N\+S\+E\+\_\+\+D\+E\+L\+AY will be specified by a minimum and a maximum.
\item The actual delay is randomly chosen between minimum and maximum of R\+E\+Q\+U\+E\+S\+T\+\_\+\+R\+E\+S\+P\+O\+N\+S\+E\+\_\+\+D\+E\+L\+AY. 
\begin{DoxyCode}
1 <\textcolor{keywordtype}{REQUEST-RESPONSE-DELAY}>
2   <\textcolor{keywordtype}{MAX-VALUE}>1.5</\textcolor{keywordtype}{MAX-VALUE}>
3   <\textcolor{keywordtype}{MIN-VALUE}>1.5</\textcolor{keywordtype}{MIN-VALUE}>
4 </\textcolor{keywordtype}{REQUEST-RESPONSE-DELAY}>
\end{DoxyCode}

\end{DoxyItemize}

\paragraph*{3.\+1.\+5.\+3 Shutdown Behavior}


\begin{DoxyItemize}
\item When a server service instance of an E\+CU is in the Repetition and Main Phase and is being stopped, a Stop Offer Service entry will be sent out.
\item When a server sends out a Stop Offer Service entry all subscriptions for this service instance get deleted on the server side.\textbackslash{}
\item When the whole E\+C\+Us is being shut down Stop Offer Service entries will be sent out for all service entries and Stop Subscribe Eventgroup entries for Eventgroups.
\item T\+T\+L(\+Time to live) \+: Describes the lifetime of the entry in seconds
\end{DoxyItemize}


\begin{DoxyCode}
1 <\textcolor{keywordtype}{SERVICE-OFFER-TIME-TO-LIVE}>10</\textcolor{keywordtype}{SERVICE-OFFER-TIME-TO-LIVE}>
\end{DoxyCode}
 \subsubsection*{3.\+1.\+6 Generation of vsomeip.\+json}


\begin{DoxyItemize}
\item In case of adaptive platform, vsomeip.\+json will get generated from system\+\_\+manifest.\+arxml file by using jsongen.\+py scripts.
\end{DoxyItemize}

\hypertarget{adaptive_communicationmanagement_aracom}{}\subsection{A\+RA Com A\+PI}\label{adaptive_communicationmanagement_aracom}

\begin{DoxyItemize}
\item Existing communication middleware A\+P\+I/technology are listed below\+:
\begin{DoxyItemize}
\item {\bfseries R\+O\+S(\+Robot Operating System) A\+PI}
\item {\bfseries D\+D\+S(\+Data Distribution Service) A\+PI}
\item {\bfseries Common\+A\+P\+I(\+G\+E\+N\+I\+V\+I)}
\item {\bfseries D\+A\+D\+DY A\+P\+I(\+Bosch)}
\end{DoxyItemize}
\item Decision to come up with a new and A\+U\+T\+O\+S\+A\+R-\/specific Communication Management A\+PI was due to the fact, that not all of the key requirements were met by existing solutions\+:
\begin{DoxyItemize}
\item Need for a Communication Management, which is N\+OT bound to a concrete network communication protocol. It has to support the S\+O\+M\+E/\+IP protocol along with the flexibility to exchange that.
\item The A\+U\+T\+O\+S\+AR service model, which defines services as a collection of provided methods, events and fields are supported naturally/straight forward.
\item The A\+PI supports an event-\/driven and a polling model to get access to communicated data equally . The latter is needed by real-\/time applications to avoid unnecessary context switches, while the former is much more convenient for applications without real-\/time requirements.
\item Possibility for seamless integration of end-\/to-\/end protection to fulfill A\+S\+IL requirements.
\item Support for static (preconfigured) and dynamic (runtime) selection of service instances to communicate with.
\end{DoxyItemize}
\end{DoxyItemize}

\begin{quote}
{\bfseries ara\+::com only defines the A\+PI signatures and its behaviour visible to the application developer. Providing an implementation of those A\+P\+Is and the underlying middleware transport layer is the responsibility of the A\+U\+T\+O\+S\+AR AP vendor.} \end{quote}


\section*{1. High Level A\+PI Structure}

\subsection*{1.\+1 Proxy/\+Skeleton Architecture}


\begin{DoxyItemize}
\item The basic idea of this pattern is, that from a formal service definition two code artifacts are generated\+: 
\begin{DoxyItemize}
\item {\bfseries Service Proxy}\+: This code is from the perspective of the service consumer, which wants to use a possibly remote service. Service proxy represents this service on code level.
\item {\bfseries Service Skeleton}\+: This code is from the perspective of the service implementation, which provides functionalities according to the service definition -\/ Connects the service implementation to the Communication Management transport layer, so that the service implementation can be contacted by distributed service consumers.
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{1.\+2 Datatype Abstractions}


\begin{DoxyItemize}
\item ara\+::com A\+PI introduces specific datatypes, which are used throughout its various interfaces. They can roughly be divided into the following classes\+:
\begin{DoxyItemize}
\item {\bfseries Pointer types\+:} for pointers to data transmitted via middleware
\item {\bfseries Collection types\+:} for collections of data transmitted via middleware
\item {\bfseries Types for async operation result management\+:} ara\+::com specific versions of C++ std\+::future and std\+::promise
\item {\bfseries Function wrappers\+:} for various application side callback or handler functions to be called by the middleware
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{1.\+3 Error Notification}


\begin{DoxyItemize}
\item ara\+::com A\+PI uses C++ exceptions to notify the user of the A\+PI about any errors occurred.
\end{DoxyItemize}

\subsubsection*{1.\+3.\+1 Checked Exceptions}


\begin{DoxyItemize}
\item Checked Exceptions within ara\+::com A\+PI can only occur in the context of a call of a service interface method
\end{DoxyItemize}

\subsubsection*{1.\+3.\+2 Unchecked Exceptions}


\begin{DoxyItemize}
\item Unchecked Exceptions within ara\+::com A\+PI can basically occur in the context of any ara\+::com A\+PI call and are fully ara\+::com implementation specific! A property of unchecked exceptions is, that programs/program artifacts hitting such an exception can typically not recover from it.
\end{DoxyItemize}

\section*{2. A\+PI Elements}


\begin{DoxyItemize}
\item A virtual service (interface) called "Radar\+Service is defined in the below example.
\end{DoxyItemize}


\begin{DoxyItemize}
\item So the example service Radar\+Service provides an event called “\+Brake\+Event”, which consists of a structure containing a flag and a variable length array of uint8 (as extra payload). A field “\+Update\+Rate”, which is of type uint32 (supports get and set calls) and methods Adjust, Calibrate and Log\+Current\+State.
\item Method “\+Adjust” is used to position the radar. It contains a target position as in-\/parameter and two out-\/parameters. One to signal the success of the positioning and other to report the final (maybe deviating) effective position. The method “\+Calibrate” is used to calibrate the radar. It contains a configuration string as in-\/parameter and returning a success indicator as an out-\/parameter. \char`\"{}\+Calibrate\char`\"{} method may raise two different application errors, in case of the calibration failure\+: “\+Calibration\+Failed” and “\+Invalid\+Config\+String”. The method “\+Log\+Current\+State” is a one way method, which means, no feedback is returned to the caller. It instructs the service Radar\+Service to output its current state into its local log files.
\end{DoxyItemize}

\subsection*{2.\+1 Common Types}

\subsubsection*{2.\+1.\+1 Optional data elements}


\begin{DoxyItemize}
\item The structure in below Figure has the optional declared elements \char`\"{}current and health\char`\"{}. These elements are not mandatorily present. The consuming application has to check whether the optional elements contain a value or not during runtime. Optional element contains a may or may not contain a value depends on the providing application. The providing application may or may not set the value for that specific instance. The feature of optional contained elements provide forward and backward compatibility of the service interface as new added record elements can just be ignored by old applications. \begin{DoxyVerb}struct BatteryState {
  Voltage_t voltage;
  Temperature_t temperature;
  ara::com::optional<Current_t> current;
  ara::com::optional<Health> health;
};
\end{DoxyVerb}

\end{DoxyItemize}

\subsubsection*{2.\+1.\+2 Instance Identifier}


\begin{DoxyItemize}
\item Instance identifiers are used within ara\+::com during following scenarios\+:
\begin{DoxyItemize}
\item On client/proxy side when a specific instance of a service will be searched for.
\item At the server/skeleton side when a specific instance of a service is created.
\end{DoxyItemize}
\item At ara\+::com A\+PI level the instance identifier is a technical binding specific identifier. The content of instance identifier are totally technology specific.
\item Example\+: S\+O\+M\+E/\+IP is using 16 bit unsigned integer, while D\+DS (D\+D\+S-\/\+R\+PC) uses string$<$256$>$ as service\+\_\+instance\+\_\+name.
\item Independant of the binding technology, instance identifier complying to a signature given below. 
\begin{DoxyCode}
  \textcolor{keyword}{class }InstanceIdentifier \{
  \textcolor{keyword}{public}:
  \textcolor{keyword}{static} \textcolor{keyword}{const} InstanceIdentifier Any;

  \textcolor{keyword}{explicit} InstanceIdentifier(std::string value);
  std::string toString() \textcolor{keyword}{const};
  \textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} InstanceIdentifier& other) \textcolor{keyword}{const};
  \textcolor{keywordtype}{bool} operator<(\textcolor{keyword}{const} InstanceIdentifier& other) \textcolor{keyword}{const};
  InstanceIdentifier& operator=(\textcolor{keyword}{const} InstanceIdentifier& other);

\};
\end{DoxyCode}

\item An ara\+:com provided functionality, which translates a logical local name used by the software developer in his realm into the technology/binding specific ara\+::com\+::\+Instance\+Identifier.
\item The local name from which the ara\+::com\+::\+Instance\+Identifier is constructed comes basically from A\+U\+T\+O\+S\+AR meta-\/model, describing your software component model.
\item The requirement for this local name(abstract identifier) is, that it is unambiguous within an executable. It has basically the form\+:
\end{DoxyItemize}


\begin{DoxyCode}
<context 0>::<context 1>::...::<context N>::<port name>
\end{DoxyCode}
 If the unambiguousness is ensured, the integrator/deployer can assign a dedicated technical binding with its specific instance ids to those abstract identifiers via a \char`\"{}manifest file\char`\"{}, which is specifically used for a distinct instantiation/execution of the executable.
\begin{DoxyItemize}
\item This explicitly allows, to start the same executable N times, each time with a different manifest, which maps the same abstract identifier differently.
\item The A\+PI ara\+:com provides, to do the translation from the abstract identifier (local name in the software developers realm) to the technical ara\+::com\+::\+Instance\+Identifier, is the following\+:
\end{DoxyItemize}


\begin{DoxyCode}
std::vector<InstanceIdentifier> ResolveInstanceIdentifiers(ara::meta::ModelIdentifier modelName);
\end{DoxyCode}

\begin{DoxyItemize}
\item A\+PI does return a list of ara\+::com\+::\+Instance\+Identifier
\item A\+U\+T\+O\+S\+AR supports, that the integrator may configure multiple technical bindings behind one abstract identifier visible to the software component developer.\+This feature is called multi-\/binding.
\item Using multi-\/binding on the skeleton/ server side is a common use case, since it simply allows different clients to use their preferred binding, when contacting the server.
\item On the Contrary using multi-\/binding on the proxy/client side is a rather exotic one. E.\+g. it could be used to support some failover approaches (if binding A does not work, fall back on binding B).
\item The possible returns for a call of Resolve\+Instance\+Identifiers() are\+:
\begin{DoxyItemize}
\item empty list\+: The integrator failed to provide a mapping for the abstract identifier. This most likely is a configuration error.
\item list with one element\+: The common case. No multi-\/binding.
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{2.\+2 Proxy Class}


\begin{DoxyItemize}
\item ara\+::com does standardization of the interface of the generated Proxy class. \begin{quote}
{\bfseries Note\+:The interfaces , Proxy class has to provide are defined by ara\+::com, a generic (product independent) generator could generate an abstract class or a mock class against which the application developer could implement the service consumer application. This perfectly suits the platform vendor independent development of Adaptive A\+U\+T\+O\+S\+AR S\+W\+Cs.} \end{quote}

\item ara\+::com expects proxy related artifacts inside a namespace \char`\"{}proxy\char`\"{}. This namespace is typically included in a namespace hierarchy deduced from the service definition and its context. 
\begin{DoxyCode}
\textcolor{keyword}{class }RadarServiceProxy \{
  \textcolor{keyword}{public}:
  \textcolor{comment}{/* }
\textcolor{comment}{   * brief Implementation is platform vendor specific}
\textcolor{comment}{   * A HandleType must contain the information that is needed to create a}
\textcolor{comment}{     proxy.}
\textcolor{comment}{   * This information will be hidden.}
\textcolor{comment}{   * Since the platform vendor is responsible for creation of handles, the}
\textcolor{comment}{   * ctor signature is not given as it is not of interest to the user.}
\textcolor{comment}{   */}

  \textcolor{keyword}{class }HandleType \{
  \textcolor{comment}{/*}
\textcolor{comment}{   * brief Two ServiceHandles are considered equal if they represent the}
\textcolor{comment}{     same service instance.}
\textcolor{comment}{   * param other}
\textcolor{comment}{   * return}
\textcolor{comment}{   */}
  \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} HandleType &other) \textcolor{keyword}{const};
  \textcolor{keyword}{const} ara::com::InstanceIdentifier &GetInstanceId() \textcolor{keyword}{const};
  \};

  \textcolor{comment}{/*}
\textcolor{comment}{   * StartFindService does not need an explicit version parameter as this}
\textcolor{comment}{     is internally available in ProxyClass}
\textcolor{comment}{   * That means only compatible services are returned.}
\textcolor{comment}{   *}
\textcolor{comment}{   * param handler this handler gets called any time the service}
\textcolor{comment}{     availability of the services matching the given}
\textcolor{comment}{   * instance criteria changes. If you use this variant of FindService,}
\textcolor{comment}{     the Communication Management has to}
\textcolor{comment}{   * continuously monitor the availability of the services and call the}
\textcolor{comment}{     handler on any change.}
\textcolor{comment}{   *}
\textcolor{comment}{   * param instance which instance of the service type defined by T will}
\textcolor{comment}{     be searched/found. Wildcards may be given.}
\textcolor{comment}{   * Default value is wildcard.}
\textcolor{comment}{   *}
\textcolor{comment}{   * return a handle for this search/find request, which will be used to }
\textcolor{comment}{     stop the availability monitoring and related}
\textcolor{comment}{   * firing of the given handler. (\(\backslash\)see StopFindService())}
\textcolor{comment}{   **/}
  \textcolor{keyword}{static} ara::com::FindServiceHandle StartFindService(
  ara::com::FindServiceHandler<RadarServiceProxy::HandleType> handler,
  ara::com::InstanceIdentifier instance =
  ara::com::InstanceIdentifier::Any);

  \textcolor{comment}{/*}
\textcolor{comment}{   * Method to stop finding service request (see above)}
\textcolor{comment}{   */}
  \textcolor{keyword}{static} \textcolor{keywordtype}{void} StopFindService(ara::com::FindServiceHandle handle);

  \textcolor{comment}{/*}
\textcolor{comment}{   * Opposed to StartFindService(handler, instance) this version is a "oneshot"}
\textcolor{comment}{     find request, which is}
\textcolor{comment}{   * - synchronous, i.e. it returns after the find has been done and a}
\textcolor{comment}{    result list of matching service instances is}
\textcolor{comment}{   * available. (list may be empty, if no matching service instances }
\textcolor{comment}{     currently exist)}
\textcolor{comment}{   * - does reflect the availability at the time of the method call. No}
\textcolor{comment}{    further (background) checks of availability}
\textcolor{comment}{   * are done.}
\textcolor{comment}{   *}
\textcolor{comment}{   * param instance which instance of the service type defined by T will}
\textcolor{comment}{     searched/found. Wildcards may be given.}
\textcolor{comment}{   * Default value is wildcard.}
\textcolor{comment}{   */}
  \textcolor{keyword}{static} ara::com::ServiceHandleContainer<RadarServiceProxy::HandleType>
  FindService(
  ara::com::InstanceIdentifier instance =
  ara::com::InstanceIdentifier::Any);

  \textcolor{comment}{/*}
\textcolor{comment}{   * brief The proxy can only be created using a specific handle which}
\textcolor{comment}{    identifies a service.}
\textcolor{comment}{   *}
\textcolor{comment}{   * This handle can be a known value which is defined at deployment or it }
\textcolor{comment}{     can be obtained using the ProxyClass::FindService method.}
\textcolor{comment}{   *}
\textcolor{comment}{   * param handle The identification of the service the proxy should represent.}
\textcolor{comment}{   */}
  \textcolor{keyword}{explicit} RadarServiceProxy(HandleType &handle);

  \textcolor{comment}{/*}
\textcolor{comment}{   * brief Public member for the BrakeEvent}
\textcolor{comment}{   */}
  events::BrakeEvent BrakeEvent;

  \textcolor{comment}{/*}
\textcolor{comment}{   * brief Public Field for UpdateRate}
\textcolor{comment}{   */}
  fields::UpdateRate UpdateRate;

  \textcolor{comment}{/*}
\textcolor{comment}{   * brief Public member for the Calibrate method}
\textcolor{comment}{   */}
  methods::Calibrate Calibrate;

  \textcolor{comment}{/*}
\textcolor{comment}{   * brief Public member for the Adjust method}
\textcolor{comment}{   */}
  methods::Adjust Adjust;

  \textcolor{comment}{/*}
\textcolor{comment}{   * brief Public member for the LogCurrentState fire-and-forget method}
\textcolor{comment}{   */}
  methods::LogCurrentState LogCurrentState;
\};
\end{DoxyCode}

\end{DoxyItemize}

\subsubsection*{2.\+2.\+1 Constructor and Handle Concept}


\begin{DoxyItemize}
\item As seen in the above code, ara\+::com prescribes the Proxy class to provide a constructor. This means, that the developer is responsible for creating a proxy instance to communicate with a possibly remote service. The ctor takes a parameter of type Radar\+Service\+Proxy\+::\+Handle\+Type — an inner class of the generated proxy class.
\item After the call to the ctor, there is proxy instance, which allows to communicate with the service. Therefore the handle has to contain the needed addressing information, so that the Communication Management binding implementation is able to contact the service.
\end{DoxyItemize}

\subsubsection*{2.\+2.\+2 Finding Services}


\begin{DoxyItemize}
\item The Proxy class provides class (static) methods to find service instances, which are compatible with the Proxy class.
\item Since the availability of service instances is dynamic by nature, as they have a life cycle, ara\+::com provides two different ways to do a ‘\+Find\+Service’ for convenience\+:
\begin{DoxyItemize}
\item Start\+Find\+Service is a class method, which starts a continuous ‘\+Find\+Service’ activity in the background, which notifies the caller via a given callback anytime the availability of instances of the service changes.
\item Find\+Service is a one-\/off call, which returns available instances at the point in time of the call.
\end{DoxyItemize}
\item Both of those methods have the instance parameter in common, which allows to either search for an explicit instance of the service or any instance (which is the default parameter value). The synchronous one-\/off variant Find\+Service returns a container of handles for the matching service instances, which might also be empty, if no matching service instance is currently available. Opposed to that, the Start\+Find\+Service returns a Find\+Service\+Handle, which can be used to stop the ongoing background activity of monitoring service instance availability via call to Stop\+Find\+Service. The first (and specific for this variant) parameter to Start\+Find\+Service is a user provided handler function with the following signature\+:
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{keyword}{using} FindServiceHandler = std::function<void(ServiceHandleContainer<T>)>;
\end{DoxyCode}


\paragraph*{2.\+2.\+2.\+1 Auto Update Proxy instance}


\begin{DoxyItemize}
\item Irrespective of the usage of one-\/off Find\+Service or the Start\+Find\+Service variant, in both cases a handle identifying the — possibly remote — service instance is received, from which proxy instance is created.
\item In the service based communication universe it is expected, that during the life time of the entire system (e.\+g. vehicle) service provider and consumer instances start up and go down frequently due to their own life cycle concepts. To deal with this, there is service discovery infrastructure, where the life cycle of service providers and consumers is monitored in terms of service offerings and service (re)subscriptions. If a service consumer application has instantiated a service proxy instance from a handle returned from some of the Find Service variants, the following sequence might possibly occur\+:
\end{DoxyItemize}


\begin{DoxyItemize}
\item Explanation of above figure\+:
\begin{DoxyItemize}
\item {\bfseries T0}\+: The service consumer may successfully call a service method of that proxy and Get\+Subscription\+State() on subscribed events will return k\+Subscribed.
\item {\bfseries T1}\+: The service instance goes down, correctly notified via service discovery.
\item {\bfseries T2}\+: A call of a service method on that proxy will lead to an exception, since the targeted service instance of the call does not exist anymore. Correspondingly Get\+Subscription\+State() on any subscribed event will return k\+Subscription\+Pending at this point even if the event has been successfully subscribed (k\+Subscribed) before.
\item {\bfseries T3}\+: The service instance comes up again, notified via service discovery infrastructure. The CM at the proxy side will be notified and will silently update the proxy object instance with a possibly changed transport layer addressing information.
\item {\bfseries T4}\+:Consequently service method calls on that proxy instance will succeed again and Get\+Subscription\+State() on events which the service consumer had subscribed before, will return k\+Subscribed again.
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+2.\+3 Events}


\begin{DoxyItemize}
\item For each event the remote service provides, the proxy class containing a member of a event specific wrapper class.
\item In the example the member has the name Brake\+Event and is of type events\+::\+Brake\+Event.
\item Below mentioned method gets generated for each event.
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Method }&{\bf Description  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Method }&{\bf Description  }\\\cline{1-2}
\endhead
void Subscribe(ara\+::com\+::\+Event\+Cache\+Update\+Policy policy, size\+\_\+t cache\+Size); &Used for subscription of events \\\cline{1-2}
ara\+::com\+::\+Subscription\+State Get\+Subscription\+State() const; &Query current subscription state \\\cline{1-2}
void Unsubscribe(); &Unsubscribe from the service \\\cline{1-2}
void Set\+Receive\+Handler(ara\+::com\+::\+Event\+Receive\+Handler handler); &Setting a receive handler signals the Communication Management implementation to use event style mode. \\\cline{1-2}
void Unset\+Receive\+Handler(); &Remove handler set by Set\+Receive\+Handler \\\cline{1-2}
void Set\+Subscription\+State\+Change\+Handler(ara\+::com\+:: Subscription\+State\+Change\+Handler handler); &Setting a subscription state change handler, which gets called by the Communication Management implementation as soon as the subscription state of this event has hanged. \\\cline{1-2}
void Unset\+Subscription\+State\+Change\+Handler(); &Remove handler set by Set\+Subscription\+State\+Change\+Handler \\\cline{1-2}
bool Update(ara\+::com\+::\+Filter\+Function$<$\+Sample\+Type$>$ filter = \{\}); &Fetch data from the Communication Management buffers and apply filter before writing the samples into the cache. \\\cline{1-2}
const ara\+::com\+::\+Sample\+Container$<$ara\+::com\+::\+Sample\+Ptr$<$const Sample\+Type$>$$>$ \& Get\+Cached\+Samples() const; &Get the container of the samples in the cache that was updated by the last call of upadate \\\cline{1-2}
void Cleanup(); &Explicitly clean the application local cache \\\cline{1-2}
\end{longtabu}



\begin{DoxyCode}
\textcolor{keyword}{class }BrakeEvent \{
   \textcolor{comment}{/*}
\textcolor{comment}{   * brief Shortcut for the events data type.}
\textcolor{comment}{   */}
   \textcolor{keyword}{using} SampleType = RadarObjects;

   \textcolor{comment}{/*}
\textcolor{comment}{   * brief The application expects the Communication Management to}
\textcolor{comment}{     subscribe the event.}
\textcolor{comment}{   *}
\textcolor{comment}{   * The Communication Management will try to subscribe and resubscribe}
\textcolor{comment}{     until \(\backslash\)see}
\textcolor{comment}{   * Unsubscribe() is called explicitly.}
\textcolor{comment}{   * The error handling will be kept within the Communication Management.}
\textcolor{comment}{   *}
\textcolor{comment}{   * The function return immediately. If the user wants to get notified,}
\textcolor{comment}{     when subscription has succeeded, he needs}
\textcolor{comment}{   * to register a handler via \(\backslash\)see SetSubscriptionStateChangeHandler().}
\textcolor{comment}{     This handler gets then called after}
\textcolor{comment}{   * subscription was successful.}
\textcolor{comment}{   *}
\textcolor{comment}{   * \(\backslash\)param policy Defines the update policy for the application local cache.}
\textcolor{comment}{   * \(\backslash\)param cacheSize Defines the size of the application local cache.}
\textcolor{comment}{   *}
\textcolor{comment}{   */}
   \textcolor{keywordtype}{void} Subscribe(ara::com::EventCacheUpdatePolicy policy, \textcolor{keywordtype}{size\_t} cacheSize);

   \textcolor{comment}{/*}
\textcolor{comment}{   * brief query current subscription state.}
\textcolor{comment}{   *}
\textcolor{comment}{   * \(\backslash\)return current state of the subscription.}
\textcolor{comment}{   */}
   ara::com::SubscriptionState GetSubscriptionState() \textcolor{keyword}{const};

   \textcolor{comment}{/*}
\textcolor{comment}{   * brief Unsubscribe from the service.}
\textcolor{comment}{   */}
   \textcolor{keywordtype}{void} Unsubscribe();

   \textcolor{comment}{/*}
\textcolor{comment}{   * Setting a receive handler signals the Communication Management }
\textcolor{comment}{     implementation to use event style mode.}
\textcolor{comment}{   * I.e. the registered handler gets called asynchronously by the}
\textcolor{comment}{     Communication Management as soon as new event data}
\textcolor{comment}{   * arrives for that event. If user wants to have strict polling behaviour,}
\textcolor{comment}{     where you decide when to check for}
\textcolor{comment}{   * new data via Update() he should NOT register a handler.}
\textcolor{comment}{   * Handler may be overwritten anytime during runtime.}
\textcolor{comment}{   *}
\textcolor{comment}{   * Provided Handler needs not to be re-entrant since the Communication}
\textcolor{comment}{     Management implementation has to serialize calls}
\textcolor{comment}{   * to the handler: Handler gets called once by the MW, when new events}
\textcolor{comment}{     arrived since the last call to Update().}
\textcolor{comment}{   * When application calls Update() again in the context of the receive}
\textcolor{comment}{     handler, MW must - in case new events arrived}
\textcolor{comment}{   * in the meantime - defer next call to receive handler until after the}
\textcolor{comment}{     previous call to receive handler has been}
\textcolor{comment}{   * completed.}
\textcolor{comment}{   *}
\textcolor{comment}{   **/}
   \textcolor{keywordtype}{void} SetReceiveHandler(ara::com::EventReceiveHandler handler);

   \textcolor{comment}{/*}
\textcolor{comment}{   * Remove handler set by SetReceiveHandler()}
\textcolor{comment}{   **/}
   \textcolor{keywordtype}{void} UnsetReceiveHandler();

   \textcolor{comment}{/*}
\textcolor{comment}{   * Setting a subscription state change handler, which gets called by}
\textcolor{comment}{     the Communication Management}
\textcolor{comment}{   * implementation as soon as the subscription state of this event has}
\textcolor{comment}{     changed.}
\textcolor{comment}{   * Communication Management implementation will serialize calls to the}
\textcolor{comment}{     registered handler. If multiple}
\textcolor{comment}{   * changes of the subscription state take place during the runtime of a}
\textcolor{comment}{     previous call to a handler, the}
\textcolor{comment}{   * Communication Management aggregates all changes to one call with the}
\textcolor{comment}{     last/effective state.}
\textcolor{comment}{   * Handler may be overwritten during runtime.}
\textcolor{comment}{   *}
\textcolor{comment}{   **/}
   \textcolor{keywordtype}{void}  SetSubscriptionStateChangeHandler(ara::com:: SubscriptionStateChangeHandler   handler);

   \textcolor{comment}{/*}
\textcolor{comment}{   * Remove handler set by SetSubscriptionStateChangeHandler()}
\textcolor{comment}{   **/}
   \textcolor{keywordtype}{void} UnsetSubscriptionStateChangeHandler();

   \textcolor{comment}{/*}
\textcolor{comment}{   * brief Fetch data from the Communication Management buffers and apply}
\textcolor{comment}{     filter before}
\textcolor{comment}{   * writing the samples into the cache.}
\textcolor{comment}{   *}
\textcolor{comment}{   * \(\backslash\)pre BrakeEvent::Subscribe has been called before (and not be}
\textcolor{comment}{     withdrawn by BrakeEvent::Unsubscribe)}
\textcolor{comment}{   *}
\textcolor{comment}{   * \(\backslash\)param filter}
\textcolor{comment}{   * parblock}
\textcolor{comment}{   * FilterFunction for the samples.}
\textcolor{comment}{   *}
\textcolor{comment}{   * This filter will be applied to the deserialized data within the}
\textcolor{comment}{     context of}
\textcolor{comment}{   * the update this function should return true if the sample will be}
\textcolor{comment}{     added to}
\textcolor{comment}{   * the cache.}
\textcolor{comment}{   * parblockend}
\textcolor{comment}{   *}
\textcolor{comment}{   * \(\backslash\)return True if new values received and those values are NOT ALL}
\textcolor{comment}{     filtered out,}
\textcolor{comment}{   * else false.}
\textcolor{comment}{   *}
\textcolor{comment}{   * \(\backslash\)note If precondition is not fulfilled, middleware impl might raise an}
\textcolor{comment}{     unchecked exception}
\textcolor{comment}{   * (e.g. NotSubscribed).}
\textcolor{comment}{   */}
   \textcolor{keywordtype}{bool} Update(ara::com::FilterFunction<SampleType> filter = \{\});
   \textcolor{comment}{/*}
\textcolor{comment}{   * brief Get the container of the samples in the cache that was updated}
\textcolor{comment}{     by the last call}
\textcolor{comment}{   * of \(\backslash\)see update.}
\textcolor{comment}{   *}
\textcolor{comment}{   * The container and referenced data is expected to be stable until}
\textcolor{comment}{     update is}
\textcolor{comment}{   * called again.}
\textcolor{comment}{   *}
\textcolor{comment}{   * \(\backslash\)return Container of SamplePtr}
\textcolor{comment}{   */}
   \textcolor{keyword}{const} ara::com::SampleContainer<ara::com::SamplePtr<const SampleType>> &
   GetCachedSamples() \textcolor{keyword}{const};
   \textcolor{comment}{/*}
\textcolor{comment}{   * brief Explicitly clean the application local cache.}
\textcolor{comment}{   *}
\textcolor{comment}{   * This should free the references to the data samples which are owned by}
\textcolor{comment}{     the}
\textcolor{comment}{   * Communication Management.}
\textcolor{comment}{   * This method only has an effect if policy in the call to \(\backslash\)see Subscribe}
\textcolor{comment}{     has been}
\textcolor{comment}{    * set to kNewestN!}
\textcolor{comment}{    */}
    \textcolor{keywordtype}{void} Cleanup();
 \};
\end{DoxyCode}
 \paragraph*{2.\+2.\+3.\+1 Event Subscription and Cache Semantics}


\begin{DoxyItemize}
\item The mere fact, that there exists a member of the event wrapper class inside the proxy instance does not mean, that the user gets instant access to events raised/sent out by service instance. First ‘subscribe’ for the event, in order to tell the Communication Management, that the application is now interested in receiving events. For that purpose the event wrapper class of ara\+::com provides below method\+:
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{comment}{/*}
\textcolor{comment}{ * brief The application expects the Communication Management to}
\textcolor{comment}{    subscribe the event.}
\textcolor{comment}{ *}
\textcolor{comment}{ * ....}
\textcolor{comment}{ *}
\textcolor{comment}{ * \(\backslash\)param policy Defines the update policy for the application local}
\textcolor{comment}{   cache.}
\textcolor{comment}{ * \(\backslash\)param cacheSize Defines the size of the application local cache.}
\textcolor{comment}{ *}
\textcolor{comment}{ */}
  \textcolor{keywordtype}{void} Subscribe(ara::com::EventCacheUpdatePolicy policy, \textcolor{keywordtype}{size\_t} cacheSize);
\end{DoxyCode}

\begin{DoxyItemize}
\item This method expects two parameters, policy and cache\+Size.
\end{DoxyItemize}

\subparagraph*{2.\+2.\+3.\+1.\+1 policy}


\begin{DoxyItemize}
\item With this parameter you control how the cache is updated if you call the Update method. Currently ara\+::com support two policies\+:
\item {\bfseries k\+LastN\+:} With this policy new available events are put in the cache by each call of Update. If they do not fit in the cache, older entries (oldest first) are displaced. With this policy the following applies\+: If the cache has been filled with a certain amount of events, the amount can only remain constant (if no new event has arrived) or get bigger with upcoming Update calls (if new events have been arrived).
\item {\bfseries k\+NewestN\+:} With this policy in each update the cache gets cleared and then filled with the newest arrived events. Even if NO event has arrived since the last call to Update, the cache gets cleared/emptied.
\end{DoxyItemize}

\subparagraph*{2.\+2.\+3.\+1.\+2 cache\+Size}


\begin{DoxyItemize}
\item With calling the method, you not only tell the Communication Management, that you now are interested in receiving event updates, but you are at the same time setting up a local cache for those events bound to the event wrapper instance with the given cache\+Size.
\item The idea behind this is very simple and possible uses are\+:
\begin{DoxyItemize}
\item {\bfseries stability}
\item {\bfseries interpolation/averaging between a number of events}
\item {\bfseries rate adoption}
\end{DoxyItemize}
\item Stability is realized with this concept by having an explicit method (see below) to update event data inside the cache. So this local cache decouples the event-\/wrapper instance from the Communication Management buffers into which the service instance may send its event updates! Updates of the cache status/content is only done explicitly by the user by calling Update.
\end{DoxyItemize}

\paragraph*{2.\+2.\+3.\+2 Monitoring Event Subscription}


\begin{DoxyItemize}
\item The call to the Subscribe method is asynchronous by nature. This means that at the point in time Subscribe returns, it is just the indication, that the Communication Management has accepted the order to care for subscription.
\item If the user needs to monitor the subscription state, he has two possibilities\+:
\begin{DoxyItemize}
\item {\bfseries Polling via Get\+Subscription\+State}
\item {\bfseries Registering a handler, which gets called, when the subscription state changes}
\end{DoxyItemize}
\end{DoxyItemize}

\subparagraph*{2.\+2.\+3.\+2.\+1 Polling via Get\+Subscription\+State}


\begin{DoxyItemize}
\item If the user — after having called Subscribe — wants to get feedback about the success of the subscription, he might call\+: 
\begin{DoxyCode}
\textcolor{comment}{/*}
\textcolor{comment}{ * brief query current subscription state.}
\textcolor{comment}{ *}
\textcolor{comment}{ * \(\backslash\)return current state of the subscription.}
\textcolor{comment}{ */}
ara::com::SubscriptionState GetSubscriptionState() \textcolor{keyword}{const};
\end{DoxyCode}

\end{DoxyItemize}

\subparagraph*{2.\+2.\+3.\+2.\+1 Registering a handler, which gets called, when the subscription state changes}


\begin{DoxyItemize}
\item User register a handler function, for subscription state changes. 
\begin{DoxyCode}
\textcolor{comment}{/*}
\textcolor{comment}{ * Setting a subscription state change handler, which gets called by}
\textcolor{comment}{   the Communication Management implementation as soon}
\textcolor{comment}{ * as the subscription state of this event has changed.}
\textcolor{comment}{ * Handler may be overwritten during runtime.}
\textcolor{comment}{ *}
\textcolor{comment}{ **/}
 \textcolor{keywordtype}{void} SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler);
\end{DoxyCode}

\item Anytime the subscription state changes, the Communication Management implementation calls the registered handler.
\end{DoxyItemize}

\paragraph*{2.\+2.\+3.\+3 Event-\/\+Driven vs Polling-\/\+Based access}


\begin{DoxyItemize}
\item {\bfseries Polling-\/\+Based access}
\begin{DoxyItemize}
\item An explicit interaction needed with ara\+::com A\+PI by calling Update to fill the local event wrapper specific cache\+: 
\begin{DoxyCode}
\textcolor{comment}{/*}
\textcolor{comment}{* brief Fetch data from the Communication Management buffers and apply filter before}
\textcolor{comment}{* writing the samples into the cache.}
\textcolor{comment}{*}
\textcolor{comment}{* \(\backslash\)pre BrakeEvent::Subscribe has been called before (and not be withdrawn by BrakeEvent::Unsubscribe)}
\textcolor{comment}{* \(\backslash\)param filter}
\textcolor{comment}{*  parblock}
\textcolor{comment}{* FilterFunction for the samples.}
\textcolor{comment}{*}
\textcolor{comment}{* This filter will be applied to the deserialized data within the context of}
\textcolor{comment}{* the update this function should return true if the sample is added to}
\textcolor{comment}{* the cache.}
\textcolor{comment}{* parblockend}
\textcolor{comment}{*}
\textcolor{comment}{* \(\backslash\)return True if new values received and those values are NOT ALL filtered out,}
\textcolor{comment}{* else false.}
\textcolor{comment}{*}
\textcolor{comment}{* \(\backslash\)note If precondition is not fulfilled, middleware impl might raise an unchecked exception}
\textcolor{comment}{* (e.g. NotSubscribed).}
\textcolor{comment}{*/}
\textcolor{keywordtype}{bool} Update(ara::com::FilterFunction<SampleType> filter = \{\});
\end{DoxyCode}

\item The method takes an optional parameter of a user defined filter function. 
\begin{DoxyCode}
\textcolor{keyword}{using} FilterFunction = std::function<bool(const S& sample)>;
\end{DoxyCode}

\item the user provided filter function gets an event (sample) and has to return true after checking, if he wants the sample to be put into the local cache.
\item During Update(), the Communication Management calls the filter function for each event, which has arrived since the last call to Update().
\item Update returns true in case new events have been placed into the local cache by the call, false otherwise.
\item After filling event specific local cache with event-\/data via Update() user typically want access those events. This is done with the following A\+PI\+: 
\begin{DoxyCode}
\textcolor{comment}{/*}
\textcolor{comment}{ * brief Get the container of the samples in the cache that was updated by the last call}
\textcolor{comment}{ * of \(\backslash\)see update.}
\textcolor{comment}{ *}
\textcolor{comment}{ * The container and referenced data is expected to be stable until update is}
\textcolor{comment}{ * called again.}
\textcolor{comment}{ *}
\textcolor{comment}{ * \(\backslash\)return Container of SamplePtr}
\textcolor{comment}{ */}
 \textcolor{keyword}{const} ara::com::SampleContainer<ara::com::SamplePtr<const SampleType>> &GetCachedSamples() \textcolor{keyword}{const};
\end{DoxyCode}

\item User can call this method as many times as you want — as long as user do not call Update() in between, the returned collection will always be the same/stable, even if the service side has send out several new events.
\end{DoxyItemize}
\item {\bfseries Event-\/\+Driven}
\item If user explicitly want the Communication Management to notify application thereby issuing asynchronous context switches to application process by below A\+PI.
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{keywordtype}{void} SetReceiveHandler(ara::com::EventReceiveHandler handler);
\end{DoxyCode}

\begin{DoxyItemize}
\item This A\+PI allows user to register a user defined callback, which the Communication Management has to call in case new event data is available since the last call to Update().
\end{DoxyItemize}

\paragraph*{2.\+2.\+3.\+4 Buffering Strategies}


\begin{DoxyItemize}
\item The following figure sketches a simple deployment, where we have a service providing an event, for which two different local adaptive S\+W\+Cs have subscribed through their respective ara\+::com proxies/event wrappers.
\item Both proxies have a local event cache. This is the cache, which gets filled via Update().
\item Service implementation sends its event data to a Communication Management buffer, which is apparently outside the process space of the service implementation
\end{DoxyItemize}


\begin{DoxyItemize}
\item This buffer is owned by kernel or it is realized as a shared memory between communicating proxies and skeleton or owned by a separate binding implementation specific ‘demon’ process.
\begin{DoxyItemize}
\item {\bfseries Kernel Space}
\item {\bfseries Shared Memory}
\item {\bfseries I\+P\+C-\/\+Demon Process}
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+2.\+4 Methods}


\begin{DoxyItemize}
\item For each method the remote service provides, the proxy class contains a member of a method specific wrapper class.
\item In our example, we have two methods and the corresponding members have the name Calibrate (of type methods\+::\+Calibrate) and Adjust (of type methods\+::\+Adjust).
\end{DoxyItemize}


\begin{DoxyItemize}
\item The return value of a call to a service method, which is not a “one-\/way method” is an ara\+::com\+::\+Future, where the template parameter is of the type of the inner struct, which aggregates all O\+U\+T-\/parameters of the method.
\end{DoxyItemize}

\paragraph*{2.\+2.\+4.\+1 One-\/\+Way or Fire-\/and-\/\+Forget Methods}


\begin{DoxyItemize}
\item ara\+::com supports a special flavor of a method, which we call “one-\/way” or “fire-\/and-\/forget”.
\item Technically this is a method with only I\+N-\/params — no O\+U\+T-\/params and no raising of errors allowed.
\item The client/caller therefore gets no feedback at all, whether the server/callee has processed a “one-\/way” call or not.
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{keyword}{class }LogCurrentState \{
  \textcolor{keyword}{public}:
  \textcolor{comment}{/*}
\textcolor{comment}{  * brief Operation will call the method.}
\textcolor{comment}{  *}
\textcolor{comment}{  * Using the operator the call will be made by the Communication Management.}
\textcolor{comment}{  * It is a one-way method, so no feedback (return value/out-parameter) is given.}
\textcolor{comment}{  */}
  \textcolor{keywordtype}{void} operator()();
\};
\end{DoxyCode}
 \paragraph*{2.\+2.\+4.\+2 Event-\/\+Driven vs Polling access to method results}

\subparagraph*{2.\+2.\+4.\+2.\+1 Event-\/\+Driven}


\begin{DoxyItemize}
\item Event-\/\+Driven means, that the caller of the method (the application with the proxy instance) gets notified by the Communication Management implementation as soon as the method call result has arrived.
\item Event driven method call can be achieve with following ways\+:
\begin{DoxyItemize}
\item {\bfseries 1.\+future.\+get()}
\item {\bfseries 2.\+wait(), wait\+\_\+for() or wait\+\_\+until()}
\item {\bfseries 3.\+Registering a callback method via then()}
\end{DoxyItemize}
\end{DoxyItemize}

\subparagraph*{2.\+2.\+4.\+2.\+2 Polling access}


\begin{DoxyItemize}
\item It is used in R\+T(real time) application.
\item ara\+::com\+::\+Future\+::is\+\_\+ready() is used to poll the method whether the method call has been finished.
\item After ara\+::com\+::\+Future\+::is\+\_\+ready() has returned true, it is guaranteed that the next call to ara\+::com\+::\+Future\+::get() will N\+OT block, but immediately return either the valid value or throw an exception in case of error
\end{DoxyItemize}

\paragraph*{2.\+2.\+4.\+3 Canceling Method Result}


\begin{DoxyItemize}
\item There may be cases, where you already have called a service method via the ()-\/ operator, which returned you an ara\+::com\+::\+Future, but you are not interested in the result anymore.
\item It could even be the case, that you already have registered a callback via ara\+::com\+::\+Future\+::then() for it. Instead of just let things go and ‘ignore’ the callback, you should tell the Communication Management explicitly.
\item This might free resources and avoid unnecessary processing load on the binding implementation level.
\item Telling that you are not interested in the method call result anymore is simply done by letting the ara\+::com\+::\+Future go out of scope, so that its destructor gets called.
\item Call of the dtor of the ara\+::com\+::\+Future is a signal to the binding implementation, that any registered callback for this future should not be called anymore, reserved/allocated memory for the method call result might be freed and event waiting mechanisms for the method result should be stopped.
\end{DoxyItemize}

\paragraph*{2.\+2.\+4.\+4 Checked Exception Handling}


\begin{DoxyItemize}
\item Unchecked Exceptions might be thrown by any ara\+::com A\+PI call, whereas Checked Exceptions might be thrown only in the context of non “one-\/way/fire-\/and-\/forget” service interface method calls.
\item There are two types of Checked Exceptions, which might be thrown in the course of a service method call on the proxy side\+:
\item Service\+Not\+Available\+Exception\+:This is a direct subclass of std\+::exception and will be thrown by the middleware implementation, when it detects during processing of a method call, that the providing service instance has already stopped offering the service.
\item Subclasses of ara\+::com\+::\+Application\+Error\+Exception\+:which are defined on meta-\/model level for a specific service interface method as Application\+Error and which are created at the application level service provider (skeleton) side and transported to the caller (proxy) side.
\item If one of those Checked Exception types happens, it will always be thrown in the context of the ara\+::com\+::\+Future\+::\+Get() call.
\item Calibrate method may raise the two application errors Calibration\+Failed and Invalid\+Config\+String, which get transformed to subclasses of ara\+::com\+::\+Application\+Error\+Exception on ara\+::com A\+PI level\+: 
\begin{DoxyCode}
 \textcolor{keyword}{using namespace }ara::com;
 \textcolor{keyword}{using namespace }com::mycompany::division::radarservice;

 Future<Calibrate::Output> calibrateFuture;

 \textcolor{keywordtype}{int} main() \{
 \textcolor{comment}{// some code to acquire handle}
 \textcolor{comment}{// ...}
 RadarServiceProxy service(handle);
 calibrateFuture = service.Calibrate(myConfigString);

 \textcolor{comment}{/* ....}
\textcolor{comment}{ Now we access the future (with potentially blocking) Get()}
\textcolor{comment}{ and directly handle the 3 different checked exceptions, which}
\textcolor{comment}{ might be raised. */}

 \textcolor{keywordflow}{try} \{
 calibrateFuture.Get();
 \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} ServiceNotAvailableException& e) \{
 \textcolor{comment}{// react on service shut down ...}
 cout << \textcolor{stringliteral}{"RadarService not available anymore"} << endl;
 ...
 \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} CalibrationFailed& e) \{
 \textcolor{comment}{// react on Application Error ’CalibrationFailed’ ...}
 cout << \textcolor{stringliteral}{"RadarService calibration failed because: "} << e.getFailureText() << endl;
 ...
 \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} InvalidConfigString& e) \{
 \textcolor{comment}{// react on Application Error ’InvalidConfigString’ ...}
 cout << \textcolor{stringliteral}{"Oops, we called RadarService.Calibrate with invalid config string: "} << e.getInvalidConfig() << 
      endl;
 cout << \textcolor{stringliteral}{"Current (valid) config is: "} << e.getCurrentValidConfig() << endl;
 ...
 \}

 \textcolor{comment}{// go on doing something ...}
 \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}

\end{DoxyItemize}

\subsubsection*{2.\+2.\+5 Fields}


\begin{DoxyItemize}
\item Conceptually a field has — unlike an event — a certain value at any time. That result in the following additions compared to an event\+:
\begin{DoxyItemize}
\item if a subscribtion to a field has been done, “immediately” initial values are sent back to the subscriber in an event-\/like notification pattern.
\item the current field value can be queried via a call to a Get() method or could be updated via a Set() method.
\end{DoxyItemize}
\item Field concept is roughly an aggregation of an event with correlated get()/set() methods.
\begin{DoxyItemize}
\item call Get() or Set() methods of the field with exactly the same mechanism as regular methods
\item access field update notifications in the form of events/event data, which are sent by the service instance our proxy is connected to with exactly the same mechanism as regular events
\end{DoxyItemize}
\end{DoxyItemize}

 \subsection*{2.\+3 Skeleton Class}


\begin{DoxyItemize}
\item The Skeleton class is generated from the service interface description of the A\+U\+T\+O\+S\+AR meta model.
\item ara\+::com does standardize the interface of the generated Skeleton class.
\item The toolchain of an AP product vendor will generate a Skeleton implementation class exactly implementing this interface.
\item The generated Skeleton class is an abstract class. It cannot be instantiated directly, because it does not contain implementations of the service methods, which the service should provide.
\item Therefore the service implementer has to subclass the skeleton and provide the service method implementation within the subclass. 
\end{DoxyItemize}

\subsubsection*{2.\+3.\+1 Instantiation}


\begin{DoxyItemize}
\item Skeleton class from which the service implementer has to subclass his service implementation provides a ctor with a parameter of type ara\+::com\+::\+Instance\+Identifier.
\item This identifier has to be unique — creating two instances in a way that they would exist at the same time with the same instance identifier will raise an exception.
\item If a new instance will be created with the same identifier, the existing instance needs to be destroyed before.
\end{DoxyItemize}

\subsubsection*{2.\+3.\+2 Offering Service instance}


\begin{DoxyItemize}
\item The skeleton provides the method Offer\+Service(). As application developer for the service provider side — have instantiated your custom service implementation class and initialized/set up your instance to a state, where it is now able to serve requests (method calls) and provide events to subscribing consumers, you will call this Offer\+Service() method on your instance.
\item If you decide at a certain point (maybe due to some state changes), that you do not want to provide the service anymore, you call Stop\+Offer\+Service() on your instance.
\end{DoxyItemize}

\subsubsection*{2.\+3.\+3 Polling and event-\/driven processing modes}


\begin{DoxyItemize}
\item The behavior of a skeleton instance is controlled by the second parameter of Skeleton class ctor, which is of type ara\+::com\+::\+Method\+Call\+Processing\+Mode.
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{comment}{/*}
\textcolor{comment}{* Request processing modes for the service implementation side}
\textcolor{comment}{* (skeleton).}
\textcolor{comment}{*}
\textcolor{comment}{* \(\backslash\)note Should be provided by platform vendor exactly like this.}
\textcolor{comment}{*/}
\textcolor{keyword}{enum class} MethodCallProcessingMode \{ kPoll, kEvent, kEventSingleThread \};
\end{DoxyCode}

\begin{DoxyItemize}
\item That means the processing mode is set for the entire service instance (i.\+e. all its provided methods are affected) and is fix for the whole lifetime of the skeleton instance. The default value in the ctor is set to k\+Event.
\end{DoxyItemize}

\paragraph*{2.\+3.\+3.\+1 Polling Mode}


\begin{DoxyItemize}
\item If you set it to k\+Poll, the Communication Management implementation will not call any of the provided service methods asynchronously! If you want to process the next (assume that there is a queue behind the scenes, where incoming service method calls are stored) pending service-\/call, you have to call the following method on your service instance\+:
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{comment}{/*}
\textcolor{comment}{* This fetches the next call from the Communication Management and executes it.}
\textcolor{comment}{* Only available in polling mode. In event mode it throws an exception.}
\textcolor{comment}{*/}
ara::com::Future<bool> ProcessNextMethodCall();
\end{DoxyCode}

\begin{DoxyItemize}
\item A simple use case for a typical RT application could be\+:
\begin{DoxyItemize}
\item RT application gets scheduled.
\item it calls Process\+Next\+Method\+Call and registers a callback with ara\+::com\+::\+Future\+::then()
\item the callback is invoked after the service method called by the midleware corresponding to the outstanding request has finished.
\item in the callback the RT application decides, if there is enough time left for serving a subsequent service method. If so, it calls another Process\+Next\+Method\+Call.
\end{DoxyItemize}
\end{DoxyItemize}

\paragraph*{2.\+3.\+3.\+2 Event-\/\+Driven Mode}


\begin{DoxyItemize}
\item If you set the processing mode to k\+Event or k\+Event\+Single\+Thread, the Communication Management implementation will dispatch events asynchronously to the service method implementations at the time the service call from the service consumer comes in.
\begin{DoxyItemize}
\item {\bfseries k\+Event\+:}
\begin{DoxyItemize}
\item Communication Management implementation may call the service method implementations concurrently.
\item If at the same point in time one call to method Calibrate and two calls to method Adjust arrive from different service consumers, the Communication Management implementation is allowed to take three threads from its internal thread-\/pool and do those three calls for the two service methods concurrently.
\end{DoxyItemize}
\item {\bfseries k\+Event\+Single\+Thread\+:}
\begin{DoxyItemize}
\item k\+Event\+Single\+Thread assures, that on the service instance only one service method at a time will be called by the Communication Management implementation.
\item That means, Communication Management implementation has to queue incoming service method call events for the same service instance and dispatch them one after the other.
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+3.\+4 Methods}


\begin{DoxyItemize}
\item Service methods on the skeleton side are abstract methods, which have to be overwritten by the service implementation sub-\/classing the skeleton.
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{comment}{/*}
\textcolor{comment}{* For all output and non-void return parameters}
\textcolor{comment}{* an enclosing struct is generated, which contains}
\textcolor{comment}{* non-void return value and/or out parameters.}
\textcolor{comment}{*/}
\textcolor{keyword}{struct }AdjustOutput \{
\textcolor{keywordtype}{bool} success;
Position effective\_position;
\};

\textcolor{keyword}{virtual} ara::com::Future<AdjustOutput> Adjust(
\textcolor{keyword}{const} Position& position) = 0;
\end{DoxyCode}

\begin{DoxyItemize}
\item The returned ara\+::com\+::\+Future contains a structure as template parameter, which aggregates all the O\+U\+T-\/parameters of the service call.
\end{DoxyItemize}

\paragraph*{2.\+3.\+4.\+1 Raising Application Errors}


\begin{DoxyItemize}
\item Whenever on the implementation side of a service method, an Application\+Error according to the interface description is detected, the Checked Exception representing this Application\+Error simply has to be stored into the Promise, from which the Future is returned to the caller\+:
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{keyword}{using namespace }ara::com;
\textcolor{keyword}{using namespace }com::mycompany::division::radarservice;

\textcolor{comment}{/* our implementation of RadarService */}
\textcolor{keyword}{class }RadarServiceImpl : \textcolor{keyword}{public} RadarServiceSkeleton \{

\textcolor{keyword}{public}:
Future<CalibrateOutput> Calibrate(\textcolor{keyword}{const} std::string& configuration)
\{
Promise<CalibrateOutput> promise;
\textcolor{keyword}{auto} future = promise.get\_future();

\textcolor{comment}{/* we check the given configuration arg */}
\textcolor{keywordflow}{if} (!checkConfigString(configuration)) \{
\textcolor{comment}{/* given arg is invalid: */}
InvalidConfigString myError(configuration, this->curValidConfig\_));
promise.set\_exception(std::make\_exception\_ptr(myError));
\} \textcolor{keywordflow}{else} \{
...
\}

\textcolor{comment}{/* we return a future with a potentially set exception */}
\textcolor{keywordflow}{return} future;
\}

\textcolor{keyword}{private}:
\textcolor{keywordtype}{bool} checkConfigString(\textcolor{keyword}{const} std::string& config);
std::string curValidConfig\_;
\}
\end{DoxyCode}



\begin{DoxyItemize}
\item In this example, the implementation of ‘\+Calibrate’ detects, that the given configuration string argument is invalid and sets the corresponding exception to the Promise.
\end{DoxyItemize}

\subsubsection*{2.\+3.\+5 Events}


\begin{DoxyItemize}
\item On the skeleton side the service implementation is in charge of notifying about occurrence of an event.
\item The event wrapper class on the skeleton/event provider side looks obviously different than on the proxy/event consumer side.
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{keyword}{class }BrakeEvent \{
\textcolor{keyword}{public}:

\textcolor{comment}{/*}
\textcolor{comment}{* Shortcut for the events data type.}
\textcolor{comment}{*/}
\textcolor{keyword}{using} SampleType = RadarObjects;

\textcolor{keywordtype}{void} Send(\textcolor{keyword}{const} SampleType &data);

ara::com::SampleAllocateePtr<SampleType> Allocate();
 \textcolor{comment}{/*}
\textcolor{comment}{ * After sending data you loose ownership and can’t access}
\textcolor{comment}{ * the data through the SampleAllocateePtr anymore.}
\textcolor{comment}{ * Implementation of SampleAllocateePtr will be with the}
\textcolor{comment}{ * semantics of std::unique\_ptr (see types.h)}
\textcolor{comment}{ **/}
 \textcolor{keywordtype}{void} Send(ara::com::SampleAllocateePtr<SampleType> data);

 \};
\end{DoxyCode}

\begin{DoxyItemize}
\item ara\+::com provides two different variants of a ‘\+Send’ method, which is used to send out new event data.
\end{DoxyItemize}
\begin{DoxyEnumerate}
\item The event data has been allocated somewhere by the service application developer and is given via reference to the binding implementation of Send(). After the call to send returns, the data might be removed/altered on the caller side. The binding implementation will make a copy in the call.
\item The second variant of ‘\+Send’ also has a parameter named ‘data’, but this is now of a different type ara\+::com\+::\+Sample\+Allocatee\+Ptr$<$\+Sample\+Type$>$. ara\+::com introduced here, will behave like a std\+::unique\+\_\+ptr$<$\+T$>$.\+Only one party can hold the pointer -\/ if the owner wants to give it away, he has to explicitly do it via std\+::move.
\item ara\+::com\+::\+Sample\+Allocatee\+Ptr$<$\+Sample\+Type$>$ Allocate();
\begin{DoxyItemize}
\item The event wrapper class provides us here with a method to allocate memory for one sample of event data.
\item It returns a smart pointer ara\+::com\+::\+Sample\+Allocatee\+Ptr$<$\+Sample\+Type$>$, which points to the allocated memory, where we then can write an event data sample to.
\end{DoxyItemize}
\end{DoxyEnumerate}

\subsubsection*{2.\+3.\+6 Fields}


\begin{DoxyItemize}
\item On the skeleton side the service implementation is in charge of
\begin{DoxyItemize}
\item updating and notifying about changes of the value of a field.
\item serving incoming Get() calls.
\item serving incoming Set() calls.
\end{DoxyItemize}
\item The field wrapper class on the skeleton/field provider side looks obviously different than on the proxy/field consumer side. 
\end{DoxyItemize}

\paragraph*{2.\+3.\+6.\+1 Registering Getters}


\begin{DoxyItemize}
\item The Register\+Get\+Handler method provides the possibility to register a method implementation by the service implementer, which gets then called by the binding implementation on an incoming Get() call from any proxy instance.
\item The Register\+Get\+Handler method in the generated skeleton does only exist in case availability of “field getter” has been configured for the field in the configuration.
\end{DoxyItemize}

\paragraph*{2.\+3.\+6.\+1 Registering Setters}


\begin{DoxyItemize}
\item Register\+Set\+Handler A\+PI has to be called by the service implementer in case field has been configured with setter support.
\end{DoxyItemize}

\section*{3 Service Discovery Implementation Strategies}


\begin{DoxyItemize}
\item As the service discovery functionality is basically defined at the A\+PI level with the methods for Find\+Service, Offer\+Service and Stop\+Offer\+Service.
\item When an AP node (more concretely an AP S\+WC) offers a service over the network or requires a service from another network node, then service discovery/service registry obviously takes place over the wire.
\item The protocol for service discovery over the wire needs to be completely specified by the used communication protocol.
\item if an ara\+::com application wants to communicate with another ara\+::com application on the same node within the AP of the same vendor there has to be a local variant of a service discovery available.
\end{DoxyItemize}

\subsection*{3.\+1 Central vs Distributed approach}

\subsubsection*{3.\+1.\+1 Central approach}


\begin{DoxyItemize}
\item This approach have one central entity(a demon process), which\+:
\begin{DoxyItemize}
\item maintains a registry of all service instances together with their location information
\item serves all Find\+Service, Offer\+Service and Stop\+Offer\+Service requests from local ara\+::com applications, thereby either updating the registry (Offer\+Service, Stop\+Offer\+Service) or querying the registry ( Find\+Service)
\item serves all S\+O\+M\+E/\+IP SD messages from the network either updating its registry (S\+O\+M\+E/\+IP Offer Service received) or querying the registry (S\+O\+M\+E/\+IP Find Service received) 
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{3.\+1.\+2 Distributed approach}


\begin{DoxyItemize}
\item This approach would be, to distribute the service registry information (availability and location information) among the ara\+::com applications within the node.\+So for the node local communication use case no prominent discovery demon would be needed. 
\end{DoxyItemize}

\subsection*{3.\+2 Multi-\/\+Binding implications}


\begin{DoxyItemize}
\item Multi-\/\+Binding describes the solution to support setups, where the technical transport/connection between different instances of a certain proxy class/skeleton class are different.
\begin{DoxyItemize}
\item proxy class uses different transport/\+I\+PC to communicate with different skeleton instances. Reason\+: Different service instances support different transport mechanisms because of deployment decisions.
\item symmetrically it may also be the case, that different proxy instances for the same skeleton instance uses different transport/\+I\+PC to communicate with this instance\+: The skeleton instance supports multiple transport mechanisms to get contacted.
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{3.\+2.\+1 Simple Multi-\/\+Binding use case}


\begin{DoxyItemize}
\item The following figure depicts an obvious and/or rather simple case. In this example, which only deals with node local (inside one AP product/\+E\+CU) communication between service consumers (proxy) and service providers (skeleton), there are two instances of the same proxy class on the service consumer side.
\item Service consumer application has triggered a ‘\+Find\+Service’ first, which returned two handles for two different service instances of the searched service type.
\item The service consumer application has instantiated a proxy instance for each of those handles.
\item Now in this example the instance 1 of the service is located inside the same adaptive application (same process/address space) as the service consumer (proxy instance 1), while the service instance 2 is located in a different adaptive application (different process/ address space). 
\end{DoxyItemize}

\subsubsection*{3.\+2.\+2 Local/\+Network Multi-\/\+Binding use case}


\begin{DoxyItemize}
\item After we have seen a special variant of Multi-\/\+Binding in the preceding section, we now look at a variant, which can also be considered as being a real-\/world case.
\item The instance 2 of the service is located on a different E\+CU attached to the same Ethernet network as our E\+CU with the AP product, where the service consumer (with its proxies for instance 1 and 2) resides.
\item As the standard protocol on Ethernet for AP is S\+O\+M\+E/\+IP, it is expected, that the communication between both E\+C\+Us is based on S\+O\+M\+E/\+IP.
\item For our concrete example this means, that proxy 1 talks to service 1 via unix domain sockets (which might be optimized for process local communication to direct method calls), while the proxy 2 talks to service 2 via network sockets in a S\+O\+M\+E/\+IP compliant message format. 
\end{DoxyItemize}

\subsubsection*{3.\+2.\+3 Typical S\+O\+M\+E/\+IP Multi-\/\+Binding use case}


\begin{DoxyItemize}
\item It is highly unlikely that an adaptive S\+WC (i.\+e. the language and network binding which runs in its context) opens socket connections itself to communicate with a remote service.
\item S\+O\+M\+E/\+IP was explicitly designed to use as few ports as possible.
\item The reason for that requirement comes from low power/low resources embedded E\+C\+Us\+:
\item Managing a huge amount of IP sockets in parallel means huge costs in terms of memory (and runtime) resources.
\item A\+U\+T\+O\+S\+AR CP siblings which will be main communication partner in an inside vehicle network demand this approach, which is uncommon, compared to non-\/automotive IT usage pattern for ports.
\item The entire S\+O\+M\+E/\+IP traffic of an E\+CU / network endpoint is routed through one IP port!
\item That means S\+O\+M\+E/\+IP messages originating from/dispatched to many different local applications (service providers or service consumers) are (de)multiplexed to/from one socket connection.
\item P\+O\+S\+IX compatible OS with P\+O\+S\+IX socket A\+PI, multiplexing S\+O\+M\+E/\+IP communication of many applications to/from one port means the introduction of a separate/central (demon) process, which manages the corresponding port.
\item The task of this process is to bridge between S\+O\+M\+E/\+IP network communication and local communication and vice versa. 
\end{DoxyItemize}

\section*{4 ara\+::com and A\+U\+T\+O\+S\+AR meta-\/model relationship}

\subsection*{4.\+1 Service Interface}


\begin{DoxyItemize}
\item Service Interface defines everything signaturewise of an ara\+::com proxy or skeleton.
\item The Service\+Interface describes the methods, fields and the methods a service interface consists of and how the signatures of those elements (arguments and data types) look like.
\item ara\+::com proxy and skeleton classes get generated from Service\+Interface.
\end{DoxyItemize}

\subsection*{4.\+2 Software Component}


\begin{DoxyItemize}
\item The idea of a software component is to describe a reusable part of software with well defined interfaces.
\item A\+U\+T\+O\+S\+AR manifest specification defines a model element Software\+Component\+Type, which is an abstract element with several concrete subtypes, of which the subtype Adaptive\+Application\+Sw\+Component\+Type is the most important one for Adaptive Application software developers. 
\item Software\+Component\+Types A and B from the example in the upper part (meta-\/model level) a concrete implementation exists on implementation level (lower part in the figure).
\item The realization/implementation of R-\/\+Port of Software\+Component\+Type A is based on an instance of ara\+::com proxy class on implementation level, while the P-\/\+Port implementation of Software\+Component\+Type B is using an instance of ara\+::com skeleton class.
\item Proxy and skeleton class are generated from the service interface definition Service\+Interface, which is referenced by the corresponding ports.
\item Such a code fragment, which realizes a Software\+Component\+Type can obviously be re-\/used. On C++ implementation level an implementation of an Adaptive\+Application\+Sw\+Component\+Type typically boils down to one or several C++ classes. So re-\/use simply means instantiating this class/those classes in different contexts multiple times. 
\item The figure above shows an arbitrary example, where the implementations of A and B are instantiated in different contexts. On the lower left side there is an Executable 1, which directly uses two instances of As impl and one instance of Bs impl.
\item Opposed to that, the right side shows an Executable 2, which \char`\"{}directly\char`\"{} (i.\+e. on its top most level) uses one instance of Bs impl and an instance of a composite software component, which itself \char`\"{}in its body\char`\"{} again instantiates one instance of As and Bs impl.
\item This natural implementation concept of composing software components from other components to a bigger/composite artefact is fully reflected in the A\+U\+T\+O\+S\+AR meta-\/model in the form of a Composition\+Sw\+Component\+Type, which itself is a Software\+Component\+Type and allows arbitrary recursive nesting/compositing of software components.
\end{DoxyItemize}

\subsection*{4.\+3 Adaptive Application/\+Executables and Processes}


\begin{DoxyItemize}
\item Deployable software units within AP are so called Adaptive Applications (the corresponding meta-\/model element is Adaptive\+Autosar\+Application).
\item Such an Adaptive Application consists of 1..n executeables. 
\item Abstract identifiers relate in a certain way to the corresponding port in the model of the Software\+Component\+Type.
\item Instance I\+Ds obviously have to be assigned to objects, which finally have a distinct identity in an deployment. 
\end{DoxyItemize}

\subsection*{4.\+4 Usage of meta-\/model identifiers within ara\+::com based application code}


\begin{DoxyItemize}
\item The abstract identifiers relate in a certain way to the corresponding port in the model of the Software\+Component\+Type.
\item Port name of the model alone isn’t sufficient to clearly identify it in its final instantiation, where the same component implementation might be instantiated multiple times in the code and then eventually started multiple times in different processes.
\item Instance I\+Ds obviously have to be assigned to objects, which finally have a distinct identity in an deployment. 
\item The figure above shows, within Executable 2 there are three instantiations of Software\+Component\+Type B implementation in different contexts (nesting levels).All instances do provide a specific instance of SI Radar\+Service.
\item The integrator, who applies the Service Instance Manifest for Process 2 has to do the technical mapping on ara\+::com level. I.\+e. he has to decide, which technical transport binding is to be used in each of the B instantiations and subsequently also, which technical transport binding specific instance ID.
\item In our example, the integrator wants to provide the SI Radar\+Service via S\+O\+M\+E/\+IP binding and an S\+O\+M\+E/\+IP specific instance ID \char`\"{}1\char`\"{} in the context of the B instantiation, which is nested inside the composite component on the right side, while he decides to provide the SI Radar\+Service via local I\+PC (Unix domain socket) binding and a Unix domain socket specific instance ID \char`\"{}/tmp/\+Radar/3\char`\"{} and \char`\"{}/tmp/\+Radar/4\char`\"{} in the context of the B instantiations on the left side, which are not nested.
\item Within the Service Instance Manifest, which allows to specify the mapping of port instantiations within a Process to technical bindings and their concrete instance I\+Ds, the sole usage of the port name from the model isn’t sufficient to differentiate.
\item To get unique identifiers within an executable (and therefore a process), the nature of nested instantiation and re-\/use of Software\+Component\+Types has to be considered. Every time a Software\+Component\+Type gets instantiated, its instantiation gets a unique name within its instantiation context.
\item In our example this means\+:
\begin{DoxyItemize}
\item B instantiations on top level get unique names on their level\+: \char`\"{}\+B\+\_\+\+Inst\+\_\+1\char`\"{} and \char`\"{}\+B\+\_\+\+Inst\+\_\+2\char`\"{}
\item B instantiation within the Composite Component Type gets unique name on this level\+: \char`\"{}\+B\+\_\+\+Inst\+\_\+1\char`\"{}
\item Composite Component instantiation on top level gets unique name on its level\+: \char`\"{}\+Comp\+\_\+\+Inst\+\_\+1\char`\"{}
\item From the perspective of the executable/process, we therefore have unique identifiers for all instances of B\+:
\begin{DoxyItemize}
\item \char`\"{}\+B\+\_\+\+Inst\+\_\+1\char`\"{}
\item \char`\"{}\+B\+\_\+\+Inst\+\_\+2\char`\"{}
\item \char`\"{}\+Comp\+\_\+\+Inst\+\_\+1\+::\+B\+\_\+\+Inst\+\_\+1\char`\"{}
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}

\section*{5. Serialization}


\begin{DoxyItemize}
\item Serialization is the process of transforming certain data structures into a standardized format for exchange between a sender and a (possibly different) receiver.
\item When putting data on the wire and reading it back, receiver have to follow exact, agreed-\/on rules to be able to correctly interpret the data on the receiver side.
\item For Adaptive Platform, the loading of executables during runtime, which have been built independently at different times and have been uploaded to an AP E\+CU at different times, is definitely a supported use case. The chance, that compiler settings for different ara\+::com applications were different regarding alignment decisions is consequently high. Therefore an AP product (more concrete its I\+PC binding implementation) has to use/support serialization of exchanged event/field/method data.
\end{DoxyItemize}

\subsection*{5.\+1 Zero-\/\+Copy implications}


\begin{DoxyItemize}
\item One thing which typically is at the top of the list of performance optimizations in I\+P\+C/middleware implementations is the avoidance of unnecessary copies between sender and the receiver of data.
\item When we talk about AP, where we have architectural expectations like applications running in separate processes providing memory protection, the typical communication approach needs at least O\+NE copy of the data from source address space to target address space.
\item Highly optimizing middleware/\+I\+PC implementations could even get rid of this single copy step by setting up shared memory regions between communicating ara\+::com components(sender and receiver). 
\end{DoxyItemize}\hypertarget{adaptive_communicationmanagement_ararest}{}\subsection{A\+RA R\+E\+ST}\label{adaptive_communicationmanagement_ararest}
\subsection*{1. What is R\+E\+ST ?}

R\+Epresentational State Transfer (R\+E\+ST) is a stateless client-\/server architecture in which the web services are viewed as resources offered by server and can be identified by their U\+R\+Is. Web service clients that want to use these resources access via globally defined set of remote methods like G\+ET, P\+UT etc, that describe the action to be performed on the resource. It consists of two components R\+E\+ST server which provides access to the resources and a R\+E\+ST client which accesses and modify the R\+E\+ST resources. In the R\+E\+ST architecture style, clients and servers exchange representations of resources by using a standardized interface and protocol.\+R\+E\+ST isn’t protocol specific, but R\+E\+ST works over H\+T\+TP. The response from server is considered as the representation of the resources. This representation can be generated from one resource or more number of resources. It enables web applications that are built on various programming languages to communicate with each other. With the help of Restful services, these web applications can reside on different environments, some could be on Windows, and others could be on Linux. 
\begin{DoxyItemize}
\item R\+E\+ST is Representational State Transfer (R\+E\+ST) architectural style.
\item Architecture style for networked systems, it is not a protocol nor a standard.
\item Relies on other standards like H\+T\+TP, J\+S\+ON, etc.
\item Protocol, language and platform independent which makes it very flexible.
\item Client-\/\+Server architecture just like the web.
\item With R\+E\+ST, networked components are a resource you request access to whose implementation details are unclear.
\end{DoxyItemize}

\subsection*{1.\+1 Key Properties of R\+E\+ST A\+PI}


\begin{DoxyItemize}
\item {\bfseries Client-\/\+Server \+:}
\begin{DoxyItemize}
\item The client-\/server architecture is a fairly well-\/known and widely used architecture. Most network based applications work in this manner.
\item The architecture consists of a server that acts as a central point where one or many clients may interact.
\item The idea behind a client-\/server architecture is that the server does the heavy lifting and orchestration required, whilst the client consumes the rich data and functionality by interacting with the server.
\item When these computers communicate with each other, there’s a clear need for a common protocol that is understood and supported by both parties.
\item The commonality required is the message format. By separating the user interface concerns from the data storage concerns, the portability of the user interface across multiple platforms is improved and also improve the scalibilty by simplifying the server components.
\item The separation also allows the components to evolve independently. 
\end{DoxyItemize}
\item {\bfseries Stateless \+:}
\begin{DoxyItemize}
\item A vast majority of web applications make use of a server-\/side managed session to keep track of a specific client.
\item These sessions are often used for auth (authentication and authorization), keeping track of context, and storing meta data in memory that may be useful for managing the user’s activity.
\item This makes scaling difficult as additional technologies and development is required to create session management servers in a clustered environment.
\item The stateless architecture removes the need for the server to create and hold sessions.
\item In a stateless architecture, Communication must be stateless in nature, such that each request from client to server must contain all of the information necessary to understand the request and cannot take advantage of any stored context on the server.
\item The disadvantage is that it may decrease network performance by increasing the repetitive data sent in a series of request. 
\end{DoxyItemize}
\item {\bfseries Cache \+:}
\begin{DoxyItemize}
\item In order to improve network efficiency, we add cache constraints to form the client-\/cache-\/stateless-\/server.
\item The cacheable architecture is the concept of cleverly caching data that is used often, and changed infrequently.
\item Caching may occur in places like the client browser, and a caching server.
\item Caching mechanisms are expected to be smart enough to serve cached data or resources until that piece of data or resource changes for the client requesting it.
\item One of the advantages of caching is a reduced load on the network, this translates to reduction of unnecessary requests, lower data usage, and a more optimal performing application. 
\end{DoxyItemize}
\item {\bfseries Uniform Interface \+:}
\begin{DoxyItemize}
\item The concept of a uniform interface includes creating a standard method of interacting with a system.
\item The uniform interface architecture also promotes abstraction of the implementation from the interface definition.
\item This allows for clients to interact with all services in the same way, using a standard protocol and message format with a well defined set of operations.
\item The central feature that distinguishes the R\+E\+ST architectural style from other network-\/based styles is its emphasis on a uniform interface between components
\item Implementations are decoupled from the services they provide, which encourages independent evolvability.
\item The trade-\/off, though, is that a uniform interface degrades efficiency, since information is transferred in a standardized form rather than one which is specific to an application\textquotesingle{}s needs. 
\end{DoxyItemize}
\item {\bfseries Layered System \+:}
\begin{DoxyItemize}
\item The layered architecture is utilised for a number of different factors.
\item A layered approach allows developers to separate concerns and loosely couple components that interact with each other.
\item The advantage of this approach when implemented optimally is that layers may change independently without impacting the rest of the application.
\item There are also cases where a layered architecture may consist of a layer that is shared across multiple other layers.
\item The layered system style allows an architecture to be composed of hierarchical layers by constraining component behavior. 
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{2. A\+R\+A\+::\+R\+E\+ST Architectural Elements}


\begin{DoxyItemize}
\item A\+R\+A\+::\+R\+E\+ST is a web standard based architecture and uses H\+T\+TP Protocol for data communication with help of P\+O\+CO library.
\item A resource is accessed by a common interface using H\+T\+TP standard methods like G\+ET, P\+UT, D\+E\+L\+E\+TE etc.
\item In A\+R\+A\+::\+R\+E\+ST architecture, a A\+R\+A\+::\+R\+E\+ST Server simply provides access to resources Object graph model and the A\+R\+A\+::\+R\+E\+ST client accesses and presents the resources.
\item Here each resource is identified by U\+R\+Is/ Global I\+Ds.
\item A\+R\+A\+::\+R\+E\+ST uses various representations to represent a resource like Text, J\+S\+ON and X\+ML.
\item A\+R\+A\+::\+R\+E\+ST is an A\+PI framework, which has components like Object Graph, Messages, Router, U\+RI, Client, Server.
\item All transport protocol bindings must map to basic set of components.
\end{DoxyItemize}

 
\begin{DoxyItemize}
\item The following H\+T\+TP methods are most commonly used in a R\+E\+ST based architecture.
\begin{DoxyItemize}
\item {\bfseries G\+ET} − Provides a read only access to a resource.
\item {\bfseries P\+UT} − Used to create a new resource.
\item {\bfseries D\+E\+L\+E\+TE} − Used to remove a resource.
\item {\bfseries P\+O\+ST} − Used to update an existing resource or create a new resource.
\item {\bfseries O\+P\+T\+I\+O\+NS} − Used to get the supported operations on a resource.
\end{DoxyItemize}
\item The A\+R\+A\+::\+Rest elements are as follows\+:
\begin{DoxyItemize}
\item {\bfseries Resources\+:}
\begin{DoxyItemize}
\item A\+R\+A\+::\+R\+E\+ST architecture treats every content as a resource. These resources can be Text Files, Html Pages, Images, Videos or Dynamic Business Data.
\item A\+R\+A\+::\+R\+E\+ST Server simply provides access to resources and A\+R\+A\+::\+R\+E\+ST client accesses and modifies the resources.
\item Here each resource is identified by U\+R\+Is/ Global I\+Ds. A\+R\+A\+::\+R\+E\+ST uses various representations to represent a resource which can be Text, J\+S\+ON, X\+ML.
\item The most popular representations of resources are X\+ML and J\+S\+ON.
\item A resource in A\+R\+A\+::\+R\+E\+ST is a similar to an Object in Object Oriented Programming or is like an Entity in a Database.
\item Once a resource is identified then its representation is to be decided using a standard format so that the server can send the resource in the above said format and client can understand the same format.
\end{DoxyItemize}
\item {\bfseries Messages\+:}
\begin{DoxyItemize}
\item R\+E\+S\+Tful make use of H\+T\+TP protocols as a medium of communication between client and server.
\item A client sends a message in form of a H\+T\+TP Request and the server responds in the form of an H\+T\+TP Response.
\item This technique is termed as Messaging. These messages contain message data and metadata i.\+e. information about message itself.
\item Message are of following types\+:
\begin{DoxyItemize}
\item {\bfseries H\+T\+TP Request}
\begin{DoxyItemize}
\item An H\+T\+TP Request has five major parts −
\begin{DoxyItemize}
\item Verb − Indicates the H\+T\+TP methods such as G\+ET, P\+O\+ST, D\+E\+L\+E\+TE, P\+UT, etc.
\item U\+RI − Uniform Resource Identifier (U\+RI) to identify the resource on the server.
\item H\+T\+TP Version − Indicates the H\+T\+TP version. For example, H\+T\+TP v1.\+1.
\item Request Header − Contains metadata for the H\+T\+TP Request message as key-\/value pairs. For example, client (or browser) type, format supported by the client, format of the message body, cache settings, etc.
\item Request Body − Message content or Resource representation.
\end{DoxyItemize}
\end{DoxyItemize}
\item {\bfseries H\+T\+TP Response}
\begin{DoxyItemize}
\item An H\+T\+TP Response has four major parts −
\begin{DoxyItemize}
\item Status/\+Response Code − Indicates the Server status for the requested resource. For example, 404 means resource not found and 200 means response is ok.
\item H\+T\+TP Version − Indicates the H\+T\+TP version. For example H\+T\+TP v1.\+1.
\item Response Header − Contains metadata for the H\+T\+TP Response message as keyvalue pairs. For example, content length, content type, response date, server type, etc.
\item Response Body − Response message content or Resource representation.
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}
\item Basic request and response messages.
\begin{DoxyItemize}
\item For the request\+:
\begin{DoxyItemize}
\item Consists of a line that have the method, the path, and the version of H\+T\+TP being used.
\item An optional header to send extra information, for example the user-\/agent, the content of the body etc…
\item An optional body also can be used to send information depending on the method. For example you cant send any with G\+ET but a P\+O\+ST request usually contains a body having the required information specific to a resource.
\end{DoxyItemize}
\item For a response\+:
\begin{DoxyItemize}
\item Again the version, also there is a status code stating the result of the request (200 for a success, 404 not found, etc… error codes are grouped by the nature of the error, for example 5xx is about server side errors. 4xx client errors, 2xx successful, 1xx informational) and a status message. Also, the header and the body are optional.
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}
\item {\bfseries Addressing(\+U\+R\+I)\+:}
\begin{DoxyItemize}
\item Addressing refers to locating a resource or multiple resources lying on the server.
\item Each resource in A\+R\+A\+::\+R\+E\+ST architecture is identified by its U\+RI (Uniform Resource Identifier). A U\+RI is of the following format −
\begin{DoxyItemize}
\item \char`\"{}$<$protocol$>$\+://$<$service-\/name$>$/$<$\+Resource\+Type$>$/$<$\+Resource\+I\+D$>$\char`\"{}
\end{DoxyItemize}
\item Purpose of an U\+RI is to locate a resource(s) on the server hosting the web service.
\item Another important attribute of a request is V\+E\+RB which identifies the operation to be performed on the resource.
\item There are 4 parts in a U\+RL\+:
\begin{DoxyItemize}
\item Protocol\+: The application-\/level protocol used by the client and server, e.\+g., H\+T\+TP, F\+TP, and telnet.
\item Hostname\+: The D\+NS domain name (e.\+g., www.\+nowhere123.\+com) or IP address (e.\+g., 192.\+128.\+1.\+2) of the server.
\item Port\+: The T\+CP port number that the server is listening for incoming requests from the clients.
\item Path-\/and-\/file-\/name\+: The name and location of the requested resource, under the server document base directory.
\end{DoxyItemize}
\end{DoxyItemize}
\item {\bfseries Object graph model\+:}
\begin{DoxyItemize}
\item ara\+::rest communicates via tree-\/structured data called object graphs.
\item O\+GM is a syntax tree of a “struct”; shall be able to map struct as well as J\+S\+ON.
\item It provides all necessary abstractions to build, traverse and dissect object graphs at C++ level.
\item It reflects the capabilities of J\+S\+ON to some extent for easy serialization.
\item J\+S\+ON is map–based, which makes it easy to divide a large data set into smaller subsets and send them across the wire on demand.
\item J\+S\+ON Graph allows a graph to be modeled as J\+S\+ON without introducing duplicates. Instead of inserting an entity into the same message multiple times, each entity with a unique identifier is inserted into a single, globally unique location in the J\+S\+ON Graph object.
\item The Path to the only location within the J\+S\+ON Graph object where an entity is stored is referred to as the entity’s Identity Path.
\item No two entities in an application’s domain model should have the same Identity Path.
\item So identity can be used in U\+RI to browse through different node to G\+ET the status of node element. 
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{3. Use cases\+: Door E\+CU}


\begin{DoxyItemize}
\item Each Door has a similar but varying set of controls and actors.
\item Door E\+CU can be expressed as R\+E\+S\+Tful service.
\item Resource door\+Status always has one element (“leaf”).
\item Resource window\+Status has 0..1 elements (e.\+g., manual window).
\item Resource controls elements for windows and mirrors.
\item Door E\+CU becomes the A\+R\+A\+::\+R\+E\+ST server with Driver Door and Rear Door are two nodes each of them having different elements like doorstate, windowstatus and control etc. \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Driver Door\+: }&{\bf Rear Door\+:  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Driver Door\+: }&{\bf Rear Door\+:  }\\\cline{1-2}
\endhead
Open/\+Close State &Open/\+Close State \\\cline{1-2}
Lock/\+Unlock State &Lock/\+Unlock State \\\cline{1-2}
Handle pulled State &Handle pulled State \\\cline{1-2}
Electric Window &Electric Window \\\cline{1-2}
Control for four windows &Control for four windows \\\cline{1-2}
\end{longtabu}

\item Restful Service model \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Driver Door\+: }&{\bf Rear Door\+:  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Driver Door\+: }&{\bf Rear Door\+:  }\\\cline{1-2}
\endhead
/door\+F\+L/door\+State/leaf/open =\{true, false\} &/door\+R\+R/door\+State/leaf/open =\{true, false\} \\\cline{1-2}
/door\+F\+L/door\+State/leaf/locked =\{true, false\} &/door\+R\+R/door\+State/leaf/locked = \{true, false\} \\\cline{1-2}
/door\+F\+L/door\+State/leaf/handle\+Pulled= \{true, false\} &/door\+R\+R/door\+State/leaf/handle\+Pulled = \{true, false\} \\\cline{1-2}
/door\+F\+L/window\+Status/window/opened = \mbox{[}0…100\%\mbox{]} &/door\+R\+R/window\+Status/window/opened = \mbox{[}0…100\%\mbox{]} \\\cline{1-2}
/door\+F\+L/controls/window\mbox{[}1-\/4\mbox{]} =\{full\+Up, up, keep, down, full\+Down\} &/door\+R\+R/controls/4 =\{full\+Up, up, keep, down, full\+Down\} \\\cline{1-2}
\end{longtabu}
$\ast$ Any web browser or application can become a client and with proper authorization can access the server database (object graph model) and use these R\+E\+S\+Tful service model in U\+RI to (G\+ET, D\+E\+L\+E\+TE, P\+O\+ST , L\+I\+ST) status of each node element as required .
\item U\+RI to access Doorstate/leaf will be -\/ \href{http://example.com/get//doorFL/doorState/leaf/locked,}{\tt http\+://example.\+com/get//door\+F\+L/door\+State/leaf/locked,} this link will give you the status of the leaf whether it open or closed.
\end{DoxyItemize}

\subsection*{4. P\+O\+CO Library}


\begin{DoxyItemize}
\item R\+E\+ST works over http protocol and A\+R\+A\+::\+R\+E\+ST uses P\+O\+CO libraries to implement the H\+T\+TP protocol.
\item The P\+O\+CO C++ Libraries are a collection of open source C++ class libraries that simplify and accelerate the development of network-\/centric, portable applications in C++.
\item P\+O\+CO consists of four core libraries, and a number of add-\/on libraries. The core libraries are Foundation, X\+ML, Util and Net. Two of the add-\/on libraries are Net\+S\+SL, providing S\+SL support for the network classes in the Net library, and Data.
\item P\+O\+CO\textquotesingle{}s Net library makes it easy to write network-\/based applications.
\item No matter whether your application simply needs to send data over a plain T\+CP socket, or whether your application needs a full-\/fledged built-\/in H\+T\+TP server.
\item At the lowest level, the Net library contains socket classes, supporting T\+CP stream and server sockets, U\+DP sockets, multicast sockets, I\+C\+MP and raw sockets.
\item If your application needs secure sockets, these are available in the Net\+S\+SL library, implemented using Open\+S\+SL 
\item The five core component libraries cover the following areas that can be found in the basic edition\+:
\begin{DoxyItemize}
\item {\bfseries Foundation\+:}
\begin{DoxyItemize}
\item Platform abstraction – Eases porting issues of fundamental types, etc.
\item Memory management – Resource Acquisition Is Initialization (R\+A\+II), auto\+\_\+ptr, reference counting garbage collection, etc.
\item String utilities.
\item Error handling – Extended exception classes.
\item streams – Encoding and decoding and filtering support.
\item threads – Concurrent processing support.
\item Date and time – Date and time support including formatting and high precision timers
\item File system – Abstracted file system support.
\item Logging – Application and system logging, filtering and logging strategies.
\item Processes – Interprocess communication and memory sharing.
\item shared libraries – Dynamic library support.
\item Notifications – Abstracted notification support.
\item Events – Abstracted event support and strategies.
\item Crypt – Random number generation, Digests and encoding/decoding engines.
\item Text – Unicode encoding support.
\item Regular expressions – Based on Perl compatible regular expression.
\item U\+RI – Universal Resource Identifier support.
\item U\+U\+ID – Universally Unique Identifiers support and generators.
\item Cache support – Abstracted strategy support.
\end{DoxyItemize}
\item {\bfseries Net\+:}
\begin{DoxyItemize}
\item sockets – Abstracted low level network support.
\item Reactor pattern – Popular network abstraction pattern support.
\item M\+I\+ME messages – Encoding support.
\item H\+T\+TP – High level H\+T\+TP support for client and servers.
\item F\+TP – High level F\+TP support.
\item Mail – P\+O\+P3, S\+M\+TP stream based support.
\item H\+T\+ML – Form support.
\end{DoxyItemize}
\item {\bfseries X\+ML\+:}
\begin{DoxyItemize}
\item Document Object Model (D\+OM)
\item X\+ML writer
\end{DoxyItemize}
\item {\bfseries J\+S\+ON\+:}
\begin{DoxyItemize}
\item A\+P\+Is for reading and writing J\+S\+ON
\end{DoxyItemize}
\item {\bfseries Util\+:}
\begin{DoxyItemize}
\item Configuration files
\item Command line options
\item Tools and server application framework 
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{adaptive_executionmanagement}{}\section{Execution Management}\label{adaptive_executionmanagement}

\begin{DoxyItemize}
\item \hyperlink{execution_management}{Execution Management} 
\end{DoxyItemize}\hypertarget{execution_management}{}\subsection{Execution Management}\label{execution_management}
Execution Management is the functional cluster within the Adaptive Platform Foundation that is responsible for platform initialization and the startup and shutdown of Applications. It performs these tasks using information contained within one or more Manifest files such as when and how Executables should be started. The Execution Management functional cluster is part of the Adaptive Platform.

Execution Management, in common with other Applications is assumed to be a process executed on a P\+O\+S\+IX compliant operating system. Execution Management is responsible for initiating execution of the processes in all the Functional Clusters, Adaptive A\+U\+T\+O\+S\+AR Services, and Adaptive Applications. The launching order is derived by Execution Management to ensure proper startup of the Adaptive Platform.

For an example, The Adaptive A\+U\+T\+O\+S\+AR Services are provided via mechanisms provided by the Communication Management functional cluster of the Adaptive Platform Foundation. In order to use the Adaptive A\+U\+T\+O\+S\+AR Services, the functional clusters in the Foundation must be properly initialized beforehand.

Execution Management is responsible for all aspects of process lifecycle management, including\+:


\begin{DoxyItemize}
\item {\bfseries Machine startup and shutdown} – Execution Management is the initial (“boot”) process of the operating system.
\item {\bfseries Required process hierarchy of started services, e.\+g., init and its child process.} – The boot process in this case corresponds to machine init process.
\item {\bfseries Provision of process isolation with each instance of an Executable managed as a single process.}
\item {\bfseries Startup and shutdown of Applications.} – Loading Executable based on a defined Execution Dependency. – Specific requirements until starting an Executable main function (i.\+e. entry point)
\begin{DoxyItemize}
\item Ensure that startup and shutdown dependencies between Executable instances are respected, if an execution dependency is specified in the Application Manifest of an Executable instance. If no execution dependency is specified between Executable instances, they can be started and stopped in an arbitrary order.
\end{DoxyItemize}
\item {\bfseries Privileges and use of access control} – Description and semantics of access control in manifest files
\begin{DoxyItemize}
\item Allocate OS resource budgets for Executable and/or groups of Executables
\item Authentication and authorization of Executables at startup of Executable
\end{DoxyItemize}
\item {\bfseries State management} – Conditions for the execution of Applications
\end{DoxyItemize}

\section*{2. {\bfseries Technical aspect of execution manager}}

\subsection*{2.\+1 {\bfseries Application}}


\begin{DoxyItemize}
\item Applications are developed to resolve a set of coherent functional requirements.
\item An Application consists of executable software units, additional execution related items (e.\+g. data or parameter files), and descriptive information used for integration and execution (e.\+g. a formal model description based on the A\+U\+T\+O\+S\+AR meta model, test cases).
\item Applications can be located on user level above the middleware or can be implementation of functional clusters of the Adaptive Platform.
\item Applications might use all mechanisms and A\+P\+Is provided by the operating system and other functional clusters of the Adaptive Platform, which in general restricts portability to other Adaptive Platforms.
\item All Applications, including Adaptive Applications, are treated the same by Execution Management.
\end{DoxyItemize}

\subsection*{2.\+2 {\bfseries Adaptive Application}}


\begin{DoxyItemize}
\item An Adaptive Application is a specific type of Application that fully complies with the A\+U\+T\+O\+S\+AR specification, i.\+e. it is restricted to use A\+P\+Is standardized by A\+U\+T\+O\+S\+AR and needs to follow specific coding guidelines to allow reallocation between different Adaptive Platforms.
\item Adaptive Applications are always located above the middleware. To allow portability and reuse, user level Applications should be Adaptive Applications whenever technically possible.
\item An Adaptive Application is the result of functional development and is the unit of delivery for Machine specific configuration and integration.
\item Some contracts and Service Interfaces to interact with other Adaptive Applications need to be agreed on beforehand.
\end{DoxyItemize}

\subsection*{2.\+3 {\bfseries Executable}}


\begin{DoxyItemize}
\item An Executable is a software unit which is part of an Application. It has exactly one entry point (main function). An Application can be implemented in one or more Executables.
\item Executables which belong to the same Adaptive Application might need to be deployed to different Machines, e.\+g. to one high performance Machine and one high safety Machine.
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*3{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Process Step }&{\bf Software }&{\bf Meta Information  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Process Step }&{\bf Software }&{\bf Meta Information  }\\\cline{1-3}
\endhead
Development and Integration &Linked, configured and calibrated binary for deployment onto the target Machine. The binary might contain code which was generated at integration time. &Application Manifest and Service Instance Manifest (not used by Execution Management) \\\cline{1-3}
Deployment and Removal &Binary installed on the target Machine. &Processed Manifests, stored in a platform-\/specific format which is efficiently readable at Machine startup. \\\cline{1-3}
Execution &Process started as instance of the binary. &The Execution Management uses contents of the Processed Manifests to start up and configure each process individually. \\\cline{1-3}
\end{longtabu}




\subsection*{2.\+4 {\bfseries Process}}


\begin{DoxyItemize}
\item A Process is a forked instance of an Executable. \begin{quote}
{\bfseries Note\+: In the initial release it is assumed, that processes are self contained, i.\+e. that they take care of controlling thread creation and scheduling by calling A\+P\+Is from within the code.} \end{quote}

\item Execution Management only starts and terminates the processes and while the processes are running, Execution Management only interacts with the processes by using State Management mechanisms.
\end{DoxyItemize}

\subsection*{2.\+5 {\bfseries Application Manifest}}


\begin{DoxyItemize}
\item The Application Manifest consists of parts of the Application design information which is provided by the application developer in an application description, and additional machine-\/specific information which is added at integration time.
\item An Application Manifest is created together with a Service Instance Manifest (not used by Execution Management) at integration time and deployed onto a Machine together with the Executable it is attached to.
\item It describes in a standardized way the machine-\/specific configuration of Process properties (startup parameters, resource group assignment, priorities etc.).
\item Each instance of an Executable binary, i.\+e. each started process, is individually configurable, with the option to use a different configuration set per Machine state or per Function Group State.
\end{DoxyItemize}

\subsection*{2.\+6 {\bfseries Machine Manifest}}


\begin{DoxyItemize}
\item The Machine Manifest holds all configuration information which cannot be assigned to a specific Executable, i.\+e. which is not already covered by an Application Manifest or a Service Instance Manifest.
\item The Machine Manifest is also created at integration time for a specific Machine and is deployed like Application Manifests whenever its contents change.
\item The contents of a Machine Manifest includes the configuration of Machine properties and features (resources, safety, security, etc.), e.\+g. configured Machine States and Function Group States, resource groups, access right groups, scheduler configuration, S\+O\+M\+E/\+IP configuration, memory segmentation.
\end{DoxyItemize}

\subsection*{2.\+7 {\bfseries Manifest format}}


\begin{DoxyItemize}
\item The Application Manifests and the Machine Manifest can be transformed into a platform-\/specific format (called Processed Manifest), which is efficiently readable at Machine startup.
\item The format transformation can be done either off board at integration time or at deployment time, or on the Machine (by Update and Configuration management) at installation time.
\end{DoxyItemize}

\subsection*{2.\+8 {\bfseries Execution Management Responsibilities}}


\begin{DoxyItemize}
\item Execution Management is responsible for all aspects of Process execution management. A Process is a loaded instance of an Executable, which is part of an Application.
\item Execution Management is started as part of the Adaptive Platform startup phase and is responsible for starting and terminating Processes.
\item Execution Management determines when, and possibly in which order, to start or stop Processes, i.\+e. instances of the deployed Executables, based on information in the Machine Manifest and Application Manifests.
\item Execution Management will be solely responsible for initiating execution of Processes.
\item Depending on the Machine State or on a Function Group State, deployed Executables are started during Adaptive Platform startup or later.
\item Execution Management is not responsible for run-\/time scheduling of Processes since this is the responsibility of the Operating System.
\item {\bfseries Application Lifecycle Management\+:}
\begin{DoxyItemize}
\item The Execution Management is responsible for the ordered startup and shutdown of the deployed Applications.
\item The Execution Management determines when, and possibly in which order, to start or stop the deployed Applications, based on information in the Machine Manifest and Application Manifests.
\item Depending on the Machine State or on a Function Group State, deployed Applications are started during Adaptive Platform startup or later, however, it is not expected that all will begin active work immediately since many Applications will provide services to other Applications and therefore wait and “listen” for incoming service requests.
\item The Execution Management derives an ordering for startup/shutdown within the State Management framework, based on declared Application dependencies. The dependencies are described in the Application Manifests.
\end{DoxyItemize}
\item The Execution Management is not responsible for run-\/time scheduling of Applications since this is the responsibility of the Operating System. However the Execution Management is responsible for initialization configuration of the OS to enable it to perform the necessary run-\/time scheduling based on information extracted by the Execution Management from the Machine Manifest and Application Manifests.
\end{DoxyItemize}

\subsubsection*{2.\+8.\+1 {\bfseries Process Lifecycle Management}}


\begin{DoxyItemize}
\item {\bfseries Process States\+:} From the execution stand point, Process States characterize the lifecycle of any Process. \begin{quote}
{\bfseries Note that each process is independent and therefore has its own Process State.} \end{quote}

\begin{DoxyItemize}
\item {\bfseries Idle Process State\+:} The Idle Process State will be the Process state prior to creation of the process and resource allocation.
\item {\bfseries Starting Process State\+:} The Starting Process State will apply when the process has been created and resources have been allocated.
\item {\bfseries Running Process State\+:} The Running Process State will apply to a process after it has been scheduled and it has reported Running State to the Execution Manager.
\item {\bfseries Terminating Process State\+:}
\begin{DoxyItemize}
\item The Terminating Process State will apply either after an process has received the termination indication from the Execution Manager or after it has decided to self-\/terminate and informed the Execution Manager.
\item The Terminating and Running Process State indications from Application to Execution Management use the Report\+Application\+State A\+PI. On entering the k\+Terminating\+Process State, the Process is expected to save persistent data, free all used Process internal resources and exit.
\end{DoxyItemize}
\item {\bfseries Terminated Process State\+:}
\begin{DoxyItemize}
\item The Terminated Process State will apply after the process has been terminated and the process resources have been freed. For that, Execution Manager will observe the exit status of all processes, with the P\+O\+S\+IX waitpid() command.
\item From the resource allocation stand point, Terminated state is similar to the Idle state as there is no process running and no resources are allocated anymore.
\item From the execution stand point, Terminated state is different from the Idle state since it tells that the process has already been executed and terminated.
\item This is relevant for one shot Processes which are supposed to run and terminate on their own as once they have reached their Terminated Process State they are to return to the Idle Process State without any external trigger.
\end{DoxyItemize}
\item {\bfseries One-\/shot Process State\+:}
\begin{DoxyItemize}
\item After a one-\/shot Process has terminated, Execution Management shall immediately set its Process State to Idle. 
\end{DoxyItemize}
\end{DoxyItemize}
\item {\bfseries Startup and Shutdown\+:}
\begin{DoxyItemize}
\item {\itshape Ordering\+:}
\begin{DoxyItemize}
\item The Execution Manager can derive an ordering for the startup and shutdown of Processes within the State Management framework based on the declared Execution Dependencies.
\item An Execution Dependency defines the provider of service(s) required by a Process before that Process can provide its own services. Hence Execution Management ensures the dependent Processes are in the state defined by the Execution Dependency before the Process with the dependency is started.
\item Execution Dependencies are described in the Application Manifest.
\item During startup, Execution Management shall respect Execution Dependencies by ensuring that any Processes upon which the Process to be started depends have reached the requested state before starting the Process.
\item The same Execution Dependencies used to define the startup order are also used to define the shutdown order. However the situation is reversed as Execution Management must ensure that dependent processes are shutdown after the process to ensure that the services required remain available until no longer required.
\item During shutdown, Execution Management will respect Execution Dependencies by ensuring that any Processes upon which the Process to be shutdown depends are not terminated before shutting down the Process.
\end{DoxyItemize}
\item {\itshape Arguments \+:}
\begin{DoxyItemize}
\item Execution Manager provides argument passing for a Process contain is gone or more Mode\+Dependent\+Startup\+Config in the role Process.\+mode\+Depen-\/dent\+Startup\+Config. This permits different Processes to be started with different arguments.
\item At the initiation of startup of a Process, the aggregated Startup\+Options of the Startup\+Config referenced by the Mode\+Dependent\+Startup\+Config will be passed to the call of the exec-\/family based P\+O\+S\+IX interface to start the Process by the Operating System.
\item The first argument on the command-\/line passed by Execution Management is the name of the Executable.
\end{DoxyItemize}
\end{DoxyItemize}
\item {\bfseries Startup Sequence\+:}
\begin{DoxyItemize}
\item When the Machine is started, the OS will be initialized first and then Execution Manager is launched as one of the O\+S’s initial Processes. Other functional clusters and platform-\/level Applications of the Adaptive Platform Foundation are then launched by Execution Management. After the Adaptive Platform Foundation is up and running, Execution Management continues to launch userlevel Applications.
\item The startup order of the platform-\/level Processes is determined by the Execution Management, based on Machine Manifest and Application Manifest information. 
\end{DoxyItemize}
\item {\bfseries Execution Dependency\+:}
\begin{DoxyItemize}
\item The Execution Management provides support to the Adaptive Platform for ordered startup and shutdown of Applications.
\item This ensures that Applications are started before dependent Applications use the services that they provide and, likewise, that Process are shutdown only when their provided services are no longer required.
\item The Execution dependencies, are configured in the Application Manifests, which is created at integration time based on information provided by the Application developer.
\item User-\/level applications use service discovery mechanisms of the Communication Management and should not depend on startup dependencies. Which Executable instances are running depends on the current Machine State and on the current Function Group States. The integrator must ensure that all service dependencies are mapped to State Management configuration, i.\+e. that all dependent Executable instances are running when needed.
\item In real life, specifying a simple dependency to an Process might not be sufficient to ensure that the depending service is actually provided. Since some Process will reach a certain Application State to be able to offer their services to other Process, the dependency information will also refer to Process State of the Process specified as dependency. With that in mind, the dependency information may be represented as a pair like\+: \char`\"{}$<$\+Process$>$.$<$\+Application\+State$>$\char`\"{}.
\item The following dependency use-\/cases have been identified\+:
\begin{DoxyItemize}
\item In case Process B has a simple dependency on Process A, the Running Application State of Process A is specified in the dependency section of Process B’s Application Manifest.
\item In case Process B depends on One-\/\+Shot Process A, the Terminated Application State of Process A is specified in the dependency section of Process B’s Application Manifest.
\end{DoxyItemize}
\item Processes are only started by the Execution Manager if they reference a requested Machine State or Function Group State, but not because of configured Execution Dependencies.
\item Execution Dependencies are only used to control a startup or terminate sequence at state transitions or at machine startup/shutdown.
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{2.\+9 {\bfseries State Management}}


\begin{DoxyItemize}
\item State Management provides a mechanism to define the state of the operation for an Adaptive Platform. The Application Manifest allows definition in which states the Process instances have to run . State Management grants full control over the set of Applications to be executed and ensures that Process are only executed (and hence resources allocated) when actually needed.
\item Four different states are relevant for Execution Management\+:
\begin{DoxyItemize}
\item Application State
\item Process State
\begin{DoxyItemize}
\item Process States are managed by an Execution Management internal state machine.
\end{DoxyItemize}
\item Machine State
\item Functional group state.
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+9.\+1 {\bfseries Application State\+:}}


\begin{DoxyItemize}
\item The Application State characterizes the internal lifecycle of any instance of an Process. The states are defined by the Application\+State enumeration.
\item {\bfseries Application State Running\+:}
\begin{DoxyItemize}
\item Execution Management shall consider Process initialization complete when the state k\+Running is reported. \begin{quote}
{\bfseries Please note that Service Discovery can introduce non-\/deterministic delays and thus is advised to be done after reporting k\+Running state thus the Process may not have completed all its initialization when the k\+Runningstate is reported.} \end{quote}

\end{DoxyItemize}
\item {\bfseries Initiation of Process termination\+:}
\begin{DoxyItemize}
\item Execution Management shall initiate termination by sending the S\+I\+G\+T\+E\+RM signal to a Process.
\item Note that from the perspective of Execution Management, requirement only requests the initiation of the steps necessary for termination.
\item On receipt of S\+I\+G\+T\+E\+RM, a Process acknowledges the request (by reporting the new state to Execution Management using the Application-\/\+Client\+:Report\+Application\+Stateinterface) and then commences the actual termination.
\end{DoxyItemize}
\item {\bfseries Acknowledgement of termination request\+:}
\begin{DoxyItemize}
\item On reception of S\+I\+G\+T\+E\+RM, the Process will acknowledge the state change request by reporting k\+Terminating to Execution Management.
\end{DoxyItemize}
\item {\bfseries Initiation of Process self-\/termination\+:}
\begin{DoxyItemize}
\item A Process will initiate self-\/termination by reporting the k\+Terminating state to Execution Management.
\item During the Terminating state, the Process is expected to free internally used resources. The Process indicates completion of the Terminating state by simply exiting (with an appropriate exit code). Execution Management as the parent process can detect termination of the child process and take the appropriate platform-\/specific actions.
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+9.\+2 {\bfseries Machine State}}


\begin{DoxyItemize}
\item Requesting and reaching a Machine State is, besides using Function Group States, one way to define the current set of running Process. It is significantly influenced by vehicle-\/wide events and modes.
\item Each Application can declare in its Application Manifest in which Machine States it has to be running.
\item There are several mandatory machine states specified in this document that have to be present on each machine.
\item Additional Machine States can be defined on a machine specific basis and are therefore not standardized.
\item Machine States\+:
\begin{DoxyItemize}
\item A Mode\+Declaration for each required Machine State has to be defined in the Machine Manifest.
\item The Execution Manager will obtain the Machine States from the Machine Manifest.
\item The A\+PI specification will use the short\+Name for identification of the Machine State.
\item The Machine States are determined and requested by the State Manager.
\end{DoxyItemize}
\item Following are the default Machine state\+:
\item {\bfseries Startup} 
\begin{DoxyItemize}
\item The Startup Machine State will be the first state to be active after the startup of Execution Manager. Therefore, a Mode\+Declaration for the Startup has to be defined in the Machine Manifest.
\item The following behavior apply for the Startup Machine State\+:
\begin{DoxyItemize}
\item All Processes of platform-\/level Applications configured for Startup will be started.
\item Process configured for Startup are based on the reference from the Process to the Mode\+Dependent\+Startup\+Config in the role Process.\+mode\+Dependent\+Startup\+Config with the instance\+Ref to the Mode\+Declaration in the role Mode\+Dependent\+Startup\+Config.\+machine\+Mode that belongs to the Startup Machine State.
\item The Execution Manager will wait for all started Process until their Application State Running is reported.
\item If that is the case, the Execution Manager will notify the State Manager that the Startup Machine State is ready to be changed.
\item The Execution Manager will not change the Machine State by itself until a new state is requested by the State Manager.
\end{DoxyItemize}
\end{DoxyItemize}
\item {\bfseries Shutdown}
\begin{DoxyItemize}
\item The Shutdown Machine State will be active after the Shutdown Machine State is requested by the State Manager. Therefore, a Mode\+Declaration for the Shutdown has to be defined in the Machine Manifest.
\item The following behavior apply for the Shutdown Machine State\+:
\begin{DoxyItemize}
\item All Processes, including the platform-\/level Applications, that have a Process State different than Idle or Terminated will be shutdown.
\item When Process State of all Process is Idle or Terminated, all Process configured for Shutdown will be started.
\item Process configured for Shutdown are based on the reference from the Processes to the Mode\+Dependent\+Startup\+Config in the role Process.\+mode\+De-\/pendent\+Startup\+Config with the instance\+Ref to the Mode\+Declaration in the role Mode\+Dependent\+Startup\+Config.\+machine\+Mode that belongs to the Shutdown Machine State.
\end{DoxyItemize}
\item Shutdown of the Operating System\+:
\begin{DoxyItemize}
\item There will be at least one Process consisting of at least one Process that has a Mode\+Dependent\+Startup\+Config in the role Process.\+mode\+Dependent\+Startup\+Config with the instance\+Ref to the Mode\+Declaration in the role Mode\+Dependent\+Startup\+Config.\+machine\+Mode that belongs to the Shutdown Machine State.
\item This Application will contain the actual mechanism(s) to initiate shutdown of the Operating System.
\end{DoxyItemize}
\end{DoxyItemize}
\item {\bfseries Restart}
\begin{DoxyItemize}
\item The Restart Machine State will be active after the Restart Machine State is requested by the State Manager. Therefore, a Mode\+Declaration for the Restart has to be defined in the Machine Manifest.
\item The following behavior applies for the Restart Machine State\+:
\begin{DoxyItemize}
\item All Process, including the platform-\/level Applications, that have a Process State different than Idle or Terminated will be shutdown.
\item When Process State of all Process is Idle or Terminated, all Process configured for Restart will be started.
\item Process configured for Restart are based on the reference from the Process to the Mode\+Dependent\+Startup\+Config in the role Process.\+mode\+Dependent\+Startup\+Config with the instance\+Ref to the Mode\+Declaration in the role Mode\+Dependent\+Startup\+Config.\+machine\+Mode that belongs to the Restart Machine State.
\end{DoxyItemize}
\item Restart of the Operating System\+:
\begin{DoxyItemize}
\item There will be at least one Application consisting of at least one Process that has a Mode\+Dependent\+Startup\+Config in the role Process.\+mode\+Dependent\+Startup\+Config with the instance\+Ref to the Mode\+Declaration in the role Mode\+Dependent\+Startup\+Config.\+machine\+Mode that belongs to the Restart Machine State.
\item This Application will contain the actual mechanism(s) to initiate restart of the Operating System.
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{2.\+10 {\bfseries State Management Architecture}}


\begin{DoxyItemize}
\item State Management is the functional cluster which is responsible for determining the current set of active Machine State and Function Group States, and for initiating State transitions by requesting them from Execution Management.
\item Execution Management performs the State transitions and controls the actual set of running Processes, depending on the current States.
\item State Management is the central point where new Machine States and Function Group States can be requested and where the requests are arbitrated, including coordination of contradicting requests from different sources. Additional data and events might need to be considered for arbitration.
\item The State change requests can be issued by\+:
\begin{DoxyItemize}
\item Platform Health Management to trigger error recovery, e.\+g. to activate fallback functionality
\item Diagnostics, to switch the system into diagnostic states.
\item Update and Configuration Management to switch the system into states where software or configuration can be updated.
\item Network Management to coordinate required functionality and network state.
\item authorized applications, e.\+g. a vehicle state manager which might be located in a different machine or on a different E\+CU State Change requests can be issued by other.
\end{DoxyItemize}
\item Since State Management functionality is critical, access from other Functional Clusters or Process must be secured, e.\+g. by I\+AM (Identity and Access Management).
\item State Management is monitored and supervised by Platform Health Management.
\item State Management provides interfaces to request information about current states.
\end{DoxyItemize}

\subsubsection*{2.\+10.\+1 {\bfseries State Interaction}}


\begin{DoxyItemize}
\item One can see the state transitions of a Function Group and the Process and Application States of one Process which references one state of this Function Group, ignoring possible delays and dependencies if several Processes were involved.
\item The interaction is identical if the Process references a Machine State instead of a Function Group State.
\end{DoxyItemize}

\subsubsection*{2.\+10.\+2 {\bfseries State Change}}


\begin{DoxyItemize}
\item State Management can request to change one or several Function Group States and/or the Machine State from Execution Management by passing pairs of \char`\"{}\+Function Group\char`\"{} \char`\"{}requested State\char`\"{} as parameters, with Machine State being treated like any Function Group State.
\item A state change request by State Management will lead to immediate state transitions and hereof a state change to the requested Machine State and/or Function Group States.
\item State Management can request multiple Machine State and Function Group State changes sequentially by issuing several individual state change requests, or atomically within the same state change request, which leads to multiple coherent state changes.
\item However, the following restriction applies to avoid undefined behaviour while the state transitions are performed by Execution Management\+:
\item {\bfseries Deny State Change Request\+:}
\begin{DoxyItemize}
\item Execution Management will deny state change requests, that are received before all previously requested Machine State and/or Function Group State transitions are completed. If a request is denied, Execution Management will return an error code to the requester of the state transition.
\end{DoxyItemize}
\item {\bfseries State Transition Timeout\+:}
\begin{DoxyItemize}
\item If a timeout is detected when stopping or starting Processes at a state transition, Execution Management will return an error code to the requester of the state changes.
\item This implies that the state change request blocks until the state transitions are completed or until an error is detected.
\end{DoxyItemize}
\item {\bfseries State Change Failed\+:}
\begin{DoxyItemize}
\item Execution Management will return an error code to the requester of the state changes when other or unspecified errors occur at a state transition.
\end{DoxyItemize}
\item {\bfseries State Change Successful\+:}
\begin{DoxyItemize}
\item When Execution Management succeeds with the requested state transitions, a success code will be returned to the requester of the state changes.
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{2.\+11 {\bfseries Deterministic Execution}}

\subsubsection*{2.\+11.\+1 {\bfseries Determinism}}


\begin{DoxyItemize}
\item In real-\/time systems, deterministic execution often means, that a calculation of a given set of input data always produces a consistent output within a bounded time, i.\+e. the behavior is reproducible.
\item In the context of Execution Management, the term “calculation” can apply to execution of a thread, a Process, or a group of Processes. The calculation can be event-\/driven or cyclic; i.\+e. time-\/driven.
\item There are multiple elements in determinism and here we distinguish them as follows\+:
\begin{DoxyItemize}
\item {\bfseries Time Determinism\+:} The output of the calculation is always produced before a given deadline (a point in time).
\item {\bfseries Data Determinism\+:} Given the same input and internal state, the calculation always produces the same output.
\item {\bfseries Full Determinism\+:} Combination of Time and Data Determinism as defined above.
\end{DoxyItemize}
\item Deterministic behavior is important for safety-\/critical systems, which may not be allowed to deviate from the specified behavior at all.
\item Whether Time Determinism, or in addition Data Determinism is necessary to provide the required functionality depends on the system and on the safety goals.
\item Expected use cases of the Adaptive Platform where such determinism is required include\+:
\begin{DoxyItemize}
\item Software Lockstep\+: To execute A\+S\+IL C/D with high computing performance demands, specific measures, such as software lockstep are required, due to high transient hardware error rates of high performance microprocessors. Software lockstep is a technique where the calculation is done redundantly through two different execution paths and the results are compared. To make the redundant calculations comparable, software lockstep requires a fully deterministic calculation.
\item Reuse of verified software\+: The deterministic subsystem shows the same behavior on different platforms which satisfy the performance and resource needs of the subsystem, regardless of other differences in each environment, such as existence of unrelated applications. Examples include the different development and simulation platforms. Due to reproducible functional behavior, many results of testing, configuration and calibration of the subsystem are valid in each environment where the subsystem is deployed on and don’t need to be repeated.
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+11.\+1.\+1 {\bfseries Time Determinism}}


\begin{DoxyItemize}
\item Each time a calculation is started, its results are guaranteed to be available before a specified deadline. To achieve this, sufficient and guaranteed computing resources (processor time, memory, service response times etc.) must be assigned to the software entities that perform the calculation.
\item Non-\/deterministic “best-\/effort” Processes can request guaranteed minimum resources for basic functionality, and additionally can have maximum resources specified for monitoring. However, if Time Determinism is requested, the resources must be guaranteed at any time, i.\+e. minimum and maximum resources are identical.
\item If the assumptions for deterministic execution are violated, e.\+g. due to a deadline miss, this must be treated as an error and recovery actions must be initiated. In nondeterministic “best-\/effort” subsystems such deadline violations or other deviations from normal behavior sometimes can be tolerated and mitigated without dedicated error management.
\item Fully-\/\+Deterministic behavior additionally requires Data Determinism, however in many cases Time Determinism is sufficient.
\end{DoxyItemize}

\subsubsection*{2.\+11.\+1.\+2 {\bfseries Data Determinism}}


\begin{DoxyItemize}
\item For Data Determinism, each time a calculation is started, its results only depend on the input data. For a specific sequence of input data, the results always need to be exactly the same, assuming the same initial internal state.
\item A common approach to verify Data Determinism in a safety context is the use of lockstep mechanisms, where execution is done simultaneously through two different paths and the result is compared to verify consistency. Hardware lockstep means that the hardware has specific equipment to make this double-\//multi-\/execution transparent. Software lockstep is another technique that allows providing a similar property without requiring the use of dedicated hardware.
\item Depending on the Safety Level, as well as the Safety Concept employed, software lockstep may involve executing multiple times the same software, in parallel or sequentially, but may also involve running multiple separate implementations of the same algorithm.
\end{DoxyItemize}

\subsubsection*{2.\+11.\+1.\+3 {\bfseries Full Determinism}}


\begin{DoxyItemize}
\item For Full Determinism, each time a calculation is started, its results are available before a specified deadline and only depend on the input data, i.\+e. both Time and Data Determinism must be guaranteed.
\item Currently, only Full Deterministic behavior of one Process is specified. Determinism of a cluster of Processes on one or even several machines needs extensions of the Communication Management, which have not been specified yet.
\item Non-\/deterministic behavior may arise from different reasons; for example insufficient computing resources, uncoordinated access of data, potentially by multiple threads running on multiple processor cores. The order in which the threads access such data will affect the result, which makes it non-\/deterministic (“race condition”).
\item A fully deterministic calculation must be designed, implemented and integrated in a way such that it is independent of processor load, sporadic unrelated events, race conditions, etc.
\end{DoxyItemize}

\subsection*{2.\+11.\+2 {\bfseries Redundant Deterministic Execution}}


\begin{DoxyItemize}
\item Future systems need high computing performance in combination with high A\+S\+IL safety goals.
\item Here are some additional rationales behind it\+:
\begin{DoxyItemize}
\item Safety goals for Highly Automated Driving (H\+AD) systems can be up to A\+S\+IL D.
\item High Performance Computing (H\+PC) demands can only be met by non automotive-\/grade, e.\+g. consumer electronics (CE), microprocessors, which have high transient hardware error rates compared to automotive-\/grade microcontrollers. Most likely no such microprocessor is available for A\+S\+IL above B, at least for the parts relevant to the design.
\item To deal with high error rates, A\+S\+IL C/D H\+AD applications require specific measures, in particular software lockstep, where execution is done redundantly through two different paths and the result is compared to detect errors.
\item To make these redundant calculations comparable, software lockstep requires a fully deterministic calculation which must be designed, implemented and integrated in a way such that it is independent of processor load caused by other functions and calculations, sporadic unrelated events, race conditions, deviating random numbers etc, i.\+e. for the same input and initial conditions it always produces the same result within a given time.
\item To meet H\+PC demands, highly predictable and reliable multi-\/threading must be supported.
\end{DoxyItemize}
\item Two redundant Processes, which run in an internal cycle, get in each cycle the same input data via regular interfaces of the Communication Management and produce (in the absence of errors) the same results, due to full deterministic execution.
\end{DoxyItemize}

\subsection*{2.\+12 {\bfseries Resource limitation}}


\begin{DoxyItemize}
\item Despite the correct behavior of a particular Adaptive Application in the system, it is important to ensure any potentially incorrect behavior, as well as any unforeseen interactions cannot cause interference in unrelated parts of the system.
\item it is important to consider that Execution Management is only responsible for the correct configuration of the Machine. However, enforcing the associated restrictions is usually done by either the Operating System or another Application like the Persistency service.
\end{DoxyItemize}

\subsubsection*{2.\+12.\+1 {\bfseries Resource configuration}}


\begin{DoxyItemize}
\item This section provides an overview on resource assignment to Processes, resources like\+:
\begin{DoxyItemize}
\item R\+AM (e.\+g. for code, data, thread stacks, heap)
\item C\+PU time
\end{DoxyItemize}
\item In general, we need to distinguish between two resource demand values\+:
\begin{DoxyItemize}
\item Minimum resources, which need to be guaranteed so the process can reach its Running state and perform its basic functionality.
\item Maximum resources, which might be temporarily needed and will not be exceeded at any time, otherwise it will throw an error.
\end{DoxyItemize}
\item Execution Management will configure the maximum amount of R\+AM available globally for all Processes belonging to each Resource\+Group when defined in the configuration, before loading a Process from this Resource\+Group. If a Resource\+Group does not have a configured R\+AM limit, then the Processes are only bound by their implicit memory limit.
\item Execution Management will configure the maximum amount of C\+PU time available globally for all Processes belonging to each Resource\+Group when defined in the configuration, before loading a Process from this Resource\+Group. If Resource\+Group does not have a configured C\+PU usage limit, then the Processes are only bound by their implicit C\+PU usage limit (priority, scheduling scheme...).
\end{DoxyItemize}

\subsubsection*{2.\+12.\+2 {\bfseries Resource Monitoring}}


\begin{DoxyItemize}
\item The resources which are actually used by a Process should be controlled at any given time.
\item For the entire system, the monitoring part of this activity is fulfilled by the Operating System.
\item Depending on system requirements and safety goals, an appropriate Operating System has to be chosen and configured accordingly, in combination with other monitoring mechanisms (e.\+g. for execution deadlines) which are provided by Platform Health Management.
\item Resource monitoring can serve several purposes, e.\+g.
\begin{DoxyItemize}
\item Detection of misbehavior of the monitored Process to initiate appropriate recovery actions, like Process restart or state change, to maintain the provided functionality and guarantee functional safety.
\item Protection of other parts of the system by isolating the erroneous Processes from unaffected ones to avoid resource shortage.
\end{DoxyItemize}
\item For Processes which are attempting to exceed their configured maximum resource needs, one of the following alternatives\+:
\begin{DoxyItemize}
\item The resource limit violation or deadline miss is considered a failure and recovery actions may need to be initiated. Therefore the specific violation gets reported to the Platform Health Management, which then starts recovery actions which have been configured beforehand. This will be the standard option for deterministic subsystems.
\item For Processes without hard deadlines, resource violations sometimes can be mitigated without dedicated error recovery actions, e.\+g. by interrupting execution and continue at a later point in time.
\item If the OS provides a way to limit resource consumption of a Process or a group of Processes by design, explicit external monitoring is usually not necessary and often not even possible. Instead, the limitation mechanisms make sure that resource availability for other parts of the system is not affected by failures within the enclosed Processes. When such by-\/design limitation is used, monitoring mechanisms may still be used for the benefit of the platform, but are not required. Self-\/monitoring and out-\/of-\/process monitoring is currently out-\/of-\/scope in Adaptive Platform.
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{2.\+12.\+3 {\bfseries Application-\/level Resource configuration}}

\subsubsection*{2.\+12.\+3.\+1 {\bfseries C\+PU Usage}}


\begin{DoxyItemize}
\item C\+PU usage is represented in a Process by its threads. Generally speaking, Operating Systems use some properties of each thread’s configuration to determine when to run it, and additionally constrain a group of threads to not use more than a defined amount of C\+PU time. Because threads may be created at runtime, only the first thread can be configured by Execution Management.
\end{DoxyItemize}

\subsubsection*{2.\+12.\+3.\+2 {\bfseries Core Affinity}}


\begin{DoxyItemize}
\item Execution Management will configure the Core affinity of the Process initial thread restricting it to a sub-\/set of cores in the system.
\item Depending on the capabilities of the Operating System the sub-\/set could be a single core.
\item If the Operating System does not support binding to specific cores then the only supported sub-\/set is the entire set of cores.
\end{DoxyItemize}

\subsubsection*{2.\+12.\+3.\+3 {\bfseries Scheduling Policy}}


\begin{DoxyItemize}
\item Currently available P\+O\+S\+I\+X-\/compliant Operating Systems offer the scheduling policies required by P\+O\+S\+IX, and in most cases additional, but different and incompatible scheduling strategies. This means for now, the required scheduling properties need to be configured individually, depending on the chosen OS.
\item Moreover, scheduling strategy is defined per thread and the P\+O\+S\+IX standard allows for modifying the scheduling policy at runtime for a given thread, using pthread\+\_\+setschedparam(). It is therefore not currently possible for the Adaptive Platform to enforce a particular scheduling strategy for an entire Process, but only for its first thread.
\item While scheduling policies are not a sufficient method to guarantee Full Determinism, they contribute to improve it. While the aim is to limit C\+PU time for a Process, scheduling policies apply to threads. \begin{quote}
{\bfseries Note that while Execution Management will ensure the proper configuration for the first thread (that calls the main() function), it is the responsibility of the Process itself to properly configure secondary threads.} \end{quote}

\end{DoxyItemize}

\subsubsection*{2.\+12.\+3.\+4 {\bfseries Resource Management}}


\begin{DoxyItemize}
\item In general, for deterministic behavior the required computing time is guaranteed and violations are treated as error, while best-\/effort subsystems are more robust and might be able to mitigate sporadic violations, e.\+g. by continuing the calculation at the next activation, or by providing a result of lesser quality. This means, if time (e.\+g. deadline or runtime budget) monitoring is in place, the reaction on deviations is different for deterministic and best-\/effort subsystems.
\item In fact, it may not even be necessary to monitor best-\/effort subsystems, since they by definition are doing only a function that may not succeed. This leads to an architecture where monitoring is a voluntary, configured property.
\item The remaining critical property however is to guarantee that a particular process or set of Processes cannot adversely affect the behavior of other Processes.
\item To guarantee Full Determinism for the entire system, it is important to ensure Freedom from Interference, which the Resource\+Group contribute to ensure.
\item Execution Management will configure the Process according to its Resource\+Group membership.
\end{DoxyItemize}

\subsubsection*{2.\+12.\+3.\+5 {\bfseries Memory Budget and Monitoring}}


\begin{DoxyItemize}
\item To render a function, a Process requires the availability of some amount of memory for its usage (mainly code, data, heap, thread stacks). Over the course of its execution however, not all of this memory is required at all times, such that an OS can take advantage of this property to make these ranges of memory available on-\/demand, and provide them to other Processes when the memory is no longer used.
\item While this has clear advantages in terms of system flexibility as well as memory efficiency, it is also in the way of both Time Determinism and Full Determinism\+: when a range of memory that was previously unused must now be made available, the OS may have to execute some amounts of potentially-\/unbounded activities to make this memory available. Often, the reverse may also be happening, removing previously available (but unused) memory from the Process under scope, to make it available to other Processes. This is detrimental to an overall system determinism.
\item Execution Management will ensure that the entire memory range that deterministic Processes may be using is available at the start and for the whole duration of the respective Process execution.
\item In order to provide sufficient memory at the beginning of the execution of a Process, some properties may need to be defined for each Process.
\item {\bfseries Maximum heap\+:}
\begin{DoxyItemize}
\item Execution Management will configure the Maximum heap usage for the Process.
\item Heap memory is used for dynamic memory allocation inside a Process e.\+g. through malloc()/free() and new/delete.
\end{DoxyItemize}
\item {\bfseries Maximum system memory usage\+:}
\begin{DoxyItemize}
\item Execution Management will configure the Maximum system memory usage of the Process.
\item System memory can be used to create extra resources like file handles or semaphores, as well as creating new threads.
\end{DoxyItemize}
\item {\bfseries Process pre-\/mapping\+:}
\begin{DoxyItemize}
\item Execution Management will premap a Process if required by the corresponding Application Manifest.
\item Fully pre-\/mapping a Process ensures that code and data execution is not going to be delayed at its first execution by demand-\/loading. This helps providing Time Determinism during system startup and first execution phases, but also helps with safety where code handling error cases can be preloaded and made guaranteed to be available. In addition, pre-\/mapping avoids late issues where filesystem may be corrupted and part of the Process may not be loadable anymore. 
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{adaptive_update_configurationmanagement}{}\section{Update \& Configuration Management}\label{adaptive_update_configurationmanagement}

\begin{DoxyItemize}
\item \hyperlink{ucm_overview}{Update and Configuration Management (U\+CM)} 
\end{DoxyItemize}\hypertarget{ucm_overview}{}\subsection{Update and Configuration Management (U\+CM)}\label{ucm_overview}
\subsection*{1. Introduction}

{\bfseries Update and Configuration Management} has the responsibility of installing, updating and removing software on an Adaptive Platform in a safe and secure way while not sacrificing the dynamic nature of the Adaptive Platform. These updates and changes can be to the A\+U\+T\+O\+S\+AR Adaptive Platform itself, including all functional clusters, the underlying P\+O\+S\+IX OS and its kernel. U\+CM exposes its functionality via {\bfseries ara\+::com service interfaces} and not direct A\+P\+Is. This ensures the user of U\+CM does not have to be located on the same E\+CU.

{\bfseries Responsibilities}
\begin{DoxyItemize}
\item Version reporting of the software present in the A\+U\+T\+O\+S\+AR Adaptive Platform.
\item Receiving and buffering software updates.
\item Checking that enough resources are available to ensure a software update.
\item Performing software updates and providing log messages and progress info.
\item Validating the outcome of a software update.
\item Providing rollback functionality to restore to a known functional state in case of failure. 
\end{DoxyItemize}

\subsection*{2. Limitations}


\begin{DoxyItemize}
\item U\+CM is not responsible to initiate the update process.
\item U\+CM realizes a service interface to achieve this operation.
\item The safe state of the vehicle has to be ensured by the client, before executing a software update procedure on demand.
\item U\+CM receives a locally available software package for processing.
\item Prior to triggering their processing, the software packages have to be transferred to U\+CM by using the provided ara\+::com interface.
\end{DoxyItemize}

\subsection*{3. Technical Overview}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline


-\/ The U\+CM functional cluster provides a service interface that exposes its functionality to consistently execute software updates.



-\/ The Diagnostic Client uploads a Software Package by standard U\+DS services.



-\/ After decompression and verification steps inside the O\+E\+M-\/specific Diagnostic Application, the Software Package is passed to U\+CM.



-\/ Both O\+TA and U\+DS connections are very much O\+EM specific. For this reason a O\+EM specific application, like Diagnostic Service Application manages how data is transferred to U\+CM.



-\/ U\+CM handles the package management after it has received the data.



&

{\bfseries Diagnostic Application communicating with U\+CM and DM. }

 \\\cline{1-2}
\end{longtabu}


\subsection*{4. Software Package}

The unit for deployment which is the input for U\+CM is a {\bfseries Software Package}. \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
 &{\bfseries Content of a Software Package }
\begin{DoxyItemize}
\item Each Software Package addresses a single Software\+Cluster and contains manifests, executables and further data (depending on the role of the Software\+Cluster)
\item The manifest include a name and a version. A time stamp will be trailing the Major.\+Minor.\+Patch version.
\item U\+CM can create, update or remove any persistency data that is contained in the Software\+Cluster. Rollback of persisted data can be done to persistent data during update process.
\item Software\+Cluster can have execution dependencies towards other Software\+Clusters. Execution dependencies are checked in the end of the update process before activating/switching to the new software version.
\end{DoxyItemize}

\\\cline{1-2}
\end{longtabu}


Each Software Package will address a single Software\+Cluster. A Software\+Cluster can act in two roles\+: 
\begin{DoxyItemize}
\item {\bfseries ‘\+Sub’-\/\+Software\+Cluster} \+: A Software\+Cluster without diagnostic target address, containing processes, executables and further elements. 
\item {\bfseries ‘\+Root’-\/\+Software\+Cluster}\+: A Software\+Cluster with a diagnostic target address that may reference several other {\bfseries ‘\+Sub’-\/\+Software\+Clusters}, which thus form a logical group. 
\end{DoxyItemize}

A software package has to be modelled as a so-\/called Software\+Cluster which describes the content of a software package that has to be uploaded to the A\+U\+T\+O\+S\+AR Adaptive Platform. Software Package is used for the \char`\"{}physical\char`\"{}, uploadable software package that is processed by U\+CM whereas the term Software\+Cluster is used for the modeling element. 

In the model, the content of a Software\+Cluster will be determined by references to all required model elements. The Software\+Cluster and the related model elements will be put into a manifest that is part of the Software Package. 

\subsubsection*{4.\+1 SW Package Manifest Dependency}

Installing a SW Package in {\bfseries Dependency Example 1} has {\itshape Application A, Application B and Library A} and in {\bfseries Dependency Example 2} has {\itshape Application A, Manifest} files as dependencies. So during installation dependencies will be resolved and application list builder will be updated with these resolved Dependencies.

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
 &

{\bfseries Dependency Example 1}



Software Package contents\+:


\begin{DoxyItemize}
\item Application C, Application D and Library B (provided contents)
\item Manifest \char`\"{}\+Second\char`\"{} has dependency of $>$$>$
\begin{DoxyItemize}
\item Application A
\item Application B
\item Library A
\end{DoxyItemize}
\item Before installation application listbuilder will check for the installed applications. After checking for dependencies, Manifest \char`\"{}\+First\char`\"{} containing $>$$>$
\begin{DoxyItemize}
\item Application A
\item Application B
\item Library A are installed.   
\end{DoxyItemize}
\end{DoxyItemize}\\\cline{1-2}
&\\\cline{1-2}
 &

{\bfseries Dependency Example 2}



Software Package contents\+:


\begin{DoxyItemize}
\item Application E and Library C (provided contents)
\item Manifest \char`\"{}\+Third\char`\"{} has dependency of $>$$>$
\begin{DoxyItemize}
\item Application A
\item Manifest \char`\"{}\+Second\char`\"{}
\begin{DoxyItemize}
\item Manifest \char`\"{}\+Second\char`\"{} has dependency of $>$$>$
\begin{DoxyItemize}
\item Application A
\item Application B
\item Library A
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}
\item Installation sequence $>$$>$
\begin{DoxyItemize}
\item 1)Manifest \char`\"{}\+Third\char`\"{} contains $>$$>$
\begin{DoxyItemize}
\item Application A
\end{DoxyItemize}
\item 2)Followed by Manifest \char`\"{}\+Second\char`\"{} containing $>$$>$
\begin{DoxyItemize}
\item Application A
\item Application B
\item Library A   
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}\\\cline{1-2}
\end{longtabu}


\subsection*{5. Software Package Management}

The U\+CM update sequence consists of three different phases\+:


\begin{DoxyItemize}
\item {\bfseries Software Package transfer}\+: Phase in which, one or several Software Packages are transferred from the Diagnostic Application Client to the internal buffer of the U\+CM.
\item {\bfseries Software Package processing}\+: Phase in which the U\+CM performs the operation (k\+Install, k\+Update, k\+Remove) on the relevant Software\+Cluster (which will be inactivated \mbox{[}not executed\mbox{]} during the operation).
\item {\bfseries Activation}\+: Phase in which the U\+CM checks the dependencies of the Software\+Clusters that have been involved in the operation, activates them and finally checks that all the Software\+Clusters can be executed properly prior to finishing the update.
\end{DoxyItemize}

\subsubsection*{5.\+1 Transferring Software Packages}

Each Software Package gets its own state as soon as it is being transferred to U\+CM. During this lifecycle, a Software Package is uniquely identified with a {\bfseries Transfer\+Id} that U\+CM provides to the client.




\begin{DoxyItemize}
\item U\+CM provides support to transfer Software Packages at any time when U\+CM is running. Transferring is decoupled from the U\+CM Package Management states.
\item Data transfer starts with method {\bfseries Transfer\+Start(size of pkg)}. Number of bytes to be transferred is provided by the client. On successful allocation of resources, U\+CM assigns a {\bfseries Transfer id} for the Software Package to be transferred.
\item {\bfseries Transfer\+Data(id, buffer, block counter)} method supports the transmission of the Software Package block-\/wise.
\item {\bfseries Transfer\+Exit(\+Transfer id)} is called on a successful transfer of Software Package.
\item Handling of multiple data transfers in parallel will be supported by U\+CM. While a software package is being transferred, if U\+CM receives a subsequent {\bfseries Transfer\+Start()} call targeting another software package, U\+CM will make sure the U\+CM buffer size does not exceed.
\item The processing (i.\+e. unpacking and actually applying changes to the A\+U\+T\+O\+S\+AR Adaptive Platform) of Software Packages is described by the state k\+Processing .
\item {\bfseries Delete\+Transfer(id)} is a method that will delete the targeted Software Package and free the resources reserved to store that Software Package.
\item If {\bfseries Transfer\+Data() or Transfer\+Exit()} is called without prior call to {\bfseries Transfer\+Start()} U\+CM will raise the {\bfseries Application\+Error Operation\+Not\+Permitted}.
\end{DoxyItemize}

\subsubsection*{5.\+2 Processing Software Packages}

In contrast to package transmission, only one Software Package can be processed at the same time to ensure consistency of the system.


\begin{DoxyItemize}
\item A software or package processing can involve any combination of an installation, update or removal of applications, configuration data, calibration data or manifests.
\item U\+CM provides a method {\bfseries Process\+Sw\+Package(id)} to process transferred Software Package.
\item U\+CM will support processing of several Software Packages by calling method {\bfseries Process\+Sw\+Package()} several times in sequence.
\item {\bfseries Get\+Sw\+Process\+Progress()} method provides the percentage of progress of the package.
\item U\+CM will raise the {\bfseries Application\+Error Package\+Inconsistent} in case the package to be processed is not consistent.
\item U\+CM provides a method {\bfseries Cancel(id)} to cancel the running package processing. U\+CM will then immediately abort the current package processing task and undo the required changes.
\end{DoxyItemize}

\subsubsection*{5.\+3 Status Reporting}

In contrast to the transmission, the processing and activation tasks happen in a strict sequential order.\+The global state of U\+CM can be queried using the field {\itshape Current\+Status}.


\begin{DoxyItemize}
\item {\itshape k\+Idle} will be the default state. Once {\bfseries Process\+Sw\+Package()} is performed successfully, this state will only be entered if a Clean-\/up has been performed successfully.
\item {\itshape k\+Busy} state will be set only if {\bfseries Process\+Sw\+Package()} has been called. This is possible, if {\itshape Current\+Status -\/$>$ k\+Idle or k\+Ready}.
\item Busy state will be exited
\begin{DoxyItemize}
\item when calling of {\bfseries Process\+Sw\+Package() or Revert\+Processed\+Sw\+Packages()} has finished.
\item when the processing of the package is interrupted by calling {\bfseries Cancel()}. 
\end{DoxyItemize}

State reported by Current\+Status \+:
\begin{DoxyItemize}
\item {\itshape k\+Cleaning-\/up} -\/ in case of a {\bfseries Revert\+Processed\+Sw\+Packages()} call.
\item {\itshape k\+Ready} -\/ in case of a {\bfseries Process\+Sw\+Package()} completion or in case of a {\bfseries Cancel()} call.
\end{DoxyItemize}
\item Ready state will be reported
\begin{DoxyItemize}
\item after the package processing is finished successfully.
\item {\bfseries Cancel()} has been performed.
\item when {\bfseries Activate()} fails due to an {\bfseries Application\+Error Missing\+Dependencies}.
\end{DoxyItemize}
\item Activating state of Package Management {\itshape k\+Activating} will be set
\begin{DoxyItemize}
\item when {\bfseries Activate} is called. 
\end{DoxyItemize}

After {\bfseries Activate} was performed successfully (all dependencies are satisfied), the system has to be restarted in case a A/B partition is used. In case A/B partition is not used, all affected Function Groups or the platform could be restarted. Immediately after the processed Software Cluster has been restarted, a system check has to be performed in order to make sure the system is able to start up as expected. 
\item Activated state of Package Management {\itshape k\+Activated} state gives the client controlling the update process a chance to perform verification test. If the system check was successful, the client can decide either to Rollback to the previous processed working software, or to perform {\bfseries Finish} so that the changes of processed software become permanent.
\item By calling {\bfseries Finish()} a clean-\/up is initiated. In case of A/B partition, a swap between the partitions happens and the newly inactive partition becomes a copy of the newly active partition. On a successful {\bfseries Finish()} (including cleanup), {\itshape Current\+Status} changes to {\itshape k\+Idle}.
\item Calling {\bfseries Rollback()} sets U\+CM into {\itshape k\+Rolling\+Back} state where original software version is made executable and to {\bfseries k\+Rolled\+Back} state when the original software is activated by the State Management. U\+CM will switch the state into {\bfseries k\+Cleaning-\/up} state when {\bfseries Finish() or Revert\+Processed\+Sw\+Packages()} is called. k\+Idle will be set when Finish() is called and the clean-\/up has been successfully performed.
\end{DoxyItemize}

\subsubsection*{5.\+4 Activation and Rollback}

\paragraph*{5.\+4.\+1 Activation}


\begin{DoxyItemize}
\item The installed Software\+Cluster does not express whether a Software\+Cluster is currently executed or not.
\item When {\bfseries Activate()} is called, U\+CM will check if dependencies for the Software\+Clusters are all fulfilled. Unfulfilled dependencies will raise the {\bfseries Application\+Error Missing\+Dependencies}.
\item The activation method could either lead to a full system reset or restart of Function Groups impacted by the Software Package.
\item The U\+CM does not trigger the restart of processed software. This needs to be performed by the client application. This is due to the fact that such restart might need to be synchronized between several Platforms/\+E\+C\+Us.
\item U\+CM will switch from Activating state to Activated state when the State Management Function\+Group\+State field notifies that the updated software is executed successfully.
\end{DoxyItemize}

 \paragraph*{5.\+4.\+2 Rollback}


\begin{DoxyItemize}
\item U\+CM will provide a method {\bfseries Rollback()} to recover from an activation that went wrong. Rollback can be called in the case of A/B partitions or if U\+CM uses some other solution to maintain backups of updated or removed Software Packages.
\item During Rolling-\/\+Back U\+CM will disable the changes done by the software update.
\item While Rolling-\/\+Back, U\+CM can forcefully shutdown the newly processed software (i.\+e the one that needs to be the Rolled-\/back).
\end{DoxyItemize}

\paragraph*{5.\+4.\+3 Boot options}


\begin{DoxyItemize}
\item U\+CM will manage which version of software is available for the Execution Management to launch.
\item During the {\itshape k\+Activating} state U\+CM modifies the Boot options so that in the next restart of the updated software the new versions will be executed.
\item In the {\itshape k\+Rolling\+Back} state U\+CM modifies the Boot options so that in the next restart of the updated software the original versions will be executed.
\end{DoxyItemize}

\subsubsection*{5.\+5 Software Cluster Lifecycle}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
 &

The {\bfseries state machine} in the figure describes the states of a Software\+Cluster \+:



-\/ The new Software\+Cluster starts its lifecycle with state {\itshape k\+Added}.



-\/ After finishing update process with method Finish, it is in state {\itshape k\+Present}.



-\/ In another update process, by processing a Software Package with new data for the Software\+Cluster, it changes to {\itshape k\+Updated}.



-\/ Returns to {\itshape k\+Present} once update process has finished. If a Software Package is processed and it involves the deletion of an existing Software\+Cluster the state changes to {\itshape k\+Removed}.

\\\cline{1-2}
\end{longtabu}


\subsubsection*{5.\+6 Version Reporting}

-\/ U\+CM provides a method {\bfseries Get\+Sw\+Cluster\+Info()} to provide the identifiers and versions of the Software\+Clusters that are in state {\itshape k\+Activated}.

-\/ U\+CM provides a method {\bfseries Get\+Sw\+Cluster\+Change\+Info()} to provide the identifiers and versions of the Software\+Cluster that are in state {\itshape k\+Added, k\+Updated or k\+Removed}.

\subsection*{6. Dependencies to other Functional Clusters}

1) Interfaces to Adaptive State Management
\begin{DoxyItemize}
\item Few applications can conflict with the update process and might need to be stopped during the update process. This will be achieved by putting the machine to a safe Machine State, for example {\bfseries Update State}, or by activating a combination of suitable Function Groups and its states. It is the responsibility of the platform integrator to define this state or Function Groups. The application accessing the U\+CM, should make sure that the platform is switched to this state, before starting an update. U\+CM uses State Management interface field parameter {\bfseries Function\+Group\+State} to monitor the restart of the updated software.
\end{DoxyItemize}

2) U\+CM service over ara\+::com
\begin{DoxyItemize}
\item U\+CM provides a service interface over ara\+::com using methods and fields.
\end{DoxyItemize}

3) Interfaces to Adaptive Crypto Interface
\begin{DoxyItemize}
\item U\+CM uses Crypto Interface for Adaptive Platform to verify package integrity and authenticity and to decrypt confidential update data.
\end{DoxyItemize}

4) Interfaces to Identity and Access Management
\begin{DoxyItemize}
\item Communication Management,uses Identity and Access Management to validate the authorization of requests made to U\+C\+M’s service interface Package\+Management.
\end{DoxyItemize}

\subsection*{7. Service Interfaces}

Service Interface Package\+Management -\/ Field

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
Field&Description \\\cline{1-2}
Current\+Status&The current status of U\+CM. \\\cline{1-2}
\end{longtabu}


Service Interface Package\+Management -\/ Methods

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
Method&Description \\\cline{1-2}
Get\+Sw\+Cluster\+Info()&Retrieve a list of Software\+Clusters. 

\\\cline{1-2}
Get\+Sw\+Cluster\+Change\+Info()&This method returns a list pending changes to the set of Software\+Clusters on the adaptive platform. The returned list includes all Software\+Clusters that are to be added, updated or removed. 

\\\cline{1-2}
Get\+Sw\+Packages&This method returns a list of all Software Packages that have been successfully transferred and are ready to be installed. 

\\\cline{1-2}
Transfer\+Start(buffer size)&Start the transfer of a Software Package. The size of the Software Package to be transferred to U\+CM must be provided. U\+CM will generate a Transfer ID for subsequent calls to Transfer\+Data, Transfer\+Exit, Process\+Sw\+Package. 

\\\cline{1-2}
Transfer\+Data(transfer id, data, block counter)&Block-\/wise transfer of a Software Package to U\+CM. 

\\\cline{1-2}
Transfer\+Exit(transfer id)&Finish the transfer of a Software Package to U\+CM. 

\\\cline{1-2}
Delete\+Transfer(transfer id)&Delete a transferred Software Package. 

\\\cline{1-2}
Process\+Sw\+Package(transfer id)&Process a transferred Software Package. 

\\\cline{1-2}
Revert\+Processed\+Sw\+Packages()&Reverts the changes done by processing (Process\+Sw\+Package) of one or several software packages. 

\\\cline{1-2}
Get\+Sw\+Process\+Progress(transfer Id)&Get the progress (0 -\/ 100\%) of the currently processed Software Package. 

\\\cline{1-2}
Cancel(transfer Id)&This method aborts an ongoing processing of a Software Package. 

\\\cline{1-2}
Rollback()&Rollback the system to the state before the packages were processed. 

\\\cline{1-2}
Activate(transfer id)&This method activates the processed software components. 

\\\cline{1-2}
Finish()&Finish the processing for the current set of processed Software Packages. Cleanup all data of the processing including the sources of the Software Packages. 

\\\cline{1-2}
\end{longtabu}
\hypertarget{adaptive_configurationmethodology}{}\section{Configuration Methodology}\label{adaptive_configurationmethodology}
The Adaptive Platform is usually not exclusively used within a single A\+U\+T\+O\+S\+AR System as the vehicle is also equipped with a number of E\+C\+Us developed on the A\+U\+T\+O\+S\+AR Classic Platform. The System design for the entire vehicle will therefore cover both E\+C\+Us built using Classic Platform(\+C\+P) as well as Machines using the Adaptive Platform(\+A\+P).


\begin{DoxyItemize}
\item The Function Architecture is composed of a number of function networks. A function network consists of a set of function blocks with their interfaces and corresponding interconnections.
\item Function Architecture is one of the input to deduce Common Software Architecture. The Common Software Architecture provides a dedicated view of all software entities and their communication relation within the E/E vehicle system. In this light, the Common Software Architecture comprises both types, A\+U\+T\+O\+S\+AR software components of the Classic Platform as well as those entities that form later an Adaptive Application Software deployed to an Adaptive Platform-\/based machine.
\item The communication entry and exit points of components are ports typed by a particular interface definition. In case of the Adaptive Platform, interfaces are expressed as Service Interfaces. The Common Software Architecture can be specified by means of the System Description.
\end{DoxyItemize}

 {\bfseries System\+:} Like for the CP methodology, this development domain will cover activities which refine the Common Software Architecture into a system defined by specific E\+C\+Us or machines. The overall system which talk about the refinement of the V\+FB by the definition of a topology of E\+C\+Us and networks and the deployment of software components onto E\+C\+Us, with the extensions necessary for the Common Software Architecture and the additions to specify machines and the corresponding mapping of machines to E\+C\+Us.

\section*{1. Development Workflow}



\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*3{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Task Definition }&{\bf Responsibility }&{\bf Task Description  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Task Definition }&{\bf Responsibility }&{\bf Task Description  }\\\cline{1-3}
\endhead
Develop a Service Interface Description &O\+EM &This activity describes the definition of the service interfaces, aggregating events, methods and fields, including the definition of data types \\\cline{1-3}
Develop Adaptive Software (Application/\+Platform) &Tier1/\+Tier2 &Develop an Adaptive Application with category application-\/level or platform level. \\\cline{1-3}
Develop the communication structure by means of Machine\+Design &O\+EM &Define and configure network connections and configure the SD message \\\cline{1-3}
Create Diagnostic Mapping &O\+EM &A diagnostic mapping is used to establish relation between adaptive diagnostic management and endpoints in the application software so that SD can connect the corresponding end points correctly \\\cline{1-3}
Design Communication between CP and AP &O\+EM &All activities which are necessary to design communication between two platforms \\\cline{1-3}
Integrate the Software Components &Tier 1 &The compiled Software and one main function are integrated into one executable \\\cline{1-3}
Select OS Distribution &Tier 2 &Select and Assemble an Operating System \\\cline{1-3}
Define and Configure Machine &Tier 1/2 &This includes the configuration of all machine states, function groups and the available hw resources and configure Adaptive Autosar platforms \\\cline{1-3}
Create Application Manifest &Tier 1 &In this activity, processes, startup configuration and execution dependencies for the application will be defined \\\cline{1-3}
Define and Configure Service Instance &O\+E\+M/\+Tier 1 &Define the service instances, configure their search or offer criteria and map service instance to prototype \\\cline{1-3}
Setup initial Machine &Tier 1/2 &Configure and Install OS and other necessary platform modules on the machine \\\cline{1-3}
Create Software Package &Tier 1 &Creation of Software Package \\\cline{1-3}
Provide and Manage Software Packages &O\+EM &Deploy and store software package on a back-\/end server \\\cline{1-3}
\end{longtabu}
\subsection*{1 Software Configuration}

\subsubsection*{1.\+1 Configure Data Types}

The specification of data types on the A\+U\+T\+O\+S\+AR adaptive platform follows the same pattern as the counterpart on the A\+U\+T\+O\+S\+AR classic platform\+: data types are defined on different levels of abstraction that complement each other. ~\newline
 In Adaptive Autosar we focus on two data types.
\begin{DoxyItemize}
\item Implementation\+Datat\+Types
\item Application\+Data\+Types
\end{DoxyItemize}

\paragraph*{1.\+1.\+1 Implementation\+Data\+Types}

A subset of the modeling of Implementation\+Data\+Types that is supported on the A\+U\+T\+O\+S\+AR classic platform can directly be used on the A\+U\+T\+O\+S\+AR adaptive platform as well



\paragraph*{1.\+1.\+2 Application\+Data\+Types}

Application\+Data\+Type defines a data type from the application point of view. Especially it should be used whenever something \char`\"{}physical\char`\"{} is at stake.~\newline
 An Application\+Data\+Type represents a set of values as seen in the application model,such as measurement units. It does not consider implementation details such as bit-\/size, endianess, etc.



\subsubsection*{1.\+2 Configure a Service Interface}

This represents the ability to define a Port\+Interface that consists of a heterogeneous collection of methods, events and fields. Service interfaces can consist of events, methods and fields and are the basis for the generation of header files for a software component.  \subsubsection*{Example Service Interface}



\subsubsection*{1.\+3 Configure Service Interface Deployment}

The different meta-\/class specializations of {\bfseries Service\+Interface\+Deployment} define a binding of a Service\+Interface to a middleware transport layer.~\newline
 In Service\+Interface\+Deployment Configure following Attributes ~\newline

\begin{DoxyItemize}
\item {\bfseries Service\+Method\+Deployment} ~\newline
 The Service\+Method\+Deployment meta-\/class provides the ability to define middleware transport layer specific configuration settings relevant for a method that is defined in the context of a Service\+Interface. ~\newline

\item {\bfseries Service\+Event\+Deployment} ~\newline
 The Service\+Event\+Deployment meta-\/class provides the ability to define middleware transport layer specific configuration settings relevant for an event that is defined in the context of a Service\+Interface. ~\newline

\item {\bfseries Service\+Field\+Deployment} ~\newline
 The Service-\/\+Field\+Deployment meta-\/class provides the ability to define middleware transport layer specific configuration settings relevant for a field that is defined in the context of a Service\+Interface. ~\newline

\end{DoxyItemize}



\subsubsection*{1.\+4 Configure Provided Some\+Ip Service Instance}

The Provided\+Someip\+Service\+Instance defines the service\+Instance\+Id for the Service Instance of the Someip\+Service\+Interface\+Deployment that is referenced with the service\+Interface reference.~\newline
 It means that the Server on which the Provided\+Someip\+Service\+Instance is deployed offers the Service Instance over S\+O\+M\+E/\+IP with the service\+Instance\+Id and service\+Interface\+Id.



\subsubsection*{1.\+5 Configure Required Some\+Ip Service Instance}

The Required\+Someip\+Service\+Instance defines the required-\/\+Service\+Instance\+Id of a Someip\+Service\+Interface\+Deployment that the client searches.



\subsubsection*{1.\+6 Configure Application Manifest}

The purpose of the application manifest is to provide information that is needed for the actual deployment of an application (formally modeled as an Sw\+Component\+Type) onto the A\+U\+T\+O\+S\+AR adaptive platform.
\begin{DoxyItemize}
\item To instantiate the same application software several times on the same machine
\item To deploy the application software to several machines and instantiate the application software per machine
\end{DoxyItemize}

\paragraph*{1.\+6.\+1 Configure Adaptive\+Application\+Sw\+Component}

This meta-\/class represents the ability to support the formal modeling of application. software on the A\+U\+T\+O\+S\+AR adaptive platform. Consequently, it shall only be used on the A\+U\+T\+O\+S\+AR adaptive platform. ~\newline
 In sw Component Configure Following elements ~\newline

\begin{DoxyItemize}
\item R Port Prototype ~\newline
 Provide Required Someip\+Service\+Interface Reference for Service
\item P Port Prototype ~\newline
 Provide Provided Someip\+Service\+Interface Reference for Service
\end{DoxyItemize}



\paragraph*{1.\+6.\+2 Configure Executable}

This meta-\/class represents an executable program.~\newline
 It should have reference to Adaptive\+Application\+Sw\+Component which needs to be execute



\paragraph*{1.\+6.\+3 Configure Processes}

This meta-\/class provides information required to execute the referenced executable.



\subsubsection*{1.\+7 Map Service Instance To Port Prototype}

Configure Which service instance should use which port. Service\+Instance\+To\+Port\+Prototype\+Mapping is used to assign an Adaptive\+Platform\+Service\+Instance to a Port\+Prototype of a Sw\+Component\+Type. This allows to define how specific Port\+Prototypes of a Software Component are represented in the middleware in terms of the service configuration



\subsection*{2. Hardware Configuration}

\subsubsection*{2.\+1 Configure Ether\+Net Cluster}

It is the main element to describe the topological connection of communicating E\+C\+Us. A cluster describes the ensemble of E\+C\+Us, which are linked by a communication medium of arbitrary topology (bus, star, ring, ...). The nodes within the cluster share the same communication protocol, which may be event-\/triggered, time-\/triggered or a combination of both. ~\newline
 Configure the Following elements In Ethernet Cluster.~\newline
 1)Ether\+Net Physical Channel~\newline
 i) Network Endpoints
\begin{DoxyItemize}
\item Ipv4 Configuration
\item Ipv6 Configuration
\end{DoxyItemize}

ii) Communication Connector Ref Conditional ~\newline
 Provide Reference To The Machine Design Communication Connectors.



\subsubsection*{2.\+2 Configure Machine Manifest}

The Machine meta-\/class defines the entity on which one Adaptive A\+U\+T\+O\+S\+AR Software Stack is running with an operating system. The Machine may be physical or virtual. In A\+U\+T\+O\+S\+AR adaptive the element Machine is an entity which already represents a specific E\+CU Implementation with dedicated configurations for e.\+g. Processors,machine\+Mode\+Machines, function\+Groups. The Machine is a model entity which is not in the focus of communication designers and should not be used during system design.~\newline
 The Machine Manifest focuses on the following aspects\+:
\begin{DoxyItemize}
\item Configuration of the network connection and defining the basic credentials for the network technology (e.\+g. for Ethernet this involves setting of a static IP address or the definition of D\+H\+CP)
\item Configuration of the service discovery technology (e.\+g. for S\+O\+M\+E/\+IP this involves the definition of the IP port and IP multicast address to be used)
\item Definition of the used machine states
\item Definition of the used function groups
\item Configuration of the adaptive platform functional cluster implementations (e.\+g. the operating system provides a list of OS users with specific rights)
\item Configuration of the Crypto platform Module
\item Configuration of Platform Health Management
\item Configuration of Time Synchronization
\item Documentation of available hardware resources (e.\+g. how much R\+AM is available; how many processor cores are available)
\end{DoxyItemize}

\paragraph*{2.\+2.\+1 Configure Machine Design}

The Machine\+Design has been introduced in order to allow the communication system designer to define a placeholder for an adaptive E\+CU in the scope of the System (the Machine\+Design corresponds to the Ecu\+Instance of A\+U\+T\+O\+S\+AR classic) -\/\+This meta-\/class represents the ability to define requirements on a Machine in the context of designing a system  \paragraph*{2.\+2.\+1.\+1 Configure network Connection}

One of the most prominent information defined in the context of the Machine\+Design is the network connectivity. Since the A\+U\+T\+O\+S\+AR adaptive platform focuses on the usage of Ethernet for communication, this boils down to the specification of IP addresses.
\begin{DoxyItemize}
\item Configure Communication connector for Ethernet cluster and provide Network endpoint for using ip address.
\item Configure Service discovery with Some ip service discovery port
\end{DoxyItemize}

\paragraph*{2.\+2.\+2 Configure Machine}

Machine that represents an Adaptive Autosar Software Stack. Provide reference to Machine\+Design.



\subsection*{3 Map Hardware and Software Configuration}

\subsubsection*{3.\+1 Service Instance to Machine Mapping}

This allows to map Service\+Instances to a Communication\+Connector of a Machine.



\subsection*{4 Configure Execution Manifest}

The purpose of the execution manifest is to provide information that is needed for the actual deployment of an application (formally modeled as an Sw\+Component\+Type) onto the A\+U\+T\+O\+S\+AR adaptive platform. 

\subsubsection*{4.\+1 Configure Startup}

The configuration of startup behavior is an essential part of the execution manifest.

\subsubsection*{4.\+2 Configure Mode-\/dependent Startup Configuration}

The purpose of meta-\/class Mode\+Dependent\+Startup\+Config is to qualify the startup configuration represented by meta-\/class Startup\+Config for specific Mode\+Declarations. Each Mode\+Dependent\+Startup\+Config of a Process shall reference at least one Mode\+Declaration in the role function\+Group\+Mode or in the role machine\+Mode \hypertarget{adaptive_persistency}{}\section{Persistency}\label{adaptive_persistency}

\begin{DoxyItemize}
\item \hyperlink{peristency_overview}{Persistency} 
\end{DoxyItemize}\hypertarget{peristency_overview}{}\subsection{Persistency}\label{peristency_overview}
\subsection*{1. Overview}

{\bfseries Persistency} offers mechanisms to applications and other functional clusters of the Adaptive Platform to store information in the non-\/volatile memory of an Adaptive Machine.

Responsibilities of the Persistency\+:
\begin{DoxyItemize}
\item Persistently stored data is available over boot and ignition cycles
\item Loads data which is persistently stored
\item Accesses data using an unique identifier
\item Reads and writes data from file-\/like structures
\item Encrypts/\+Decrypts the persistent data
\item Error detection and correction of stored data 
\end{DoxyItemize}

\subsubsection*{1.\+1 Available Storage locations in persistency}


\begin{DoxyItemize}
\item {\bfseries  Key-\/\+Value Storage } provides a mechanism to store and retrieve multiple Key-\/\+Value pairs in one storage location. The keys need to be unique for each Key-\/\+Value database and are defined by an application using the methods provided by the Persistency.
\item {\bfseries  File-\/\+Proxy Storage } A File-\/\+Proxy Port allows an application to access a storage location and create one or multiple accessors in it. These accessors again are identified by unique keys in string format.
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
{\bfseries Key-\/\+Value Storage } &{\bfseries File-\/\+Proxy Storage }  \\\cline{1-2}
Used to store and retrieve multiple Key-\/\+Value pairs in one storage location and key should be unique. Basically holds\+: 1) Data types defined in S\+W\+S\+\_\+\+Adaptive\+Platform\+Types. 2) Simple byte arrays that result from a streaming of complex types in the application. 3) All Implementation Data Types. &Used to support large chunk of data and allows application to access a storage location and create one or multiple accessors in it. These accessors again are identified by unique keys in string format. Example\+: It is filesystem directory in which an application is allowed to create multiple files (accessors).  \\\cline{1-2}
\end{longtabu}


\subsubsection*{1.\+2 Architectural concepts}

Persistent data is always private to one application. This design decision was taken to prevent second communication path beneath the functionality provided by Communication Management. If persistent data needs to be shared between multiple applications, it is the duty of an application developer to provide Service Interfaces for communication.

\subsubsection*{1.\+3 Security concepts}


\begin{DoxyItemize}
\item The Persistency cluster shall encrypt data before storing it to the persistent memory according to Crypto need.
\item The Persistency cluster shall decrypt data data after reading it from the persistent memory according to Crypto need.
\end{DoxyItemize}

\subsubsection*{1.\+4 Redundancy concepts}

The implementer of the Persistency functional cluster shall take care of the error detection and error correction mechanisms which are implementation specific.

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*3{|X[-1]}|}
\hline
{\bfseries Enumeration} &{\bfseries Value} &{\bfseries Persistency\+Redundancy\+Enum}  \\\cline{1-3}
none&1&This value represents the requirement that a piece of data to be stored persistently shall not end up in a redundant persistent storage facility.  \\\cline{1-3}
redundant&0&This value represents the requirement that a piece of data to be stored persistently shall end up in a redundant persistent storage facility.\\\cline{1-3}
\end{longtabu}


\subsection*{2. Persistency -\/ Persistent data over U\+CM}

{\bfseries Update and Configuration Management handles 3 main use cases for handling of Adaptive Application}
\begin{DoxyItemize}
\item Installation of new software
\item Update of already installed software
\item Uninstallation of installed software
\end{DoxyItemize}

Persistency needs for U\+CM\+:
\begin{DoxyItemize}
\item Deployment of persistent data that was defined by an application designer
\item Deployment of persistent data that was defined by an application designer and changed by an integrator
\item Deployment of persistent data that was defined by an integrator
\item Definition of update strategies for persistent data when a new version of an application is installed
\item Removing persistent data when an application is uninstalled 
\end{DoxyItemize}

\subsubsection*{2.\+1 Installation of Key-\/\+Value-\/\+Databases}


\begin{DoxyItemize}
\item Persistency shall create an entry containing the Persistency Data Element in the Persistency Key-\/\+Value Database Interface which is addressed by Port Prototype.
\item The created entry in the Key-\/\+Value-\/\+Database shall have the short\+Name of the Persistency\+Data\+Element as key.
\item The created entry in the Key-\/\+Value-\/\+Database shall be of the datatype defined in Persistency\+Data\+Element.
\item The value of the created entry in the K\+VS db shall be taken from the {\bfseries Persistency\+Data\+Required\+Com\+Spec.\+init\+Value} , if no Persistency Key-\/\+Value Pair with the same short Name as the Persistency Data Element exists in the Persistency KV db for the corresponding Adaptive application Mode(w.\+r.\+t process defined).
\item The value of the created entry in the KV db shall be taken from the {\bfseries Persistency\+Key\+Value\+Pair.\+init\+Value}, if a Persistency Key-\/\+Value Pair with the same short Name as the Persistency Data Element exists in the database for the corresponding Adaptive application Mode(w.\+r.\+t process defined).
\item If a Persistency Data Element exists that is neither referenced by a Persistency Data Required Com\+Spec with a {\bfseries Persistency\+Data\+Required\+Com\+Spec.\+init\+Value} nor a Persistency Key-\/\+Value Pair with the same short Name as the Persistency Data Element in the Persistency\+Key\+Value\+Database for the corresponding Adaptive application Mode(w.\+r.\+t process defined), no entry in the KV db shall be created.
\item Incompatible A\+U\+T\+O\+S\+AR datatypes are rejected.
\item During installation if the key-\/value pair with same Short name does not exist then persistency will create a new entry.
\item Short name of Persistency Key-\/\+Value-\/\+Pair will be the key.
\item The created entry in the KV db shall be of the datatype defined in {\bfseries Persistency\+Key\+Value\+Pair.\+value\+Data\+Type}.
\item The created entry in the KV db shall have the {\bfseries Persistency\+Key\+Value\+Pair.\+init\+Value} as value.
\item If {\bfseries Update\+Statergy} is defined as delete then no entry in the KV db shall be created.
\end{DoxyItemize}

\subsubsection*{2.\+2 Update of Key-\/\+Value-\/\+Databases}


\begin{DoxyItemize}
\item Same rules of Installation K\+VS is applicable but update\+Strategy parameter should be respected.
\item If update\+Strategy is \textquotesingle{}overwrite\textquotesingle{}, then entry to the KV db shall be created or overwritten with the new Key.
\item If update\+Strategy is \textquotesingle{}keep\+Existing\textquotesingle{}, no changes to the existing key value pair shall be done in the db if key already exists, else a new entry shall be created.
\item If update\+Strategy is delete, then entry to the KV db shall be deleted if key already exists, and no entry for the KV db shall be created.
\item If the final update\+Strategy is \textquotesingle{}keep\+Existing\textquotesingle{}, all Key-\/ Value-\/\+Pairs in the Key-\/\+Value-\/\+Database that are not explicitly modeled as Persistency\+Data\+Element or Persistency\+Key\+Value\+Pair shall be kept.
\item If the final update\+Strategy is \textquotesingle{}delete\textquotesingle{}, all Key-\/\+Value-\/\+Pairs in the Key-\/\+Value-\/\+Database that are not explicitly modeled as Persistency\+Data\+Element or Persistency\+Key\+Value\+Pair shall be deleted.
\end{DoxyItemize}

\paragraph*{2.\+2.\+1 Key-\/\+Value-\/\+Databases -\/ Update}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
{\bfseries Update\+Stategy Value } &{\bfseries Description}  \\\cline{1-2}
O\+V\+E\+R\+W\+R\+I\+TE&Persistency will create a new entry or overwrite an existing Key-\/\+Value-\/\+Pair with the same key.   \\\cline{1-2}
K\+E\+E\+P-\/\+E\+X\+I\+S\+T\+I\+NG&Persistency will keep existing Key-\/\+Value-\/\+Pair with the same key shall be kept in the Key-\/\+Value-\/\+Database, if doesn’t exist then new entry is created.  \\\cline{1-2}
D\+E\+L\+E\+TE&Persistency will not add new entry into the DB, if already exists with same key then delete.  \\\cline{1-2}
\end{longtabu}


\subsubsection*{2.\+3 Uninstallation of Key-\/\+Value-\/\+Databases}


\begin{DoxyItemize}
\item When deleting an Adaptive Application, Persistency shall delete all Key-\/\+Value-\/\+Databases used by this Adaptive Application from the Adaptive Machine.
\end{DoxyItemize}

\subsubsection*{2.\+4 Installation of File-\/\+Proxies}


\begin{DoxyItemize}
\item While installing a new Adaptive Application, for every Persistency\+File\+Proxy in a Persistency\+File\+Proxy\+Interface addressed by Port\+Prototype, Persistency shall create an entry in the File-\/\+Proxy.
\item The created entry in the File-\/\+Proxy shall have the {\bfseries Persistency\+File\+Proxy.\+file\+Name} as key.
\item The content of the created entry in the File-\/\+Proxy shall be taken from a file in the Software Package addressed by {\bfseries Persistency\+File\+Proxy.\+content\+Uri} if no Persistency\+File with the same short\+Name as the Persistency-\/\+File\+Proxy exists in the Persistency\+File\+Array that is mapped to the aggregating Port\+Prototype typed by the Persistency\+File\+Proxy\+Interface with a Persistency\+Port\+Prototype\+To\+File\+Array\+Mapping in the context of the Process of this Adaptive Application.
\item The content of the created entry in the File-\/\+Proxy shall be taken from a file in the Software Package addressed by {\bfseries Persistency\+File.\+content\+Uri}, if a Persistency\+File with the same short\+Name as the Persistency\+File\+Proxy exists in the Persistency\+File\+Array that is mapped to the aggregating Port\+Prototype typed by the Persistency\+File\+Proxy\+Interface with a Persistency-\/\+Port\+Prototype\+To\+File\+Array\+Mapping in the context of the Process of this Adaptive Application.
\item When installing a new Adaptive Application, for every Persistency\+File in a Persistency\+File\+Array that is mapped to a Persistency\+File\+Proxy\+Interface using a Persistency\+Port\+Prototype\+To\+File\+Array\+Mapping, Persistency shall create an entry in this File-\/\+Proxy if no Persistency\+File\+Proxy in the Port\+Prototype typed by the Persistency\+File\+Proxy\+Interface exists with the same short\+Name as the Persistency\+File.
\item The created entry in the File-\/\+Proxy shall have the {\bfseries Persistency\+File.\+file\+Name} as key.
\item The content of the created entry in the File-\/\+Proxy shall be taken from a file in the Software Package addressed by the {\bfseries Persistency\+File.\+content\+Uri}.
\item Persistency shall reject any configuration in which a Persistency\+File\+Proxy and a Persistency\+File with the same file\+Name but different short\+Names exist that are mapped by a Persistency\+Port\+Prototype\+To\+File\+Array\+Mapping referring to the Port\+Prototype typed by the Persistency\+File\+Proxy\+Interface and the Persistency\+File\+Array.
\item If the final update\+Strategy of an entry to be created is delete, no entry in the File-\/\+Proxy shall be created.
\end{DoxyItemize}

\subsubsection*{2.\+5 Update of File-\/\+Proxies}


\begin{DoxyItemize}
\item Same rules of File-\/\+Proxies is applicable as installation, but update\+Strategy parameter should be respected.
\item If update\+Strategy is \textquotesingle{}overwrite\textquotesingle{}, the entry to the File-\/\+Proxy shall be created and shall overwrite an existing entry with the same key.
\item If update\+Strategy is \textquotesingle{}keep\+Existing\textquotesingle{}, an existing entry with the same key shall be kept in the File-\/\+Proxy. If no entry with the same key exists, the entry to the File-\/\+Proxy shall be created.
\item If update\+Strategy is \textquotesingle{}delete\textquotesingle{}, an existing entry with the same key shall be deleted and no entry to the File-\/\+Proxy shall be created.
\item If the final update\+Strategy is \textquotesingle{}keep\+Existing\textquotesingle{}, all entries in the File-\/\+Proxy that are not explicitly modeled as Persistency\+File\+Proxy or Persistency\+File shall be kept.
\item If the final update\+Strategy is \textquotesingle{}delete\textquotesingle{}, all entries in the File-\/\+Proxy that are not explicitly modeled as Persistency\+File\+Proxy or Persistency\+File shall be deleted.
\end{DoxyItemize}

\paragraph*{2.\+5.\+1 File-\/\+Proxies -\/ Update}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
{\bfseries Update\+Stategy Value } &{\bfseries Description}  \\\cline{1-2}
O\+V\+E\+R\+W\+R\+I\+TE&Persistency will either create a new entry or overwrite an existing File-\/\+Proxy with the same key.   \\\cline{1-2}
K\+E\+E\+P-\/\+E\+X\+I\+S\+T\+I\+NG&Persistency will keep existing File-\/\+Proxy with the same key shall be kept in the File-\/\+Proxy, if doesn’t exist then new entry is created.  \\\cline{1-2}
D\+E\+L\+E\+TE&Persistency will not add new entry into the DB, if already exists with same key then delete.  \\\cline{1-2}
\end{longtabu}


\subsubsection*{2.\+6 Uninstallation of File-\/\+Proxies}


\begin{DoxyItemize}
\item When deleting an Adaptive Application, Persistency shall delete all File-\/\+Proxies used by this Adaptive Application from the Adaptive Machine. 
\end{DoxyItemize}\hypertarget{adaptive_state_manager}{}\section{State Manager}\label{adaptive_state_manager}

\begin{DoxyItemize}
\item State Management is responsible to determine the operation state, based on information received or gathered from other Adaptive Platform Applications or Adaptive Applications.
\item State Manager functional cluster determine the overall operation of Adaptive platform.
\item It would interact with Execution Manager to change functional group and machine state.
\item Adaptive Platform Functional clusters e.\+g. Diagnostic Manager and, Update and Configuration Manager can request the State Manager to change the state, depending on arbitration State Manager would change the state.
\item State Manager would arbitrate multiple request and signal to decide state change and State Manager implementation would be project spcific.
\end{DoxyItemize}

\subsection*{Glossary of Terms}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Term }&{\bf Definition  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Term }&{\bf Definition  }\\\cline{1-2}
\endhead
State Management &The element defining modes of operation for A\+U\+T\+O\+S\+AR Adaptive Platform. It allows flexible definition of functions which are active on the platform at any given time. \\\cline{1-2}
Execution Management &Functional Cluster within the Adaptive Platform Foundation. \\\cline{1-2}
Communication Management &A Functional Cluster within the Adaptive Platform Foundation. \\\cline{1-2}
Network Management &A Functional Cluster within the Adaptive Platform Services. Part of Communication Management. \\\cline{1-2}
Adaptive Diagnostics &A Functional Cluster within the Adaptive Platform Services. \\\cline{1-2}
Update And Configuration Management&A Functional Cluster within the Adaptive Platform Services. \\\cline{1-2}
Network Handle &Network Handles are provided by Network Management. A handle represents a set of (partial) networks. \\\cline{1-2}
Process &A process is a loaded instance of an Executable to be executed on a Machine. \\\cline{1-2}
Function Group &A Function Group is a set of coherent Processes, which need to be controlled consistently. Depending on the state of the Function Group, Processes are started or terminated. \\\cline{1-2}
Component &Element of a Process. Processes are comprised of one or more S\+W-\/entities that provide a particular function or group of related functions called Component. \\\cline{1-2}
Function Group State &The element of State Management that characterizes the current status of a set of (functionally coherent) user-\/level Applications. The set of Function Groups and their Function Group States is machine specific and are configured in the Machine Manifest. \\\cline{1-2}
Machine State &The state of Function Group \char`\"{}\+Machine\+State\char`\"{} with some predefined states (Startup/\+Shutdown/\+Restart). \\\cline{1-2}
Operational State &The element of State Management that characterizes the current internal state of the State Management. The Operational State is machine specific and depends on multiple events from somewhere within the system. \\\cline{1-2}
Component State &The element of State Management that characterizes the current state of Components within an Adaptive Application. The Component State is Adaptive Application specific and therefore it has to be described in the respective Execution Manifest. Every Adaptive Application provides at least an \char`\"{}\+On\char`\"{} and an \char`\"{}\+Off\char`\"{} State. \\\cline{1-2}
Execution Manifest &Manifest file to configure execution of an Adaptive Application. \\\cline{1-2}
Machine Manifest &Manifest file to configure a Machine. \\\cline{1-2}
\end{longtabu}
\subsection*{Dependencies of State Management}


\begin{DoxyItemize}
\item Operating System Interface\+:
\begin{DoxyItemize}
\item State Management has no direct interface to the Operating System, all OS dependencies are abstracted by the Execution Management and Persistency.
\end{DoxyItemize}
\item Execution Manager Interface\+:
\begin{DoxyItemize}
\item State Management is dependent on Execution Management to control operation state.
\item Execution Manager will fork or terminate an application depending upon the state requested and state defined in the application manifest.
\end{DoxyItemize}
\item Persistency\+:
\begin{DoxyItemize}
\item State Management is dependent on the Persistency functional cluster to access persistent storage.
\end{DoxyItemize}
\item Adaptive Diagnostics\+:
\begin{DoxyItemize}
\item State Manager will evaluate the information received from the Diagnostic Manager about the ongoing Session and decide the operational states based on the evaluation.
\end{DoxyItemize}
\item Update And Configuration Management\+:
\begin{DoxyItemize}
\item State Manager will interact with Update and Configuration Management to check the ongoing update session and decide the operation states.
\end{DoxyItemize}
\item Network Management\+:
\begin{DoxyItemize}
\item Network Management provides multiple Network\+Handle fields which represents a set of (partial) networks.
\item State Management evaluates this fields to set Function Groups to the corresponding Function Group State defined in Manifest and vice versa.
\item Additionally State Management shall prevent system from shutting down during an update session is ongoing.
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{State Manager Architecture\+:}


\begin{DoxyItemize}
\item State Manager communicate with execution manager for state change through A\+PI provided by execution manager i.\+e Get\+State(), Set\+State() which uses P\+O\+S\+IX F\+I\+FO.
\item It report its internal state i.\+e k\+Running , k\+Terminating back to Execution Manager through exec A\+PI.
\item Platform Health Manager interact with State Manager through service interface, in case State Manager does not respond back Platform Health Manager will also have an interface with Execution Manager to change state for recovery action.
\item It also has service interface defined for other application to interact with State Manager to notify and request for functional group state change as well as for component state.
\end{DoxyItemize}

\subsection*{State Management Responsibility\+:}


\begin{DoxyItemize}
\item State Management is the functional cluster responsible to communicate with the Execution Manager, determine the current operational state and request for transition to different operational state.
\item It ensures that the application are executed when it is actually needed and it also provide necessary resources granting them full control.
\item It is the central point where all events are received, further operational state transition will be decided after the evaluation is done based on event type, event priority and application identifier.
\item If an operational state change is triggered then State Manager will request the Execution Manager for a state change.
\item Operation state change can be triggered by multiple application which are as follows\+: • Platform Health Management to trigger error recovery, e.\+g. to activate fall back Functionality. • Adaptive Diagnostics, to switch the system into diagnostic states. • Update and Configuration Management to switch the system into states where software or configuration can be updated. • Network Management to coordinate required functionality and network state. • Authorized applications, e.\+g. a vehicle State Manager which might be located in a different machine or on a different E\+CU.
\item Autosar Application may trigger the State Manager events through ara-\/com interface where the State Manager will be subscribing.
\item It also provide interface to the Application to request information about the current state through ara-\/com.
\item State Manager has critical functionality, access is secured through the Identity Access Manager.
\item It is monitored and supervised by Platform health Manager which also has direct access to Execution Manager to change operational state when State Manager stops responding.
\item Operational state is the internal state of State Manager upon which decision will be made for next state change.
\end{DoxyItemize}

\subsection*{Machine State\+:}


\begin{DoxyItemize}
\item Machine state is specific type of function group state which refer to the global state of the machine.
\item State Manager will request the Execution Manager to change these state based on vehicle-\/wide event and priority evaluation.
\item Whenever State Manager requests Execution Manager for a state change, Execution Manager will terminate the application belonging to the current state and fork new application.
\item Machine state define the set of process to be forked by execution manager.
\item Each Application would have an application manifest, which defines the machine state in which the application is allowed to execute.
\item Adaptive Autosar Platform will have 3 mandatory machine state i.\+e Startup, Restart and Shutdown along with project specific machine state.
\item Startup will be the default machine state in Execution Manager and State Manager will control the operational flow henceforth.
\item Startup Machine State\+:
\begin{DoxyItemize}
\item Execution Manager will be controlled by State Manager hence it should not be able to change the machine state on its own.
\item Hence State Manager should run in each and every machine state or the Adaptive Platform will not be able to transit to any other machine state.
\item Startup will be the default machine state in Execution Manager and State Manager should also belong to Startup Machine state so that it can control the operational flow.
\end{DoxyItemize}
\item Shutdown State/\+Restart State\+:
\begin{DoxyItemize}
\item State Management will be configured to run in Shutdown/\+Restart.
\item State transition is not a trivial system change and it can fail for a number of reasons. When ever this happens State Management has to be alive, to report an error and wait for further instructions.
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{State Transition}


\begin{DoxyItemize}
\item Execution Manager is initiated after boot up, it will fork all application belonging to startup phase.
\item State Manager has Startup state defined in its execution manifest.
\item After State Manager is initialized it will decide the state change henceforth and request Execution Manager for state change.
\item Executiion Manager on request from State Manager will initiate state change, first it will send S\+I\+G\+T\+E\+RM signal to all application an indication for all application to terminate itself.
\item If the application doesnot terminate within the timeout specified in its execution mnifest execution terminate the application and confirm state change. 
\end{DoxyItemize}

\subsection*{Functional Group State}


\begin{DoxyItemize}
\item Machine state mechanism is not flexible enough to control a group of application which are functionally coherent, in particular if they have to be started and terminated with interleaving life-\/cycle.
\item Hence additional function group and functional group state can be configured.
\item During diagnostic and error recover it is necessary to handle such application using functional group state.
\item Machine state controls machine life-\/cycle and processes of platform level application while function group state control process functionally coherent user application.
\item State Manager will obtain available functional group state and machine state from machine manifest.
\item Processes refers in their execution manifest the state in which they want to execute, state can be functional group state and machine state.
\item Application is provided with communication interface with the State Manager to request functional group state change.
\item If there are multiple request from different application, State Manager would arbitrate based on priority and other factor before requesting Execution Manager for state change. 
\end{DoxyItemize}

\subsection*{State Management and Components state}


\begin{DoxyItemize}
\item Transition from one operational state to another usually require termination of application and forking new application.
\item When execution manager need to change the internal behaviour of process it needs to unload the process from memory and reload the executable, to avoid such overhead component state is used .
\item Component state is basically state inside a process where process can have one or multiple component i.\+e threads. 
\item Late-\/wakeup is an use-\/case of component state, where process can have ON or O\+FF state and threads corresponding to each state.
\item whenever shutting down is invoked process can execute O\+FF state threads, while shutting down new wake-\/up reason is found.
\item Instead of terminating the process and again loading the process, Component state i.\+e ON and O\+FF can be used.
\item O\+FF state would perform all the persistence data and ON state would resume the activity without terminating the process hence avoiding the overhead of unloading process from memory.
\end{DoxyItemize}

 \subsection*{Component state Handling}


\begin{DoxyItemize}
\item State management will calculate component state from current operational state and other requirement and send state to registered process.
\item Process need to register with State Manager via A\+PI interface to receive component state ,when components do not require component state it can unregister from State Manager.
\item Registration done by calling the constructor of component-\/client and un-\/registration is done by calling destructor.
\item Component are allowed to temporarily avoid component state change due ongoing critical execution. component has to send confirmation that it has received the state change request.
\item After certain timeout the State Manager will again request for component state change, this retry count and timeout values are configured in the execution manifest.
\item When maximum retries are over State Manager will force the process to transit into a component state.
\item Components must be able to perform a transition from any Component State into any Component State that they have defined. 
\end{DoxyItemize}

\subsection*{Interaction with Diagnostic Manager}


\begin{DoxyItemize}
\item Adaptive Diagnostics is responsible for diagnosis, configuration and resetting of Function Groups. During any diagnostic request is executed it is necessary to prevent system from shutting down.
\item State Management shall not shutdown the system during an active diagnostic session. Therefore State Management has to register to Adaptive Diagnostics to receive information about active diagnostic session.
\item Adaptive Diagnostic have several reset type i.\+e hard\+Reset, soft\+Reset and key\+Off\+On\+Reset to carry out functionalities of diagnostic.
\item State Manager would translate this reset and send equivalent component state to the process.
\item A hard\+Reset could be interpreted as Hardware reset while soft\+Reset could be interpreted as loading the software configuration and key\+O\+F\+F\+On\+Reset could mean restarting the functional group state.
\item State Manager also has functionality to persist the reset cause while resetting the Machine state.
\item State Manager will also read the last reset cause when spawned by execution manager and set the persist data to default value.
\end{DoxyItemize}

\subsection*{Interaction with the Update and Configuration Management}


\begin{DoxyItemize}
\item State Manager has to register with the update and Configuration Management to receive information about the ongoing update and It will not shutdown the system while the update is going on.
\item Update and verify state should be available to enable the update and Configuration Management to fulfill its functionality.
\item Update and Configuration Management would request for the corresponding state from State Manager.
\item When a platform software is updated which needs a Machine reset State Manager should have means to reset the machine.
\item If an application software is updated which doesn\textquotesingle{}t need system reset the State Manager should have meant to trigger execution manager to re-\/parse the manifest update the application list.
\end{DoxyItemize}

\subsection*{Interaction with Network Management}


\begin{DoxyItemize}
\item State Management interacts with Network Management via a service interface.
\item Network Management provides multiple instances of Network\+Handles, where each represents a set of (partial) networks.
\item The Network\+Handles are defined in the Machine Manifest and are there assigned to a Function Group State.
\item Whenever network is activated or deactivated due outside request corresponding handle is set which is notified to State Manager which in turn would change the corresponding functional group state.
\item Similarly State Manager would change the network handle when functional group is changed and the association between functional group and network handle is available in Machine Manifest.
\item It might be needed that a Function Group stays longer in its Function Group State when the causing (partial) network set has been switched off network is longer available than the causing Function Group has been switched to Function Group State ’\+Off’. This is called ’afterrun’. The corresponding timeoutvalue has to be configured in Machine Manifest. 
\end{DoxyItemize}\hypertarget{Porting_rocko}{}\section{Porting Adaptive Platform to Rocko}\label{Porting_rocko}
\subsection*{Checkout Adaptive platform and other B\+S\+Ps}


\begin{DoxyEnumerate}
\item Install the Pre-\/requisites 
\begin{DoxyCode}
1 $home: sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib \(\backslash\)
2                     build-essential chrpath socat libsdl1.2-dev xterm repo
\end{DoxyCode}

\item Download the Adaptive platform demostrator 18-\/06 release 
\begin{DoxyCode}
1 $ mkdir fsl-auto-yocto-bsp
2 & cd fsl-auto-yocto-bsp
3 $ fsl-auto-yocto-bsp$: git clone ssh://git@code.autosar.org/tf-apd/ara-api
4 $ fsl-auto-yocto-bsp$: git clone ssh://git@code.autosar.org/tf-apd/sample-applications
5 $ fsl-auto-yocto-bsp$: git clone ssh://git@code.autosar.org/tf-apd/yocto-layers
6 $ fsl-auto-yocto-bsp$: git -C ara-api checkout  4f804c096d2b4d08b25badc4322ab02fe7484a5d
7 $ fsl-auto-yocto-bsp$: git -C sample-applications checkout  e07a84a5e302a1cc54c170e04d9dd55ba73cbcc9
8 $ fsl-auto-yocto-bsp$: git -C yocto-layers checkout  07d0731abf244fb1afa7b7787c0e54d11b7020a7
\end{DoxyCode}

\end{DoxyEnumerate}

\subsection*{Changes required to run Adaptive platform on rocko}

\begin{quote}
{\bfseries Note\+: Following changes are required in order to build an image on Rocko. Left hand side is the actual file and right hand side is the changes to be made.} \end{quote}



\begin{DoxyEnumerate}
\item Diagnostic functional cluster has few warnings during the compilation process and these warnings are treated as an error due to compiler option -\/\+Werror is used in C\+Make\+Lists.\+txt. In order to build image successfully, this option is removed from corresponding C\+Make\+Lists file.

Path\+: /ara-\/api/diag/\+Cmake\+Lists.txt 
\item \char`\"{}\+Logger g\+\_\+log\+I\+N\+T\char`\"{} is a global variable of dlt which gets initialized even before the application gets forked, due to this execution manager gets stuck inside fork() A\+PI. Jira ticket -\/ 6516 has been raised in this regard. In order to avoid this issue, following work around is applied in the logmanager.\+cpp file.

Path\+: /ara-\/api/log/src/  
\item Boost components are used in the ara-\/per in order to optimize the performance. However, this component(\+Boost) is causing a build issue during linking process as it\textquotesingle{}s not getting linked from the respective application receipe-\/sysroot. To remove dependency on Boost components used by ara-\/per, following changes have been made in the ara-\/per functional clusters.

Path\+: /ara-\/api/per/src/fileaccess/\+Cmake\+Lists.txt  Path\+: /ara-\/api/per/src/key-\/value-\/storage/\+Cmake\+Lists.txt 
\item S\+Y\+S\+T\+EM is a component in the boost library which is not used by the ucm package manager and unit-\/test C\+Make\+List.\+txt. In order to build image successfully, S\+Y\+S\+T\+EM component is removed from the respective C\+Make\+Lists.\+txt.

Path\+: /ara-\/api/ucm/pkgmgr/src/\+Cmake\+Lists.txt  Path\+: /ara-\/api/ucm/pkgmgr/src/test/unit\+\_\+test/\+Cmake\+Lists.txt 
\item This change is carried out to make Test-\/appl1 in emo-\/sample as machine client so that it can interact with Execution manager to change the Machine state.

Path\+: /sample-\/applications/emo\+\_\+samples/\+M\+A\+N\+I\+F\+E\+S\+T-\/appl1.json 
\item functional header file is added to resolve the dependency in the machine state manager.

Path\+: /sample-\/applications/st\+\_\+scenarios/machine\+\_\+state\+\_\+manager/inc/i\+\_\+ms\+\_\+control\+\_\+server.h  Path\+: /sample-\/applications/st\+\_\+scenarios/machine\+\_\+state\+\_\+manager/inc/ms\+\_\+client\+\_\+manager.h 
\item lib-\/platform dependency is added in ara-\/com-\/lib recipe file in order to resolve dependency.

Path\+: /yocto-\/layers/meta-\/ara/recipes-\/ara/com/ara-\/com-\/lib\+\_\+1.0.\+0.\+bb 
\item coreutils-\/native dependency is added in the execution-\/manager.\+bb file. To remove auto start of Execution manager during boot process, few lines have been commented (optional).

Path\+: /yocto-\/layers/meta-\/ara/recipes-\/ara/exec/execution-\/manager.bb 
\item boost library dependency is added ara-\/iam recipe file

Path\+: /yocto-\/layers/meta-\/ara/recipes-\/ara/iam/ara-\/iam.bb 
\item Python library has been replaced with two libraries -\/ python-\/native and python-\/lxml-\/native.

Path\+: /yocto-\/layers/meta-\/ara/recipes-\/ara/sample-\/applications/ara-\/com-\/example.inc 
\item coreutils-\/native dependency is added in the emo-\/sample.\+bb file.

Path\+: /yocto-\/layers/meta-\/ara/recipes-\/ara/sample-\/applications/emo-\/samples\+\_\+1.0.\+0.\+bb 
\item ara-\/com-\/gen has been replaced with ara-\/com-\/gen-\/native in ucm recipe file

Path\+: /yocto-\/layers/meta-\/ara/recipes-\/ara/ucm/ucm-\/package-\/manager.bb 
\item The inclusion of Machine State Manager is causing packaging issue and bitbake process gets stuck. In order to avoid hanging issue during bitbake process, Machine State Manager is removed while building an image. The R\+O\+O\+T\+F\+S\+\_\+\+P\+K\+G\+M\+A\+N\+A\+G\+E\+\_\+\+B\+O\+O\+T\+S\+T\+R\+AP variable and any references to it have been removed from Yocto -\/ Rocko version onwards. To remove auto start of Execution manager during boot process, few lines have been commented (optional).

Path\+: /yocto-\/layers/meta-\/ara/recipes-\/core/images/core-\/image-\/apd-\/common.inc 
\item ara-\/rest library is dependent on gtest hence this is added in C\+Make\+Lists.\+txt and ara-\/rest-\/lib\+\_\+1.\+0.\+0.\+bb.

Path\+: /yocto-\/layers/meta-\/ara/recipes-\/ara/rest/ara-\/rest-\/lib\+\_\+1.0.\+0.\+bb  Path\+: /ara-\/api/rest/lib/ara\+\_\+rest/\+Cmake\+Lists.txt 
\item I\+N\+S\+T\+A\+L\+L\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE modified the path variable, hence system libraries were not found during linking.

Path\+: /ara-\/api/per/src/kvsparser/\+Cmake\+Lists.txt 
\item I\+N\+S\+T\+A\+L\+L\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE modified the path variable, hence system libraries were not found during linking.

Path\+: /ara-\/api/per/src/kvstype/\+Cmake\+Lists.txt 
\item do\+\_\+package\+\_\+qa caused the bitbaking to hang hence it has been commented.

Path\+: /yocto-\/layers/meta-\/ara/recipes-\/ara/sample-\/applications/machinestatemanager\+\_\+1.0.\+0.\+bb  Path\+: /yocto-\/layers/meta-\/ara/recipes-\/ara/sample-\/applications/machinestatemanager\+\_\+1.0.\+0.\+bb 
\item I\+N\+S\+T\+A\+L\+L\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE modified the path variable, hence system libraries were not found during linking.

Path\+: /ara-\/api/per/src/manifestaccess/\+Cmake\+Lists.txt 
\item When an application tries to call the Update() method in \char`\"{}vsomeip\+\_\+event\+\_\+impl.\+h\char`\"{} where the queue is empty, the application will crashes (sporadic crashes) when trying to access a map object at /com/src/internal/e2e/e2e\+\_\+binding.cpp line 84(Jira Ticket -\/ A\+P-\/6292).

Path\+: ara-\/api/com/include/public/ara/com/internal/vsomeip/proxy/vsomeip\+\_\+event\+\_\+impl.\+h  \subsection*{Porting Adaptive platform to N\+XP s3v234sbc}
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Download N\+XP bsp along with rocko verison of poky and compiler. 
\begin{DoxyCode}
1 cd fsl-auto-yocto-bsp
2 $fsl-auto-yocto-bsp: repo init -u https://source.codeaurora.org/external/autobsps32/auto\_yocto\_bsp -b
       alb/master
3 $fsl-auto-yocto-bsp: repo sync
\end{DoxyCode}

\item First time setup 
\begin{DoxyCode}
1 $fsl-auto-yocto-bsp: ./sources/meta-alb/scripts/host-prepare.sh
\end{DoxyCode}
 
\begin{DoxyCode}
1 ! Note: When you run the host script you will see the following prompt.
\end{DoxyCode}
  
\begin{DoxyCode}
1 The line that is highlighted in the image has to be added in the sudoer file. To add the command in sudoer
       follow the steps given below.
2 1. Copy the command in your terminal as it can change in different host 
3 2. Enter the command:  sudo /usr/sbin/visudo
4 3. Paste the line in user priviledge section.
5 4. Then press ctrl+x, it will prompt whether to save so press yes.
6 5. Now press ctrl+m+a.
\end{DoxyCode}

\item Creating Build Directories. 
\begin{DoxyCode}
1 $fsl-auto-yocto-bsp: source nxp-setup-alb.sh -m s32v234sbc
\end{DoxyCode}

\item if sourcing for the second time 
\begin{DoxyCode}
1 $fsl-auto-yocto-bsp: source build\_s32v234sbc/SOURCE\_THIS
\end{DoxyCode}

\item Add the adaptive layer in bblayer.\+conf 
\begin{DoxyCode}
1 $fsl-auto-yocto-bsp/build\_s32v234sbc: bitbake-layers add-layer ../yocto-layers/meta-ara
\end{DoxyCode}

\item Add fsl-\/image-\/auto in local.\+conf 
\begin{DoxyCode}
1 $fsl-auto-yocto-bsp/build\_s32v234sbc: echo "IMAGE\_INSTALL\_append ??= \(\backslash\)"fsl-image-auto\(\backslash\)"" >> conf/local.conf
       
\end{DoxyCode}

\item Bitbake the core-\/image-\/apd-\/minimal 
\begin{DoxyCode}
1 $fsl-auto-yocto-bsp/build\_s32v234sbc: bitbake core-image-apd-minimal-radar
\end{DoxyCode}

\item Flash image in SD cards. 
\begin{DoxyCode}
1 $fsl-auto-yocto-bsp/build\_s32v234sbc: cd  tmp/deploy/images/s32v234sbc
2 $fsl-auto-yocto-bsp/build\_s32v234sbc/tmp/deploy/images/s32v234sbc: sudo dd if="image name".sdcard
       of=/dev/"dev" name bs=1M && sync
\end{DoxyCode}
 \begin{quote}
for example \char`\"{}image name\char`\"{} = core-\/image-\/apd-\/minimal-\/radar-\/s32v234sbc-\/2018101181325204-\/rootfs.\+sdcard

\char`\"{}dev name\char`\"{} = sdb1, sdb, mmbclk0 (check the dev name in Disk utility) \end{quote}

\item For log, connect the micro-\/usb to host machine and run the below command on new terminal 
\begin{DoxyCode}
1 $home: sudo picocom -b 115200 /dev/ttyUSB0
\end{DoxyCode}

\item Insert the SD card, press the reset button and it will boot automatically. 
\end{DoxyEnumerate}\hypertarget{Debug_App}{}\section{Debug Adaptive Platform Application Using Eclipse}\label{Debug_App}
\subsection*{Pre requisite\+:}

\begin{quote}
{\bfseries Note\+: Add meta-\/ara and meta-\/cm-\/use-\/case-\/avin in bblayer.\+conf before creating S\+DK} \end{quote}



\begin{DoxyItemize}
\item Add the following image in I\+M\+A\+G\+E\+\_\+\+I\+N\+S\+T\+A\+LL in the respective application recipe found in /yocto-\/layers/meta-\/ara/recipes-\/core and for CM application add in /yocto-\/layers/meta-\/ara/recipes-\/core/core-\/image-\/apd-\/common-\/avin.inc \+: 
\begin{DoxyCode}
1 IMAGE\_INSTALL\_append = "\(\backslash\)
2         ara-dropbear \(\backslash\)
3         ara-getty \(\backslash\)
4         gdbserver \(\backslash\)
5         openssh-sftp-server \(\backslash\)
6         glibc-utils \(\backslash\)
7         localedef \(\backslash\)
8         "
\end{DoxyCode}

\item Add the following in build/conf/local.\+conf 
\begin{DoxyCode}
1 EXTRA\_IMAGE\_FEATURES\_append =  " eclipse-debug tools-sdk tools-debug dbg-pkgs"
2 IMAGE\_GEN\_DEBUGFS = "1"
3 IMAGE\_FSTYPES\_DEBUGFS = "tar.bz2"
\end{DoxyCode}

\end{DoxyItemize}

\subsection*{Creation of S\+DK\+:}


\begin{DoxyItemize}
\item Bitbake image and create S\+DK. 
\begin{DoxyCode}
1 $ bitbake core-image-apd-minimal
2 $ bitbake ara-sdk
\end{DoxyCode}

\item ara-\/adk creates a script in build/tmp/deploy/sdk/$<$script-\/name$>$.sh
\item Create a folder in home directory to install sdk. 
\begin{DoxyCode}
1 $ mkdir autosar\_sdk && cd autosar\_sdk
2 $ autosar\_sdk:  mkdir sdk && cd sdk
3 $ autosar\_sdk/sdk:  <path-to-script>.sh -y -d   ./nxpsdk
\end{DoxyCode}

\end{DoxyItemize}

\begin{quote}
{\bfseries Note\+: It is found in /build/tmp/deploy/sdk.eg\+: /home/avin/\+Rocko\+\_\+adaptive/fsl-\/auto-\/yocto-\/bsp/build\+\_\+s32v234sbc/tmp/deploy/sdk} \end{quote}


\subsection*{Installation of Eclipse}


\begin{DoxyItemize}
\item Install the Neon version of the Eclipse for C/\+C++ developers from eclipse.\+org
\item Start the Eclipse I\+DE.
\item Make sure you are in your Workbench and select \char`\"{}\+Install New Software\char`\"{} from the \char`\"{}\+Help\char`\"{} pull-\/down menu. \begin{quote}
{\bfseries Note\+: Some plugin will not be listed as it may already be installed in eclipse.} \end{quote}

\item Select Neon -\/ \href{http://download.eclipse.org/releases/neon}{\tt http\+://download.\+eclipse.\+org/releases/neon} from the \char`\"{}\+Work with\+:\char`\"{} pull-\/down menu.
\item Expand the box next to \char`\"{}\+Linux Tools\char`\"{} and select
\begin{DoxyItemize}
\item L\+T\+Tng -\/ Linux Tracing Toolkit boxes.
\end{DoxyItemize}
\item Expand the box next to \char`\"{}\+Mobile and Device Development\char`\"{} and select the following boxes\+:
\begin{DoxyItemize}
\item C/\+C++ Remote Launch
\item Remote System Explorer End-\/user Runtime
\item Remote System Explorer User Actions
\item Target Management Terminal
\item T\+CF Remote System Explorer add-\/in
\item T\+CF Target Explorer   
\end{DoxyItemize}
\item Expand the box next to \char`\"{}\+Programming Languages\char`\"{} and select
\begin{DoxyItemize}
\item Autotools Support for C\+DT
\item C/\+C++ Development Tools boxes. 
\end{DoxyItemize}
\item Add new link to download yocto plugin \href{http://downloads.yoctoproject.org/releases/eclipse-plugin/2.3.2/neon}{\tt http\+://downloads.\+yoctoproject.\+org/releases/eclipse-\/plugin/2.\+3.\+2/neon} and install all plugin listed for yocto. 
\end{DoxyItemize}

\subsection*{Setup S\+DK gdb in eclipse}


\begin{DoxyItemize}
\item source S\+DK script before starting eclipse 
\begin{DoxyCode}
1 $ source  autosar\_sdk/sdk/nxpsdk/environment-setup-aarch64-fsl-linux
\end{DoxyCode}
 \begin{quote}
{\bfseries Note\+: “which cmake” is command to check whether the cmake path is pointing to sdk cmake.} \end{quote}

\end{DoxyItemize}


\begin{DoxyItemize}
\item Start Eclipse in the “\+Sourced” terminal. 
\begin{DoxyCode}
1 $ eclipse/eclipse
\end{DoxyCode}

\item When Eclipse has started the first time the Yocto Project S\+DK tools configuration should be done.
\item This is done in Eclipse under the Window menu $>$ Preferences $>$ Yocto Project S\+DK  
\begin{DoxyCode}
1 Note: Cross compiler should be standalone pre-built toolchain.
2      Point Toolchain Root location and Sysroot Location to sdk.
3      Target Architecture should be available once pointed to proper sdk.
4      eg: toolchain Root location:/home/avin/Autosar\_sdk/sdk/nxpsdk 
5      Sysroot Location: /home/avin/Autosar\_sdk/sdk/nxpsdk/sysroot/
\end{DoxyCode}

\end{DoxyItemize}

\subsection*{Importing project to debug\+:}


\begin{DoxyItemize}
\item Create Build directory in autosar\+\_\+sdk and build the application
\item Each sample application will have cmake command with different command line argument. Refer C\+Make command section at the end 
\begin{DoxyCode}
1 $ cd autosar\_sdk
2 $autosar\_sdk: source sdk/nxpsdk/environment-setup-aarch64-fsl-linux
3 $autosar\_sdk: mkdir Build && cd Build
4 $autosar\_sdk/Build:  cmake -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON   -DENABLE\_DOXYGEN=ON  
       -DCMAKE\_BUILD\_TYPE=Debug -DBUILD\_TESTS=ON -G"Eclipse CDT4 - Unix Makefiles" </path /to/application/to/debug>
\end{DoxyCode}
 
\begin{DoxyCode}
1 Eg. Rocko\_adaptive/fsl-auto-yocto-bsp/sample-applications/emo\_samples/
2     $autosar\_sdk/Build: cmake -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON  -DENABLE\_DOXYGEN=ON 
       -DCMAKE\_BUILD\_TYPE=Debug -DBUILD\_TESTS=ON -G "Eclipse CDT4 - Unix Makefiles"
       /home/avin/Rocko\_adaptive/fsl-auto-yocto-bsp/sample-applications/emo\_samples/
3     $autosar\_sdk/Build: make
\end{DoxyCode}

\item Import the project to eclipse(eclipse should be opened on sourced terminal)
\item Click File $>$ Import $>$ C/\+C++ $>$ Existing project into workspace then click next
\item Browse root location to Build folder in autosar\+\_\+sdk and click on Yocto C\+M\+A\+KE build
\item Click finish.
\item Build the project
\end{DoxyItemize}

\subsection*{Setup Debug rootfs on host machine}


\begin{DoxyItemize}
\item Create a new folder for debug filesystem in home directory 
\begin{DoxyCode}
1 $ mkdir debugfs
2 $ cd debugfs
3 $ tar xzf
       <path/to>/build\_s32v234sbc/tmp/deploy/images/s32v234sbc/core-image-apd-minimal-s32v234sbc-20180904061102.rootfs.tar.gz
4 $ tar xjf
       <path/to>/build\_s32v234sbc/tmp/deploy/images/s32v234sbc/core-image-apd-minimal-s32v234sbc-20180904061102-dbg.rootfs.tar.bz2
\end{DoxyCode}

\end{DoxyItemize}

\subsection*{Deploying Image to Debug}


\begin{DoxyItemize}
\item Select the Imported project then click on Debug As $>$ Debug configuration, new window will apear.
\item Under C/\+C++ Remote Application Imported application will appear select the project. In Main tab under C/\+C++ Application browse to executable in sdk build directory. For eg\+: /home/avin/fsl\+\_\+sdk/build/src/\+Test\+Appl1  
\item In build configuration select use active option in drop down
\item Use workspace setting should be selected.
\item In connection create a new connection 
\item In host give the ip address of the board and root as user
\item In command to execute before application, give cd /opt/\+Test\+Appl1
\item In Debugger Tab , G\+DB debugger should be pointing to G\+DB exe in S\+DK and G\+DB command line should be .gdbinit in workspace 
\begin{DoxyCode}
1 for eg :
       Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/bin/aarch64-fsl-linux/aarch64-fsl-linux-gdb
\end{DoxyCode}

\end{DoxyItemize}




\begin{DoxyItemize}
\item If .gdbinit is not found create new file with following entry 
\begin{DoxyCode}
1 set sysroot debugfs
2 set substitute-path /usr/src/debug debugfs/usr/src/debug
\end{DoxyCode}

\item In main tab , Remote absolute path for C/\+C++ application should be path in filesystem of the board(\+If connection is made between board and host , browse option will show you boards filsystem)
\item Now select apply and then debug.(Board should be connected to the network and you should be able to ping the board )
\item Before you hit debug on eclipse following has to be done on target board.
\end{DoxyItemize}

\subsection*{Boot the image on target board}


\begin{DoxyItemize}
\item Create SD card to boot the image 
\begin{DoxyCode}
1 $ sudo dd
       if=</path/to>build\_s32v234sbc/tmp/deploy/images/s32v234sbc/core-image-apd-minimal-s32v234sbc-20180904061102.rootfs.sdcard of=/dev/mmcblk0 bs=1M && sync
\end{DoxyCode}

\item Insert the Sd card on sbc board
\item Connect the board and the host machine with micro U\+SB
\item Start a new terminal on host machine and start picocom 
\begin{DoxyCode}
1 $ sudo picocom -b 115200 /dev/ttyUSB0
\end{DoxyCode}

\item Power on the board
\item Enter \textquotesingle{}root\textquotesingle{} when asked for user
\item Run the execution-\/manager in background 
\begin{DoxyCode}
1 $ execution-manager&
\end{DoxyCode}

\item Open a new terminal on host machine and connect the board through ssh 
\begin{DoxyCode}
1 $ ssh root@<board ip address>
\end{DoxyCode}

\item When you logged into the board through S\+SH, type \textquotesingle{}top\textquotesingle{} command and look for the pid of the application you want to debug.
\item Kill the application you want to debug. 
\begin{DoxyCode}
1 $ kill <pid>
\end{DoxyCode}

\end{DoxyItemize}

\subsection*{C\+Make command for Sample Application}

\begin{quote}
{\bfseries Note\+: Change the application path and sdk path as per host machine path} \end{quote}



\begin{DoxyItemize}
\item C\+Make for U\+CM application(pkgmgr\+\_\+sample) 
\begin{DoxyCode}
1 cmake -DCMAKE\_NO\_SYSTEM\_FROM\_IMPORTED=1 -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DCMAKE\_BUILD\_TYPE=Debug
       -DARAGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/share/ara-gen/aragen.py 
       -DJSONGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/share/ara-gen/jsongen.py 
       -DARA\_UCM\_PKGMGR\_MODEL\_DIR=$HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/ara-api/ucm/pkgmgr/files/manifests
       -DARA\_ARXMLS\_DIR=$HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/ara-api/apd/arxmls -DCMAKE\_ECLIPSE\_VERSION=4.6 -G"Eclipse CDT4 - Unix
       Makefiles"  $HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/avin-applications/ucm-use-case-avin/pkgmgr\_sample
\end{DoxyCode}

\item C\+Make for Mode\+\_\+\+Manager\+\_\+ecu1 
\begin{DoxyCode}
1 cmake  -Wno-dev -DCMAKE\_NO\_SYSTEM\_FROM\_IMPORTED=1  -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON  -DROUTING=vsomeipd 
       -DLOG\_LEVEL=debug -DCMAKE\_BUILD\_TYPE=Debug
       -DARAGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/share/ara-gen/aragen.py 
       -DJSONGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/share/ara-gen/jsongen.py  -DARA\_ARXMLS\_DIR=$HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/ara-api/apd/arxmls
       -DCMAKE\_ECLIPSE\_VERSION=4.6 -G"Eclipse CDT4 - Unix Makefiles" 
       $HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/avin-applications/em-use-case-avin/StateManager\_usecase/Mode\_Manager\_ecu1
\end{DoxyCode}

\item C\+Make for Mode\+\_\+\+Manager\+\_\+ecu2 
\begin{DoxyCode}
1 cmake  -Wno-dev -DCMAKE\_NO\_SYSTEM\_FROM\_IMPORTED=1  -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON  -DROUTING=vsomeipd 
       -DLOG\_LEVEL=debug -DCMAKE\_BUILD\_TYPE=Debug
       -DARAGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/share/ara-gen/aragen.py 
       -DJSONGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/share/ara-gen/jsongen.py  -DARA\_ARXMLS\_DIR=$HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/ara-api/apd/arxmls
       -DCMAKE\_ECLIPSE\_VERSION=4.6 -G"Eclipse CDT4 - Unix Makefiles" 
       $HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/avin-applications/em-use-case-avin/StateManager\_usecase/Mode\_Manager\_ecu2
\end{DoxyCode}

\item C\+Make for emo-\/sample-\/avin 
\begin{DoxyCode}
1 cmake -Wno-dev -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DCMAKE\_BUILD\_TYPE=Debug -DCMAKE\_ECLIPSE\_VERSION=4.6
       -G"Eclipse CDT4 - Unix Makefiles" 
       $HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/avin-applications/em-use-case-avin/emo-sample-avin
\end{DoxyCode}

\item C\+Make for per\+\_\+usecase 
\begin{DoxyCode}
1 cmake -Wno-dev -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DCMAKE\_BUILD\_TYPE=Debug -DCMAKE\_ECLIPSE\_VERSION=4.6
       -G"Eclipse CDT4 - Unix Makefiles" 
       $HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/avin-applications/per-use-case-avin/per\_usecase
\end{DoxyCode}

\item C\+Make for R\+E\+S\+T\+Server 
\begin{DoxyCode}
1 cmake -Wno-dev -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON
       -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DROUTING=vsomeipd  -DLOG\_LEVEL=debug -DCMAKE\_BUILD\_TYPE=Debug
       -DARAGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/share/ara-gen/aragen.py 
       -DJSONGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/share/ara-gen/jsongen.py
       -DARA\_ARXMLS\_DIR=$HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/ara-api/apd/arxmls -DCMAKE\_ECLIPSE\_VERSION=4.6 -G"Eclipse CDT4 - Unix Makefiles" 
       $HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/avin-applications/rest-use-case-avin/RESTServer
\end{DoxyCode}

\item C\+Make for Door\+Swc 
\begin{DoxyCode}
1 cmake -Wno-dev -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DROUTING=vsomeipd 
       -DLOG\_LEVEL=debug -DCMAKE\_BUILD\_TYPE=Debug
       -DARAGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/share/ara-gen/aragen.py 
       -DJSONGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/share/ara-gen/jsongen.py -DARA\_ARXMLS\_DIR=$HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/ara-api/apd/arxmls
       -DCMAKE\_ECLIPSE\_VERSION=4.6 -G"Eclipse CDT4 - Unix Makefiles"
       $HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/avin-applications/rest-use-case-avin/DoorSwc
\end{DoxyCode}

\item C\+Make for Battery\+Swc 
\begin{DoxyCode}
1 cmake -Wno-dev -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DROUTING=vsomeipd 
       -DLOG\_LEVEL=debug -DCMAKE\_BUILD\_TYPE=Debug
       -DARAGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/share/ara-gen/aragen.py 
       -DJSONGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/share/ara-gen/jsongen.py -DARA\_ARXMLS\_DIR=$HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/ara-api/apd/arxmls
       -DCMAKE\_ECLIPSE\_VERSION=4.6 -G"Eclipse CDT4 - Unix Makefiles"
       $HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/avin-applications/rest-use-case-avin/BatterySwc
\end{DoxyCode}

\item C\+Make for Performance application ecu2 (Radar) 
\begin{DoxyCode}
1 cmake -Wno-dev -DCMAKE\_NO\_SYSTEM\_FROM\_IMPORTED=1 -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DROUTING=vsomeipd 
       -DLOG\_LEVEL=debug -DCMAKE\_BUILD\_TYPE=Debug
       -DARAGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/share/ara-gen/aragen.py 
       -DJSONGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/share/ara-gen/jsongen.py -DARA\_ARXMLS\_DIR=$HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/ara-api/apd/arxmls
       -DCMAKE\_ECLIPSE\_VERSION=4.6 -G"Eclipse CDT4 - Unix Makefiles"
       $HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/avin-applications/performance-use-case-avin/radar
\end{DoxyCode}

\item C\+Make for Performance application ecu1 (Fusion) 
\begin{DoxyCode}
1 cmake -Wno-dev -DCMAKE\_NO\_SYSTEM\_FROM\_IMPORTED=1 -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DROUTING=vsomeipd 
       -DLOG\_LEVEL=debug -DCMAKE\_BUILD\_TYPE=Debug
       -DARAGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/share/ara-gen/aragen.py 
       -DJSONGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroot/x86\_64-fslbsp-linux/usr/share/ara-gen/jsongen.py -DARA\_ARXMLS\_DIR=$HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/ara-api/apd/arxmls
       -DCMAKE\_ECLIPSE\_VERSION=4.6 -G"Eclipse CDT4 - Unix Makefiles"
       $HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/avin-applications/performance-use-case-avin/fusion
\end{DoxyCode}

\item C\+Make for cm use case \begin{quote}
Note\+: Open\+Cv 3.\+1.\+0 has to be installed into S\+DK before debugging CM usecase application and the step is provided in the following link. \end{quote}
\begin{DoxyVerb}https://bugzilla.autosar.org/wiki/doku.php?id=apd_user_guide:sdk:guide:add_items_to_sdk&s[]=sdk&s[]=opencv
\end{DoxyVerb}

\item C\+Make command for Video Provider Right 
\begin{DoxyCode}
1 cmake -DCMAKE\_NO\_SYSTEM\_FROM\_IMPORTED=1
       -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON-DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON
       -DCMAKE\_BUILD\_TYPE=Debug
       -DARAGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroots/x86\_64-pokysdk-linux/usr/share/ara-gen/aragen.py 
       -DJSONGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroots/x86\_64-pokysdk-linux/usr/share/ara-gen/jsongen.py  -DARA\_ARXMLS\_DIR=$HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/ara-api/apd/arxmls
       -DBUILD\_MACHINE\_STATE\_MANAGER=OFF -DBUILD\_VIDEO\_PROVIDER=OFF -DBUILD\_VIDEO\_PROVIDER\_RIGHT=ON -DBUILD\_VIDEO\_ADAPTER=OFF
       -DBUILD\_PREPROCESSING=ON -DBUILD\_COMPUTER\_VISION=ON -DBUILD\_EBA=ON -DCMAKE\_ECLIPSE\_VERSION=4.6 -G"Eclipse CDT4 -
       Unix Makefiles"  $HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/avin-applications/cm-use-case-avin
\end{DoxyCode}

\item C\+Make command for Video Provider Left 
\begin{DoxyCode}
1 cmake -DCMAKE\_NO\_SYSTEM\_FROM\_IMPORTED=1 -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON
       -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DCMAKE\_BUILD\_TYPE=Debug
       -DARAGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroots/x86\_64-pokysdk-linux/usr/share/ara-gen/aragen.py 
       -DJSONGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroots/x86\_64-pokysdk-linux/usr/share/ara-gen/jsongen.py 
       -DARA\_ARXMLS\_DIR=$HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/ara-api/apd/arxmls -DBUILD\_MACHINE\_STATE\_MANAGER=OFF
       -DBUILD\_VIDEO\_PROVIDER=ON -DBUILD\_VIDEO\_PROVIDER\_RIGHT=OFF -DBUILD\_VIDEO\_ADAPTER=OFF -DBUILD\_PREPROCESSING=ON
       -DBUILD\_COMPUTER\_VISION=ON -DBUILD\_EBA=ON -DCMAKE\_ECLIPSE\_VERSION=4.6 -G"Eclipse CDT4 - Unix Makefiles"
       $HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/avin-applications/cm-use-case-avin
\end{DoxyCode}

\item C\+Make command for Video Adapter 
\begin{DoxyCode}
1 cmake -DCMAKE\_NO\_SYSTEM\_FROM\_IMPORTED=1 -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON
       -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON -DCMAKE\_BUILD\_TYPE=Debug
       -DARAGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroots/x86\_64-pokysdk-linux/usr/share/ara-gen/aragen.py 
       -DJSONGEN\_PATH=$HOME/Autosar\_sdk/sdks/nxpsdk/sysroots/x86\_64-pokysdk-linux/usr/share/ara-gen/jsongen.py 
       -DARA\_ARXMLS\_DIR=$HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/ara-api/apd/arxmls -DBUILD\_MACHINE\_STATE\_MANAGER=OFF
       -DBUILD\_VIDEO\_PROVIDER=OFF -DBUILD\_VIDEO\_PROVIDER\_RIGHT=OFF -DBUILD\_VIDEO\_ADAPTER=ON -DBUILD\_PREPROCESSING=ON
       -DBUILD\_COMPUTER\_VISION=ON -DBUILD\_EBA=ON -DCMAKE\_ECLIPSE\_VERSION=4.6 -G"Eclipse CDT4 - Unix Makefiles"
       $HOME/Rocko\_adaptive/fsl-auto-yocto-bsp/avin-applications/cm-use-case-avin
\end{DoxyCode}
 
\end{DoxyItemize}\hypertarget{Performance_parameter}{}\section{Performance Parameter}\label{Performance_parameter}
\subsection*{1) Steps to check communication latency}


\begin{DoxyEnumerate}
\item Communication latency Measurement between two machines could be possible only when , both the machines are synchronize to same time.
\item We need to install N\+TP client on both the machines, to synchronize the time between machines.
\item Below link is used to install and configure N\+TP server. We also mentioned steps to install N\+TP server on host machine. ~\newline
 \href{http://www.ubuntugeek.com/install-and-configure-network-time-protocol-ntp-serverclients-on-ubuntu-16-04-server.html}{\tt http\+://www.\+ubuntugeek.\+com/install-\/and-\/configure-\/network-\/time-\/protocol-\/ntp-\/serverclients-\/on-\/ubuntu-\/16-\/04-\/server.\+html }
\item We also need to have a host machine which has N\+TP server installed on it. Below is the command to install N\+TP server on host. 
\begin{DoxyCode}
1 sudo apt-get install ntp
\end{DoxyCode}

\item On the host machine in /etc/ntp.conf file add the below line. 
\begin{DoxyCode}
1 restrict 192.168.0.0 mask 255.255.255.0 nomodify notrap
\end{DoxyCode}

\item Image 
\item Use the below command to start the ntp server. 
\begin{DoxyCode}
1 /etc/init.d/ntp start
\end{DoxyCode}

\item Add the meta-\/networking layer in bblayer.\+conf as it contains .bb file regarding N\+TP. 
\begin{DoxyCode}
1 bitbake-layers add-layer ../yocto-layers/meta-networking
\end{DoxyCode}

\item Add the following N\+TP image using I\+M\+A\+G\+E\+\_\+\+I\+N\+S\+T\+A\+LL in recipe yocto-\/layers/meta-\/ara/recipes-\/core/core-\/performance-\/use-\/case/core-\/image-\/apd-\/minimal-\/perform-\/avin.\+bb 
\begin{DoxyCode}
1 IMAGE\_INSTALL += "\(\backslash\)
2         .. \(\backslash\)
3         .. \(\backslash\)
4         ntp \(\backslash\)
5         "
\end{DoxyCode}

\item Bitbake respective images. 
\begin{DoxyCode}
1 $ bitbake core-image-apd-minimal-perform-ecu1
2 $ bitbake core-image-apd-minimal-perform-ecu2
\end{DoxyCode}

\item After bitbake, flash the image into S\+Dcard.
\begin{DoxyEnumerate}
\item We can assign static IP address to target in /etc/network/interface file. 
\begin{DoxyCode}
1 auto eth0
2 iface eth0 inet static
3       address 192.168.20.53
4       netmask 255.255.255.0
5       network 192.168.20.0
6       gateway 192.168.20.1
\end{DoxyCode}

\end{DoxyEnumerate}
\item After logged in into the board , the /etc/ntp.conf file on the board should have IP address of host machine in the below format.

For Example\+: 
\begin{DoxyCode}
1 $ server <ip adress of host machine>
2 $ fudge <ip adress of host machine> stratum 14
\end{DoxyCode}

\item Now restart the respective boards.
\item Use the below command to check whether both the machines have same time. 
\begin{DoxyCode}
1 date -u
\end{DoxyCode}

\item If both the machines are synchronized to the same host machine, then adjust() method can be used to calculate the communication latency.
\item {\bfseries  In the Performance Parameter Sample Application, Adjust() method of Radar and Fusion is used. }
\begin{DoxyItemize}
\item In Fusion Application, print timestamp before Adjust() method is being invoked. 
\item Pass this timestamp to Adjust() method in Radar. 
\item In Radar Application, print timestamp inside Adjust() method. 
\item Check the difference between current time taken in Radar Application and time which was passed as parameter from Fusion.
\item The difference between the two timestamps specifies the communication latency. 
\end{DoxyItemize}
\item {\bfseries  Now we will do the above method in reverse order from Radar to Fusion }
\begin{DoxyItemize}
\item In Radar Application, print timestamp in Adjust() method. 
\item Return this timestamp as out parameter of Adjust() method to Fusion. 
\item In Fusion Application, print the timestamp. 
\item Check the difference between current time taken in Fusion Application and the timestamp received from Radar.
\item The difference between the two timestamps specifies the communication latency. 
\end{DoxyItemize}
\item The above steps illustrates the communication latency between two machines.
\end{DoxyEnumerate}

\subsection*{2) Steps to check booting time}

\begin{quote}
{\bfseries 2.\+1 \+: N\+XP S32v234\+S\+BC} \end{quote}



\begin{DoxyEnumerate}
\item Add the below command into build\+\_\+s32v234sbc/conf/local.\+conf file. 
\begin{DoxyCode}
1 DISTRO\_FEATURES +=" $\{DISTRO\_FEATURES\_LIBC\} systemd "
\end{DoxyCode}

\item Add the following systemd image using I\+M\+A\+G\+E\+\_\+\+I\+N\+S\+T\+A\+LL in recipe yocto-\/layers/meta-\/ara/recipes-\/core/core-\/per-\/use-\/case/core-\/image-\/apd-\/minimal-\/per.\+bb 
\begin{DoxyCode}
1 IMAGE\_INSTALL += "\(\backslash\)
2         .. \(\backslash\)
3         systemd \(\backslash\)
4         systemd-analyze \(\backslash\)
5         "
\end{DoxyCode}

\item Bitbake respective image. 
\begin{DoxyCode}
1 $ bitbake core-image-apd-minimal-per
\end{DoxyCode}

\item After bitbake, flash the image into S\+Dcard.
\item Following are the steps to copy image from host system to memory card\+: 
\begin{DoxyCode}
1 cd /tmp/deploy/images/s32v234sbc
2 sudo dd if=image-name.rootfs.sdcard of=/dev/mmcblk0 bs=1M && sync
\end{DoxyCode}

\item When you login into board, Enter the below command to check the booting time. 
\begin{DoxyCode}
1 systemd-analyze
\end{DoxyCode}

\item Enter the below command to store the booting time into .svg image file, which gets stored at /home/root/ directory. 
\begin{DoxyCode}
1 systemd-analyze plot > filename.svg
\end{DoxyCode}

\item Copy the .svg image file into /opt folder. 
\begin{DoxyCode}
1 cp filename.svg opt/
\end{DoxyCode}

\item Now insert the S\+D\+Card from board into host machine, /opt directory will conatin filename.\+svg image file.
\item This .svg file will contain details regarding booting time.


\begin{DoxyEnumerate}
\item While a system is booted up by starting the Kernel , systemd initializes the system, starting all the system services.
\begin{DoxyItemize}
\item multi-\/user.\+target \+: It starts every service that are expected to run in multi user mode.
\item sysinit.\+target \+: systemd starts system initialization services. This includes swap devices enabling and file systems mounting.
\item basic.\+target \+: Starts the basic services like firewalld and microcode services.
\item local-\/fs.\+target \+: No user related services are started by this target unit. It handles core level services only. This target is one performing actions on basis of /etc/fstab/ and /etc/inittab files.
\item When systemd starts up the system, it will activate all units that are dependencies of default.\+target (as well as recursively all dependencies of these dependencies). Usually, default.\+target is simply an alias of graphical.\+target or multi-\/user.\+target, depending on whether the system is configured for a graphical UI or only for a text console.
\item Each target has a set of dependencies described in its configuration file. systemd starts the required dependencies. These dependencies are the services required to run the Linux host at a specific level of functionality. When all of the dependencies listed in the target configuration files are loaded and running, the system is running at that target level.
\item A unit configuration file whose name ends in \char`\"{}.\+slice\char`\"{} encodes information about a slice unit. A slice unit is a concept for hierarchically managing resources of a group of processes. This management is performed by creating a node in the Linux Control Group (cgroup) tree. Units that manage processes (primarily scope and service units) may be assigned to a specific slice. For each slice, certain resource limits may be set that apply to all processes of all units contained in that slice.
\item By default, service and scope units are placed in system.\+slice, virtual machines and containers registered with systemd-\/machined are found in machine.\+slice, and user sessions handled by systemd-\/logind in user.\+slice. systemd.\+unit for the common options of all unit configuration files. 
\end{DoxyItemize}
\end{DoxyEnumerate}
\end{DoxyEnumerate}