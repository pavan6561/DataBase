<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Adaptive Platform Demonstrator: ARA Com API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Platform Demonstrator
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('adaptive_communicationmanagement_aracom.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">ARA Com API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li>Existing communication middleware API/technology are listed below:<ul>
<li><b>ROS(Robot Operating System) API</b></li>
<li><b>DDS(Data Distribution Service) API</b></li>
<li><b>CommonAPI(GENIVI)</b></li>
<li><b>DADDY API(Bosch)</b></li>
</ul>
</li>
<li>Decision to come up with a new and AUTOSAR-specific Communication Management API was due to the fact, that not all of the key requirements were met by existing solutions:<ul>
<li>Need for a Communication Management, which is NOT bound to a concrete network communication protocol. It has to support the SOME/IP protocol along with the flexibility to exchange that.</li>
<li>The AUTOSAR service model, which defines services as a collection of provided methods, events and fields are supported naturally/straight forward.</li>
<li>The API supports an event-driven and a polling model to get access to communicated data equally . The latter is needed by real-time applications to avoid unnecessary context switches, while the former is much more convenient for applications without real-time requirements.</li>
<li>Possibility for seamless integration of end-to-end protection to fulfill ASIL requirements.</li>
<li>Support for static (preconfigured) and dynamic (runtime) selection of service instances to communicate with.</li>
</ul>
</li>
</ul>
<blockquote class="doxtable">
<p><b>ara::com only defines the API signatures and its behaviour visible to the application developer. Providing an implementation of those APIs and the underlying middleware transport layer is the responsibility of the AUTOSAR AP vendor.</b> </p>
</blockquote>
<h1>1. High Level API Structure</h1>
<h2>1.1 Proxy/Skeleton Architecture</h2>
<ul>
<li>The basic idea of this pattern is, that from a formal service definition two code artifacts are generated: <div class="image">
<img src="proxy_skeleton_pattern.png" alt="proxy_skeleton_pattern.png"/>
<div class="caption">
Proxy Skeleton Pattern</div></div>
<ul>
<li><b>Service Proxy</b>: This code is from the perspective of the service consumer, which wants to use a possibly remote service. Service proxy represents this service on code level.</li>
<li><b>Service Skeleton</b>: This code is from the perspective of the service implementation, which provides functionalities according to the service definition - Connects the service implementation to the Communication Management transport layer, so that the service implementation can be contacted by distributed service consumers.</li>
</ul>
</li>
</ul>
<h2>1.2 Datatype Abstractions</h2>
<ul>
<li>ara::com API introduces specific datatypes, which are used throughout its various interfaces. They can roughly be divided into the following classes:<ul>
<li><b>Pointer types:</b> for pointers to data transmitted via middleware</li>
<li><b>Collection types:</b> for collections of data transmitted via middleware</li>
<li><b>Types for async operation result management:</b> ara::com specific versions of C++ std::future and std::promise</li>
<li><b>Function wrappers:</b> for various application side callback or handler functions to be called by the middleware</li>
</ul>
</li>
</ul>
<h2>1.3 Error Notification</h2>
<ul>
<li>ara::com API uses C++ exceptions to notify the user of the API about any errors occurred.</li>
</ul>
<h3>1.3.1 Checked Exceptions</h3>
<ul>
<li>Checked Exceptions within ara::com API can only occur in the context of a call of a service interface method</li>
</ul>
<h3>1.3.2 Unchecked Exceptions</h3>
<ul>
<li>Unchecked Exceptions within ara::com API can basically occur in the context of any ara::com API call and are fully ara::com implementation specific! A property of unchecked exceptions is, that programs/program artifacts hitting such an exception can typically not recover from it.</li>
</ul>
<h1>2. API Elements</h1>
<ul>
<li>A virtual service (interface) called "RadarService is defined in the below example.</li>
</ul>
<div class="image">
<img src="RadarService_Definition.png" alt="RadarService_Definition.png"/>
<div class="caption">
RadarService Definition</div></div>
<ul>
<li>So the example service RadarService provides an event called “BrakeEvent”, which consists of a structure containing a flag and a variable length array of uint8 (as extra payload). A field “UpdateRate”, which is of type uint32 (supports get and set calls) and methods Adjust, Calibrate and LogCurrentState.</li>
<li>Method “Adjust” is used to position the radar. It contains a target position as in-parameter and two out-parameters. One to signal the success of the positioning and other to report the final (maybe deviating) effective position. The method “Calibrate” is used to calibrate the radar. It contains a configuration string as in-parameter and returning a success indicator as an out-parameter. "Calibrate" method may raise two different application errors, in case of the calibration failure: “CalibrationFailed” and “InvalidConfigString”. The method “LogCurrentState” is a one way method, which means, no feedback is returned to the caller. It instructs the service RadarService to output its current state into its local log files.</li>
</ul>
<h2>2.1 Common Types</h2>
<h3>2.1.1 Optional data elements</h3>
<ul>
<li>The structure in below Figure has the optional declared elements "current and health". These elements are not mandatorily present. The consuming application has to check whether the optional elements contain a value or not during runtime. Optional element contains a may or may not contain a value depends on the providing application. The providing application may or may not set the value for that specific instance. The feature of optional contained elements provide forward and backward compatibility of the service interface as new added record elements can just be ignored by old applications. <pre class="fragment">struct BatteryState {
  Voltage_t voltage;
  Temperature_t temperature;
  ara::com::optional&lt;Current_t&gt; current;
  ara::com::optional&lt;Health&gt; health;
};
</pre></li>
</ul>
<h3>2.1.2 Instance Identifier</h3>
<ul>
<li>Instance identifiers are used within ara::com during following scenarios:<ul>
<li>On client/proxy side when a specific instance of a service will be searched for.</li>
<li>At the server/skeleton side when a specific instance of a service is created.</li>
</ul>
</li>
<li>At ara::com API level the instance identifier is a technical binding specific identifier. The content of instance identifier are totally technology specific.</li>
<li>Example: SOME/IP is using 16 bit unsigned integer, while DDS (DDS-RPC) uses string&lt;256&gt; as service_instance_name.</li>
<li>Independant of the binding technology, instance identifier complying to a signature given below. <div class="fragment"><div class="line">  <span class="keyword">class </span>InstanceIdentifier {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> InstanceIdentifier Any;</div><div class="line"></div><div class="line">  <span class="keyword">explicit</span> InstanceIdentifier(std::string value);</div><div class="line">  std::string toString() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> InstanceIdentifier&amp; other) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> InstanceIdentifier&amp; other) <span class="keyword">const</span>;</div><div class="line">  InstanceIdentifier&amp; operator=(<span class="keyword">const</span> InstanceIdentifier&amp; other);</div><div class="line"></div><div class="line">};</div></div><!-- fragment --></li>
<li>An ara:com provided functionality, which translates a logical local name used by the software developer in his realm into the technology/binding specific ara::com::InstanceIdentifier.</li>
<li>The local name from which the ara::com::InstanceIdentifier is constructed comes basically from AUTOSAR meta-model, describing your software component model.</li>
<li>The requirement for this local name(abstract identifier) is, that it is unambiguous within an executable. It has basically the form:</li>
</ul>
<div class="fragment"><div class="line">&lt;context 0&gt;::&lt;context 1&gt;::...::&lt;context N&gt;::&lt;port name&gt;</div></div><!-- fragment --><p> If the unambiguousness is ensured, the integrator/deployer can assign a dedicated technical binding with its specific instance ids to those abstract identifiers via a "manifest file", which is specifically used for a distinct instantiation/execution of the executable.</p><ul>
<li>This explicitly allows, to start the same executable N times, each time with a different manifest, which maps the same abstract identifier differently.</li>
<li>The API ara:com provides, to do the translation from the abstract identifier (local name in the software developers realm) to the technical ara::com::InstanceIdentifier, is the following:</li>
</ul>
<div class="fragment"><div class="line">std::vector&lt;InstanceIdentifier&gt; ResolveInstanceIdentifiers(ara::meta::ModelIdentifier modelName);</div></div><!-- fragment --><ul>
<li>API does return a list of ara::com::InstanceIdentifier</li>
<li>AUTOSAR supports, that the integrator may configure multiple technical bindings behind one abstract identifier visible to the software component developer.This feature is called multi-binding.</li>
<li>Using multi-binding on the skeleton/ server side is a common use case, since it simply allows different clients to use their preferred binding, when contacting the server.</li>
<li>On the Contrary using multi-binding on the proxy/client side is a rather exotic one. E.g. it could be used to support some failover approaches (if binding A does not work, fall back on binding B).</li>
<li>The possible returns for a call of ResolveInstanceIdentifiers() are:<ul>
<li>empty list: The integrator failed to provide a mapping for the abstract identifier. This most likely is a configuration error.</li>
<li>list with one element: The common case. No multi-binding.</li>
</ul>
</li>
</ul>
<h2>2.2 Proxy Class</h2>
<ul>
<li>ara::com does standardization of the interface of the generated Proxy class. <blockquote class="doxtable">
<p><b>Note:The interfaces , Proxy class has to provide are defined by ara::com, a generic (product independent) generator could generate an abstract class or a mock class against which the application developer could implement the service consumer application. This perfectly suits the platform vendor independent development of Adaptive AUTOSAR SWCs.</b> </p>
</blockquote>
</li>
<li>ara::com expects proxy related artifacts inside a namespace "proxy". This namespace is typically included in a namespace hierarchy deduced from the service definition and its context. <div class="fragment"><div class="line"><span class="keyword">class </span>RadarServiceProxy {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">  <span class="comment">/* </span></div><div class="line"><span class="comment">   * brief Implementation is platform vendor specific</span></div><div class="line"><span class="comment">   * A HandleType must contain the information that is needed to create a</span></div><div class="line"><span class="comment">     proxy.</span></div><div class="line"><span class="comment">   * This information will be hidden.</span></div><div class="line"><span class="comment">   * Since the platform vendor is responsible for creation of handles, the</span></div><div class="line"><span class="comment">   * ctor signature is not given as it is not of interest to the user.</span></div><div class="line"><span class="comment">   */</span></div><div class="line"></div><div class="line">  <span class="keyword">class </span>HandleType {</div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * brief Two ServiceHandles are considered equal if they represent the</span></div><div class="line"><span class="comment">     same service instance.</span></div><div class="line"><span class="comment">   * param other</span></div><div class="line"><span class="comment">   * return</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> HandleType &amp;other) <span class="keyword">const</span>;</div><div class="line">  <span class="keyword">const</span> ara::com::InstanceIdentifier &amp;GetInstanceId() <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * StartFindService does not need an explicit version parameter as this</span></div><div class="line"><span class="comment">     is internally available in ProxyClass</span></div><div class="line"><span class="comment">   * That means only compatible services are returned.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * param handler this handler gets called any time the service</span></div><div class="line"><span class="comment">     availability of the services matching the given</span></div><div class="line"><span class="comment">   * instance criteria changes. If you use this variant of FindService,</span></div><div class="line"><span class="comment">     the Communication Management has to</span></div><div class="line"><span class="comment">   * continuously monitor the availability of the services and call the</span></div><div class="line"><span class="comment">     handler on any change.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * param instance which instance of the service type defined by T will</span></div><div class="line"><span class="comment">     be searched/found. Wildcards may be given.</span></div><div class="line"><span class="comment">   * Default value is wildcard.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * return a handle for this search/find request, which will be used to </span></div><div class="line"><span class="comment">     stop the availability monitoring and related</span></div><div class="line"><span class="comment">   * firing of the given handler. (\see StopFindService())</span></div><div class="line"><span class="comment">   **/</span></div><div class="line">  <span class="keyword">static</span> ara::com::FindServiceHandle StartFindService(</div><div class="line">  ara::com::FindServiceHandler&lt;RadarServiceProxy::HandleType&gt; handler,</div><div class="line">  ara::com::InstanceIdentifier instance =</div><div class="line">  ara::com::InstanceIdentifier::Any);</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * Method to stop finding service request (see above)</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> StopFindService(ara::com::FindServiceHandle handle);</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * Opposed to StartFindService(handler, instance) this version is a &quot;oneshot&quot;</span></div><div class="line"><span class="comment">     find request, which is</span></div><div class="line"><span class="comment">   * - synchronous, i.e. it returns after the find has been done and a</span></div><div class="line"><span class="comment">    result list of matching service instances is</span></div><div class="line"><span class="comment">   * available. (list may be empty, if no matching service instances </span></div><div class="line"><span class="comment">     currently exist)</span></div><div class="line"><span class="comment">   * - does reflect the availability at the time of the method call. No</span></div><div class="line"><span class="comment">    further (background) checks of availability</span></div><div class="line"><span class="comment">   * are done.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * param instance which instance of the service type defined by T will</span></div><div class="line"><span class="comment">     searched/found. Wildcards may be given.</span></div><div class="line"><span class="comment">   * Default value is wildcard.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">static</span> ara::com::ServiceHandleContainer&lt;RadarServiceProxy::HandleType&gt;</div><div class="line">  FindService(</div><div class="line">  ara::com::InstanceIdentifier instance =</div><div class="line">  ara::com::InstanceIdentifier::Any);</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * brief The proxy can only be created using a specific handle which</span></div><div class="line"><span class="comment">    identifies a service.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * This handle can be a known value which is defined at deployment or it </span></div><div class="line"><span class="comment">     can be obtained using the ProxyClass::FindService method.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * param handle The identification of the service the proxy should represent.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">explicit</span> RadarServiceProxy(HandleType &amp;handle);</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * brief Public member for the BrakeEvent</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  events::BrakeEvent BrakeEvent;</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * brief Public Field for UpdateRate</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  fields::UpdateRate UpdateRate;</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * brief Public member for the Calibrate method</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  methods::Calibrate Calibrate;</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * brief Public member for the Adjust method</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  methods::Adjust Adjust;</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * brief Public member for the LogCurrentState fire-and-forget method</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  methods::LogCurrentState LogCurrentState;</div><div class="line">};</div></div><!-- fragment --></li>
</ul>
<h3>2.2.1 Constructor and Handle Concept</h3>
<ul>
<li>As seen in the above code, ara::com prescribes the Proxy class to provide a constructor. This means, that the developer is responsible for creating a proxy instance to communicate with a possibly remote service. The ctor takes a parameter of type RadarServiceProxy::HandleType — an inner class of the generated proxy class.</li>
<li>After the call to the ctor, there is proxy instance, which allows to communicate with the service. Therefore the handle has to contain the needed addressing information, so that the Communication Management binding implementation is able to contact the service.</li>
</ul>
<h3>2.2.2 Finding Services</h3>
<ul>
<li>The Proxy class provides class (static) methods to find service instances, which are compatible with the Proxy class.</li>
<li>Since the availability of service instances is dynamic by nature, as they have a life cycle, ara::com provides two different ways to do a ‘FindService’ for convenience:<ul>
<li>StartFindService is a class method, which starts a continuous ‘FindService’ activity in the background, which notifies the caller via a given callback anytime the availability of instances of the service changes.</li>
<li>FindService is a one-off call, which returns available instances at the point in time of the call.</li>
</ul>
</li>
<li>Both of those methods have the instance parameter in common, which allows to either search for an explicit instance of the service or any instance (which is the default parameter value). The synchronous one-off variant FindService returns a container of handles for the matching service instances, which might also be empty, if no matching service instance is currently available. Opposed to that, the StartFindService returns a FindServiceHandle, which can be used to stop the ongoing background activity of monitoring service instance availability via call to StopFindService. The first (and specific for this variant) parameter to StartFindService is a user provided handler function with the following signature:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">using</span> FindServiceHandler = std::function&lt;void(ServiceHandleContainer&lt;T&gt;)&gt;;</div></div><!-- fragment --><h4>2.2.2.1 Auto Update Proxy instance</h4>
<ul>
<li>Irrespective of the usage of one-off FindService or the StartFindService variant, in both cases a handle identifying the — possibly remote — service instance is received, from which proxy instance is created.</li>
<li>In the service based communication universe it is expected, that during the life time of the entire system (e.g. vehicle) service provider and consumer instances start up and go down frequently due to their own life cycle concepts. To deal with this, there is service discovery infrastructure, where the life cycle of service providers and consumers is monitored in terms of service offerings and service (re)subscriptions. If a service consumer application has instantiated a service proxy instance from a handle returned from some of the Find Service variants, the following sequence might possibly occur:</li>
</ul>
<div class="image">
<img src="AutoUpdatingProxyInstance.png" alt="AutoUpdatingProxyInstance.png"/>
<div class="caption">
Auto Updating of Proxy Instance</div></div>
<ul>
<li>Explanation of above figure:<ul>
<li><b>T0</b>: The service consumer may successfully call a service method of that proxy and GetSubscriptionState() on subscribed events will return kSubscribed.</li>
<li><b>T1</b>: The service instance goes down, correctly notified via service discovery.</li>
<li><b>T2</b>: A call of a service method on that proxy will lead to an exception, since the targeted service instance of the call does not exist anymore. Correspondingly GetSubscriptionState() on any subscribed event will return kSubscriptionPending at this point even if the event has been successfully subscribed (kSubscribed) before.</li>
<li><b>T3</b>: The service instance comes up again, notified via service discovery infrastructure. The CM at the proxy side will be notified and will silently update the proxy object instance with a possibly changed transport layer addressing information.</li>
<li><b>T4</b>:Consequently service method calls on that proxy instance will succeed again and GetSubscriptionState() on events which the service consumer had subscribed before, will return kSubscribed again.</li>
</ul>
</li>
</ul>
<h3>2.2.3 Events</h3>
<ul>
<li>For each event the remote service provides, the proxy class containing a member of a event specific wrapper class.</li>
<li>In the example the member has the name BrakeEvent and is of type events::BrakeEvent.</li>
<li>Below mentioned method gets generated for each event.</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">Method </th><th align="left">Description  </th></tr>
<tr>
<td align="left">void Subscribe(ara::com::EventCacheUpdatePolicy policy, size_t cacheSize); </td><td align="left">Used for subscription of events </td></tr>
<tr>
<td align="left">ara::com::SubscriptionState GetSubscriptionState() const; </td><td align="left">Query current subscription state </td></tr>
<tr>
<td align="left">void Unsubscribe(); </td><td align="left">Unsubscribe from the service </td></tr>
<tr>
<td align="left">void SetReceiveHandler(ara::com::EventReceiveHandler handler); </td><td align="left">Setting a receive handler signals the Communication Management implementation to use event style mode. </td></tr>
<tr>
<td align="left">void UnsetReceiveHandler(); </td><td align="left">Remove handler set by SetReceiveHandler </td></tr>
<tr>
<td align="left">void SetSubscriptionStateChangeHandler(ara::com:: SubscriptionStateChangeHandler handler); </td><td align="left">Setting a subscription state change handler, which gets called by the Communication Management implementation as soon as the subscription state of this event has hanged. </td></tr>
<tr>
<td align="left">void UnsetSubscriptionStateChangeHandler(); </td><td align="left">Remove handler set by SetSubscriptionStateChangeHandler </td></tr>
<tr>
<td align="left">bool Update(ara::com::FilterFunction&lt;SampleType&gt; filter = {}); </td><td align="left">Fetch data from the Communication Management buffers and apply filter before writing the samples into the cache. </td></tr>
<tr>
<td align="left">const ara::com::SampleContainer&lt;ara::com::SamplePtr&lt;const SampleType&gt;&gt; &amp; GetCachedSamples() const; </td><td align="left">Get the container of the samples in the cache that was updated by the last call of upadate </td></tr>
<tr>
<td align="left">void Cleanup(); </td><td align="left">Explicitly clean the application local cache </td></tr>
</table>
<div class="fragment"><div class="line"><span class="keyword">class </span>BrakeEvent {</div><div class="line">   <span class="comment">/*</span></div><div class="line"><span class="comment">   * brief Shortcut for the events data type.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">   <span class="keyword">using</span> SampleType = RadarObjects;</div><div class="line"></div><div class="line">   <span class="comment">/*</span></div><div class="line"><span class="comment">   * brief The application expects the Communication Management to</span></div><div class="line"><span class="comment">     subscribe the event.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * The Communication Management will try to subscribe and resubscribe</span></div><div class="line"><span class="comment">     until \see</span></div><div class="line"><span class="comment">   * Unsubscribe() is called explicitly.</span></div><div class="line"><span class="comment">   * The error handling will be kept within the Communication Management.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * The function return immediately. If the user wants to get notified,</span></div><div class="line"><span class="comment">     when subscription has succeeded, he needs</span></div><div class="line"><span class="comment">   * to register a handler via \see SetSubscriptionStateChangeHandler().</span></div><div class="line"><span class="comment">     This handler gets then called after</span></div><div class="line"><span class="comment">   * subscription was successful.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * \param policy Defines the update policy for the application local cache.</span></div><div class="line"><span class="comment">   * \param cacheSize Defines the size of the application local cache.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   */</span></div><div class="line">   <span class="keywordtype">void</span> Subscribe(ara::com::EventCacheUpdatePolicy policy, <span class="keywordtype">size_t</span> cacheSize);</div><div class="line"></div><div class="line">   <span class="comment">/*</span></div><div class="line"><span class="comment">   * brief query current subscription state.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * \return current state of the subscription.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">   ara::com::SubscriptionState GetSubscriptionState() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">   <span class="comment">/*</span></div><div class="line"><span class="comment">   * brief Unsubscribe from the service.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">   <span class="keywordtype">void</span> Unsubscribe();</div><div class="line"></div><div class="line">   <span class="comment">/*</span></div><div class="line"><span class="comment">   * Setting a receive handler signals the Communication Management </span></div><div class="line"><span class="comment">     implementation to use event style mode.</span></div><div class="line"><span class="comment">   * I.e. the registered handler gets called asynchronously by the</span></div><div class="line"><span class="comment">     Communication Management as soon as new event data</span></div><div class="line"><span class="comment">   * arrives for that event. If user wants to have strict polling behaviour,</span></div><div class="line"><span class="comment">     where you decide when to check for</span></div><div class="line"><span class="comment">   * new data via Update() he should NOT register a handler.</span></div><div class="line"><span class="comment">   * Handler may be overwritten anytime during runtime.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Provided Handler needs not to be re-entrant since the Communication</span></div><div class="line"><span class="comment">     Management implementation has to serialize calls</span></div><div class="line"><span class="comment">   * to the handler: Handler gets called once by the MW, when new events</span></div><div class="line"><span class="comment">     arrived since the last call to Update().</span></div><div class="line"><span class="comment">   * When application calls Update() again in the context of the receive</span></div><div class="line"><span class="comment">     handler, MW must - in case new events arrived</span></div><div class="line"><span class="comment">   * in the meantime - defer next call to receive handler until after the</span></div><div class="line"><span class="comment">     previous call to receive handler has been</span></div><div class="line"><span class="comment">   * completed.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   **/</span></div><div class="line">   <span class="keywordtype">void</span> SetReceiveHandler(ara::com::EventReceiveHandler handler);</div><div class="line"></div><div class="line">   <span class="comment">/*</span></div><div class="line"><span class="comment">   * Remove handler set by SetReceiveHandler()</span></div><div class="line"><span class="comment">   **/</span></div><div class="line">   <span class="keywordtype">void</span> UnsetReceiveHandler();</div><div class="line"></div><div class="line">   <span class="comment">/*</span></div><div class="line"><span class="comment">   * Setting a subscription state change handler, which gets called by</span></div><div class="line"><span class="comment">     the Communication Management</span></div><div class="line"><span class="comment">   * implementation as soon as the subscription state of this event has</span></div><div class="line"><span class="comment">     changed.</span></div><div class="line"><span class="comment">   * Communication Management implementation will serialize calls to the</span></div><div class="line"><span class="comment">     registered handler. If multiple</span></div><div class="line"><span class="comment">   * changes of the subscription state take place during the runtime of a</span></div><div class="line"><span class="comment">     previous call to a handler, the</span></div><div class="line"><span class="comment">   * Communication Management aggregates all changes to one call with the</span></div><div class="line"><span class="comment">     last/effective state.</span></div><div class="line"><span class="comment">   * Handler may be overwritten during runtime.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   **/</span></div><div class="line">   <span class="keywordtype">void</span>  SetSubscriptionStateChangeHandler(ara::com:: SubscriptionStateChangeHandler   handler);</div><div class="line"></div><div class="line">   <span class="comment">/*</span></div><div class="line"><span class="comment">   * Remove handler set by SetSubscriptionStateChangeHandler()</span></div><div class="line"><span class="comment">   **/</span></div><div class="line">   <span class="keywordtype">void</span> UnsetSubscriptionStateChangeHandler();</div><div class="line"></div><div class="line">   <span class="comment">/*</span></div><div class="line"><span class="comment">   * brief Fetch data from the Communication Management buffers and apply</span></div><div class="line"><span class="comment">     filter before</span></div><div class="line"><span class="comment">   * writing the samples into the cache.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * \pre BrakeEvent::Subscribe has been called before (and not be</span></div><div class="line"><span class="comment">     withdrawn by BrakeEvent::Unsubscribe)</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * \param filter</span></div><div class="line"><span class="comment">   * parblock</span></div><div class="line"><span class="comment">   * FilterFunction for the samples.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * This filter will be applied to the deserialized data within the</span></div><div class="line"><span class="comment">     context of</span></div><div class="line"><span class="comment">   * the update this function should return true if the sample will be</span></div><div class="line"><span class="comment">     added to</span></div><div class="line"><span class="comment">   * the cache.</span></div><div class="line"><span class="comment">   * parblockend</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * \return True if new values received and those values are NOT ALL</span></div><div class="line"><span class="comment">     filtered out,</span></div><div class="line"><span class="comment">   * else false.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * \note If precondition is not fulfilled, middleware impl might raise an</span></div><div class="line"><span class="comment">     unchecked exception</span></div><div class="line"><span class="comment">   * (e.g. NotSubscribed).</span></div><div class="line"><span class="comment">   */</span></div><div class="line">   <span class="keywordtype">bool</span> Update(ara::com::FilterFunction&lt;SampleType&gt; filter = {});</div><div class="line">   <span class="comment">/*</span></div><div class="line"><span class="comment">   * brief Get the container of the samples in the cache that was updated</span></div><div class="line"><span class="comment">     by the last call</span></div><div class="line"><span class="comment">   * of \see update.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * The container and referenced data is expected to be stable until</span></div><div class="line"><span class="comment">     update is</span></div><div class="line"><span class="comment">   * called again.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * \return Container of SamplePtr</span></div><div class="line"><span class="comment">   */</span></div><div class="line">   <span class="keyword">const</span> ara::com::SampleContainer&lt;ara::com::SamplePtr&lt;const SampleType&gt;&gt; &amp;</div><div class="line">   GetCachedSamples() <span class="keyword">const</span>;</div><div class="line">   <span class="comment">/*</span></div><div class="line"><span class="comment">   * brief Explicitly clean the application local cache.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * This should free the references to the data samples which are owned by</span></div><div class="line"><span class="comment">     the</span></div><div class="line"><span class="comment">   * Communication Management.</span></div><div class="line"><span class="comment">   * This method only has an effect if policy in the call to \see Subscribe</span></div><div class="line"><span class="comment">     has been</span></div><div class="line"><span class="comment">    * set to kNewestN!</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="keywordtype">void</span> Cleanup();</div><div class="line"> };</div></div><!-- fragment --> <h4>2.2.3.1 Event Subscription and Cache Semantics</h4>
<ul>
<li>The mere fact, that there exists a member of the event wrapper class inside the proxy instance does not mean, that the user gets instant access to events raised/sent out by service instance. First ‘subscribe’ for the event, in order to tell the Communication Management, that the application is now interested in receiving events. For that purpose the event wrapper class of ara::com provides below method:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * brief The application expects the Communication Management to</span></div><div class="line"><span class="comment">    subscribe the event.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ....</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param policy Defines the update policy for the application local</span></div><div class="line"><span class="comment">   cache.</span></div><div class="line"><span class="comment"> * \param cacheSize Defines the size of the application local cache.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div><div class="line">  <span class="keywordtype">void</span> Subscribe(ara::com::EventCacheUpdatePolicy policy, <span class="keywordtype">size_t</span> cacheSize);</div></div><!-- fragment --><ul>
<li>This method expects two parameters, policy and cacheSize.</li>
</ul>
<h5>2.2.3.1.1 policy</h5>
<ul>
<li>With this parameter you control how the cache is updated if you call the Update method. Currently ara::com support two policies:</li>
<li><b>kLastN:</b> With this policy new available events are put in the cache by each call of Update. If they do not fit in the cache, older entries (oldest first) are displaced. With this policy the following applies: If the cache has been filled with a certain amount of events, the amount can only remain constant (if no new event has arrived) or get bigger with upcoming Update calls (if new events have been arrived).</li>
<li><b>kNewestN:</b> With this policy in each update the cache gets cleared and then filled with the newest arrived events. Even if NO event has arrived since the last call to Update, the cache gets cleared/emptied.</li>
</ul>
<h5>2.2.3.1.2 cacheSize</h5>
<ul>
<li>With calling the method, you not only tell the Communication Management, that you now are interested in receiving event updates, but you are at the same time setting up a local cache for those events bound to the event wrapper instance with the given cacheSize.</li>
<li>The idea behind this is very simple and possible uses are:<ul>
<li><b>stability</b></li>
<li><b>interpolation/averaging between a number of events</b></li>
<li><b>rate adoption</b></li>
</ul>
</li>
<li>Stability is realized with this concept by having an explicit method (see below) to update event data inside the cache. So this local cache decouples the event-wrapper instance from the Communication Management buffers into which the service instance may send its event updates! Updates of the cache status/content is only done explicitly by the user by calling Update.</li>
</ul>
<h4>2.2.3.2 Monitoring Event Subscription</h4>
<ul>
<li>The call to the Subscribe method is asynchronous by nature. This means that at the point in time Subscribe returns, it is just the indication, that the Communication Management has accepted the order to care for subscription.</li>
<li>If the user needs to monitor the subscription state, he has two possibilities:<ul>
<li><b>Polling via GetSubscriptionState</b></li>
<li><b>Registering a handler, which gets called, when the subscription state changes</b></li>
</ul>
</li>
</ul>
<h5>2.2.3.2.1 Polling via GetSubscriptionState</h5>
<ul>
<li>If the user — after having called Subscribe — wants to get feedback about the success of the subscription, he might call: <div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * brief query current subscription state.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \return current state of the subscription.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">ara::com::SubscriptionState GetSubscriptionState() <span class="keyword">const</span>;</div></div><!-- fragment --></li>
</ul>
<h5>2.2.3.2.1 Registering a handler, which gets called, when the subscription state changes</h5>
<ul>
<li>User register a handler function, for subscription state changes. <div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Setting a subscription state change handler, which gets called by</span></div><div class="line"><span class="comment">   the Communication Management implementation as soon</span></div><div class="line"><span class="comment"> * as the subscription state of this event has changed.</span></div><div class="line"><span class="comment"> * Handler may be overwritten during runtime.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> **/</span></div><div class="line"> <span class="keywordtype">void</span> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler);</div></div><!-- fragment --></li>
<li>Anytime the subscription state changes, the Communication Management implementation calls the registered handler.</li>
</ul>
<h4>2.2.3.3 Event-Driven vs Polling-Based access</h4>
<ul>
<li><b>Polling-Based access</b><ul>
<li>An explicit interaction needed with ara::com API by calling Update to fill the local event wrapper specific cache: <div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">* brief Fetch data from the Communication Management buffers and apply filter before</span></div><div class="line"><span class="comment">* writing the samples into the cache.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* \pre BrakeEvent::Subscribe has been called before (and not be withdrawn by BrakeEvent::Unsubscribe)</span></div><div class="line"><span class="comment">* \param filter</span></div><div class="line"><span class="comment">*  parblock</span></div><div class="line"><span class="comment">* FilterFunction for the samples.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* This filter will be applied to the deserialized data within the context of</span></div><div class="line"><span class="comment">* the update this function should return true if the sample is added to</span></div><div class="line"><span class="comment">* the cache.</span></div><div class="line"><span class="comment">* parblockend</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* \return True if new values received and those values are NOT ALL filtered out,</span></div><div class="line"><span class="comment">* else false.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* \note If precondition is not fulfilled, middleware impl might raise an unchecked exception</span></div><div class="line"><span class="comment">* (e.g. NotSubscribed).</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keywordtype">bool</span> Update(ara::com::FilterFunction&lt;SampleType&gt; filter = {});</div></div><!-- fragment --></li>
<li>The method takes an optional parameter of a user defined filter function. <div class="fragment"><div class="line"><span class="keyword">using</span> FilterFunction = std::function&lt;bool(const S&amp; sample)&gt;;</div></div><!-- fragment --></li>
<li>the user provided filter function gets an event (sample) and has to return true after checking, if he wants the sample to be put into the local cache.</li>
<li>During Update(), the Communication Management calls the filter function for each event, which has arrived since the last call to Update().</li>
<li>Update returns true in case new events have been placed into the local cache by the call, false otherwise.</li>
<li>After filling event specific local cache with event-data via Update() user typically want access those events. This is done with the following API: <div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * brief Get the container of the samples in the cache that was updated by the last call</span></div><div class="line"><span class="comment"> * of \see update.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The container and referenced data is expected to be stable until update is</span></div><div class="line"><span class="comment"> * called again.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \return Container of SamplePtr</span></div><div class="line"><span class="comment"> */</span></div><div class="line"> <span class="keyword">const</span> ara::com::SampleContainer&lt;ara::com::SamplePtr&lt;const SampleType&gt;&gt; &amp;GetCachedSamples() <span class="keyword">const</span>;</div></div><!-- fragment --></li>
<li>User can call this method as many times as you want — as long as user do not call Update() in between, the returned collection will always be the same/stable, even if the service side has send out several new events.</li>
</ul>
</li>
<li><b>Event-Driven</b></li>
<li>If user explicitly want the Communication Management to notify application thereby issuing asynchronous context switches to application process by below API.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> SetReceiveHandler(ara::com::EventReceiveHandler handler);</div></div><!-- fragment --><ul>
<li>This API allows user to register a user defined callback, which the Communication Management has to call in case new event data is available since the last call to Update().</li>
</ul>
<h4>2.2.3.4 Buffering Strategies</h4>
<ul>
<li>The following figure sketches a simple deployment, where we have a service providing an event, for which two different local adaptive SWCs have subscribed through their respective ara::com proxies/event wrappers.</li>
<li>Both proxies have a local event cache. This is the cache, which gets filled via Update().</li>
<li>Service implementation sends its event data to a Communication Management buffer, which is apparently outside the process space of the service implementation</li>
</ul>
<div class="image">
<img src="EventBufferingApproaches.png" alt="EventBufferingApproaches.png"/>
<div class="caption">
Event Buffering Approaches</div></div>
<ul>
<li>This buffer is owned by kernel or it is realized as a shared memory between communicating proxies and skeleton or owned by a separate binding implementation specific ‘demon’ process.<ul>
<li><b>Kernel Space</b></li>
<li><b>Shared Memory</b></li>
<li><b>IPC-Demon Process</b></li>
</ul>
</li>
</ul>
<h3>2.2.4 Methods</h3>
<ul>
<li>For each method the remote service provides, the proxy class contains a member of a method specific wrapper class.</li>
<li>In our example, we have two methods and the corresponding members have the name Calibrate (of type methods::Calibrate) and Adjust (of type methods::Adjust).</li>
</ul>
<div class="image">
<img src="images/AdjustMethodClass.png"  alt="Adjust Method Class"/>
</div>
<ul>
<li>The return value of a call to a service method, which is not a “one-way method” is an ara::com::Future, where the template parameter is of the type of the inner struct, which aggregates all OUT-parameters of the method.</li>
</ul>
<h4>2.2.4.1 One-Way or Fire-and-Forget Methods</h4>
<ul>
<li>ara::com supports a special flavor of a method, which we call “one-way” or “fire-and-forget”.</li>
<li>Technically this is a method with only IN-params — no OUT-params and no raising of errors allowed.</li>
<li>The client/caller therefore gets no feedback at all, whether the server/callee has processed a “one-way” call or not.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>LogCurrentState {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">  * brief Operation will call the method.</span></div><div class="line"><span class="comment">  *</span></div><div class="line"><span class="comment">  * Using the operator the call will be made by the Communication Management.</span></div><div class="line"><span class="comment">  * It is a one-way method, so no feedback (return value/out-parameter) is given.</span></div><div class="line"><span class="comment">  */</span></div><div class="line">  <span class="keywordtype">void</span> operator()();</div><div class="line">};</div></div><!-- fragment --> <h4>2.2.4.2 Event-Driven vs Polling access to method results</h4>
<h5>2.2.4.2.1 Event-Driven</h5>
<ul>
<li>Event-Driven means, that the caller of the method (the application with the proxy instance) gets notified by the Communication Management implementation as soon as the method call result has arrived.</li>
<li>Event driven method call can be achieve with following ways:<ul>
<li><b>1.future.get()</b></li>
<li><b>2.wait(), wait_for() or wait_until()</b></li>
<li><b>3.Registering a callback method via then()</b></li>
</ul>
</li>
</ul>
<h5>2.2.4.2.2 Polling access</h5>
<ul>
<li>It is used in RT(real time) application.</li>
<li>ara::com::Future::is_ready() is used to poll the method whether the method call has been finished.</li>
<li>After ara::com::Future::is_ready() has returned true, it is guaranteed that the next call to ara::com::Future::get() will NOT block, but immediately return either the valid value or throw an exception in case of error</li>
</ul>
<h4>2.2.4.3 Canceling Method Result</h4>
<ul>
<li>There may be cases, where you already have called a service method via the ()- operator, which returned you an ara::com::Future, but you are not interested in the result anymore.</li>
<li>It could even be the case, that you already have registered a callback via ara::com::Future::then() for it. Instead of just let things go and ‘ignore’ the callback, you should tell the Communication Management explicitly.</li>
<li>This might free resources and avoid unnecessary processing load on the binding implementation level.</li>
<li>Telling that you are not interested in the method call result anymore is simply done by letting the ara::com::Future go out of scope, so that its destructor gets called.</li>
<li>Call of the dtor of the ara::com::Future is a signal to the binding implementation, that any registered callback for this future should not be called anymore, reserved/allocated memory for the method call result might be freed and event waiting mechanisms for the method result should be stopped.</li>
</ul>
<h4>2.2.4.4 Checked Exception Handling</h4>
<ul>
<li>Unchecked Exceptions might be thrown by any ara::com API call, whereas Checked Exceptions might be thrown only in the context of non “one-way/fire-and-forget” service interface method calls.</li>
<li>There are two types of Checked Exceptions, which might be thrown in the course of a service method call on the proxy side:</li>
<li>ServiceNotAvailableException:This is a direct subclass of std::exception and will be thrown by the middleware implementation, when it detects during processing of a method call, that the providing service instance has already stopped offering the service.</li>
<li>Subclasses of ara::com::ApplicationErrorException:which are defined on meta-model level for a specific service interface method as ApplicationError and which are created at the application level service provider (skeleton) side and transported to the caller (proxy) side.</li>
<li>If one of those Checked Exception types happens, it will always be thrown in the context of the ara::com::Future::Get() call.</li>
<li>Calibrate method may raise the two application errors CalibrationFailed and InvalidConfigString, which get transformed to subclasses of ara::com::ApplicationErrorException on ara::com API level: <div class="fragment"><div class="line"> <span class="keyword">using namespace </span>ara::com;</div><div class="line"> <span class="keyword">using namespace </span>com::mycompany::division::radarservice;</div><div class="line"></div><div class="line"> Future&lt;Calibrate::Output&gt; calibrateFuture;</div><div class="line"></div><div class="line"> <span class="keywordtype">int</span> main() {</div><div class="line"> <span class="comment">// some code to acquire handle</span></div><div class="line"> <span class="comment">// ...</span></div><div class="line"> RadarServiceProxy service(handle);</div><div class="line"> calibrateFuture = service.Calibrate(myConfigString);</div><div class="line"></div><div class="line"> <span class="comment">/* ....</span></div><div class="line"><span class="comment"> Now we access the future (with potentially blocking) Get()</span></div><div class="line"><span class="comment"> and directly handle the 3 different checked exceptions, which</span></div><div class="line"><span class="comment"> might be raised. */</span></div><div class="line"></div><div class="line"> <span class="keywordflow">try</span> {</div><div class="line"> calibrateFuture.Get();</div><div class="line"> } <span class="keywordflow">catch</span> (<span class="keyword">const</span> ServiceNotAvailableException&amp; e) {</div><div class="line"> <span class="comment">// react on service shut down ...</span></div><div class="line"> cout &lt;&lt; <span class="stringliteral">&quot;RadarService not available anymore&quot;</span> &lt;&lt; endl;</div><div class="line"> ...</div><div class="line"> } <span class="keywordflow">catch</span> (<span class="keyword">const</span> CalibrationFailed&amp; e) {</div><div class="line"> <span class="comment">// react on Application Error ’CalibrationFailed’ ...</span></div><div class="line"> cout &lt;&lt; <span class="stringliteral">&quot;RadarService calibration failed because: &quot;</span> &lt;&lt; e.getFailureText() &lt;&lt; endl;</div><div class="line"> ...</div><div class="line"> } <span class="keywordflow">catch</span> (<span class="keyword">const</span> InvalidConfigString&amp; e) {</div><div class="line"> <span class="comment">// react on Application Error ’InvalidConfigString’ ...</span></div><div class="line"> cout &lt;&lt; <span class="stringliteral">&quot;Oops, we called RadarService.Calibrate with invalid config string: &quot;</span> &lt;&lt; e.getInvalidConfig() &lt;&lt; endl;</div><div class="line"> cout &lt;&lt; <span class="stringliteral">&quot;Current (valid) config is: &quot;</span> &lt;&lt; e.getCurrentValidConfig() &lt;&lt; endl;</div><div class="line"> ...</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="comment">// go on doing something ...</span></div><div class="line"> <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --></li>
</ul>
<h3>2.2.5 Fields</h3>
<ul>
<li>Conceptually a field has — unlike an event — a certain value at any time. That result in the following additions compared to an event:<ul>
<li>if a subscribtion to a field has been done, “immediately” initial values are sent back to the subscriber in an event-like notification pattern.</li>
<li>the current field value can be queried via a call to a Get() method or could be updated via a Set() method.</li>
</ul>
</li>
<li>Field concept is roughly an aggregation of an event with correlated get()/set() methods.<ul>
<li>call Get() or Set() methods of the field with exactly the same mechanism as regular methods</li>
<li>access field update notifications in the form of events/event data, which are sent by the service instance our proxy is connected to with exactly the same mechanism as regular events</li>
</ul>
</li>
</ul>
<div class="image">
<img src="UpdateRateFieldClass.png" alt="UpdateRateFieldClass.png"/>
<div class="caption">
UpdateRate Field Class</div></div>
 <h2>2.3 Skeleton Class</h2>
<ul>
<li>The Skeleton class is generated from the service interface description of the AUTOSAR meta model.</li>
<li>ara::com does standardize the interface of the generated Skeleton class.</li>
<li>The toolchain of an AP product vendor will generate a Skeleton implementation class exactly implementing this interface.</li>
<li>The generated Skeleton class is an abstract class. It cannot be instantiated directly, because it does not contain implementations of the service methods, which the service should provide.</li>
<li>Therefore the service implementer has to subclass the skeleton and provide the service method implementation within the subclass. <div class="image">
<img src="RadarServiceskeleton.png" alt="RadarServiceskeleton.png"/>
<div class="caption">
RadarService Skeleton</div></div>
</li>
</ul>
<h3>2.3.1 Instantiation</h3>
<ul>
<li>Skeleton class from which the service implementer has to subclass his service implementation provides a ctor with a parameter of type ara::com::InstanceIdentifier.</li>
<li>This identifier has to be unique — creating two instances in a way that they would exist at the same time with the same instance identifier will raise an exception.</li>
<li>If a new instance will be created with the same identifier, the existing instance needs to be destroyed before.</li>
</ul>
<h3>2.3.2 Offering Service instance</h3>
<ul>
<li>The skeleton provides the method OfferService(). As application developer for the service provider side — have instantiated your custom service implementation class and initialized/set up your instance to a state, where it is now able to serve requests (method calls) and provide events to subscribing consumers, you will call this OfferService() method on your instance.</li>
<li>If you decide at a certain point (maybe due to some state changes), that you do not want to provide the service anymore, you call StopOfferService() on your instance.</li>
</ul>
<h3>2.3.3 Polling and event-driven processing modes</h3>
<ul>
<li>The behavior of a skeleton instance is controlled by the second parameter of Skeleton class ctor, which is of type ara::com::MethodCallProcessingMode.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">* Request processing modes for the service implementation side</span></div><div class="line"><span class="comment">* (skeleton).</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* \note Should be provided by platform vendor exactly like this.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">enum class</span> MethodCallProcessingMode { kPoll, kEvent, kEventSingleThread };</div></div><!-- fragment --><ul>
<li>That means the processing mode is set for the entire service instance (i.e. all its provided methods are affected) and is fix for the whole lifetime of the skeleton instance. The default value in the ctor is set to kEvent.</li>
</ul>
<h4>2.3.3.1 Polling Mode</h4>
<ul>
<li>If you set it to kPoll, the Communication Management implementation will not call any of the provided service methods asynchronously! If you want to process the next (assume that there is a queue behind the scenes, where incoming service method calls are stored) pending service-call, you have to call the following method on your service instance:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">* This fetches the next call from the Communication Management and executes it.</span></div><div class="line"><span class="comment">* Only available in polling mode. In event mode it throws an exception.</span></div><div class="line"><span class="comment">*/</span></div><div class="line">ara::com::Future&lt;bool&gt; ProcessNextMethodCall();</div></div><!-- fragment --><ul>
<li>A simple use case for a typical RT application could be:<ul>
<li>RT application gets scheduled.</li>
<li>it calls ProcessNextMethodCall and registers a callback with ara::com::Future::then()</li>
<li>the callback is invoked after the service method called by the midleware corresponding to the outstanding request has finished.</li>
<li>in the callback the RT application decides, if there is enough time left for serving a subsequent service method. If so, it calls another ProcessNextMethodCall.</li>
</ul>
</li>
</ul>
<h4>2.3.3.2 Event-Driven Mode</h4>
<ul>
<li>If you set the processing mode to kEvent or kEventSingleThread, the Communication Management implementation will dispatch events asynchronously to the service method implementations at the time the service call from the service consumer comes in.<ul>
<li><b>kEvent:</b><ul>
<li>Communication Management implementation may call the service method implementations concurrently.</li>
<li>If at the same point in time one call to method Calibrate and two calls to method Adjust arrive from different service consumers, the Communication Management implementation is allowed to take three threads from its internal thread-pool and do those three calls for the two service methods concurrently.</li>
</ul>
</li>
<li><b>kEventSingleThread:</b><ul>
<li>kEventSingleThread assures, that on the service instance only one service method at a time will be called by the Communication Management implementation.</li>
<li>That means, Communication Management implementation has to queue incoming service method call events for the same service instance and dispatch them one after the other.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>2.3.4 Methods</h3>
<ul>
<li>Service methods on the skeleton side are abstract methods, which have to be overwritten by the service implementation sub-classing the skeleton.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">* For all output and non-void return parameters</span></div><div class="line"><span class="comment">* an enclosing struct is generated, which contains</span></div><div class="line"><span class="comment">* non-void return value and/or out parameters.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">struct </span>AdjustOutput {</div><div class="line"><span class="keywordtype">bool</span> success;</div><div class="line">Position effective_position;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> ara::com::Future&lt;AdjustOutput&gt; Adjust(</div><div class="line"><span class="keyword">const</span> Position&amp; position) = 0;</div></div><!-- fragment --><ul>
<li>The returned ara::com::Future contains a structure as template parameter, which aggregates all the OUT-parameters of the service call.</li>
</ul>
<h4>2.3.4.1 Raising Application Errors</h4>
<ul>
<li>Whenever on the implementation side of a service method, an ApplicationError according to the interface description is detected, the Checked Exception representing this ApplicationError simply has to be stored into the Promise, from which the Future is returned to the caller:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>ara::com;</div><div class="line"><span class="keyword">using namespace </span>com::mycompany::division::radarservice;</div><div class="line"></div><div class="line"><span class="comment">/* our implementation of RadarService */</span></div><div class="line"><span class="keyword">class </span>RadarServiceImpl : <span class="keyword">public</span> RadarServiceSkeleton {</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">Future&lt;CalibrateOutput&gt; Calibrate(<span class="keyword">const</span> std::string&amp; configuration)</div><div class="line">{</div><div class="line">Promise&lt;CalibrateOutput&gt; promise;</div><div class="line"><span class="keyword">auto</span> future = promise.get_future();</div><div class="line"></div><div class="line"><span class="comment">/* we check the given configuration arg */</span></div><div class="line"><span class="keywordflow">if</span> (!checkConfigString(configuration)) {</div><div class="line"><span class="comment">/* given arg is invalid: */</span></div><div class="line">InvalidConfigString myError(configuration, this-&gt;curValidConfig_));</div><div class="line">promise.set_exception(std::make_exception_ptr(myError));</div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* we return a future with a potentially set exception */</span></div><div class="line"><span class="keywordflow">return</span> future;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"><span class="keywordtype">bool</span> checkConfigString(<span class="keyword">const</span> std::string&amp; config);</div><div class="line">std::string curValidConfig_;</div><div class="line">}</div></div><!-- fragment --><ul>
<li>In this example, the implementation of ‘Calibrate’ detects, that the given configuration string argument is invalid and sets the corresponding exception to the Promise.</li>
</ul>
<h3>2.3.5 Events</h3>
<ul>
<li>On the skeleton side the service implementation is in charge of notifying about occurrence of an event.</li>
<li>The event wrapper class on the skeleton/event provider side looks obviously different than on the proxy/event consumer side.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>BrakeEvent {</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">* Shortcut for the events data type.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">using</span> SampleType = RadarObjects;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Send(<span class="keyword">const</span> SampleType &amp;data);</div><div class="line"></div><div class="line">ara::com::SampleAllocateePtr&lt;SampleType&gt; Allocate();</div><div class="line"> <span class="comment">/*</span></div><div class="line"><span class="comment"> * After sending data you loose ownership and can’t access</span></div><div class="line"><span class="comment"> * the data through the SampleAllocateePtr anymore.</span></div><div class="line"><span class="comment"> * Implementation of SampleAllocateePtr will be with the</span></div><div class="line"><span class="comment"> * semantics of std::unique_ptr (see types.h)</span></div><div class="line"><span class="comment"> **/</span></div><div class="line"> <span class="keywordtype">void</span> Send(ara::com::SampleAllocateePtr&lt;SampleType&gt; data);</div><div class="line"></div><div class="line"> };</div></div><!-- fragment --><ul>
<li>ara::com provides two different variants of a ‘Send’ method, which is used to send out new event data.</li>
</ul>
<ol type="1">
<li>The event data has been allocated somewhere by the service application developer and is given via reference to the binding implementation of Send(). After the call to send returns, the data might be removed/altered on the caller side. The binding implementation will make a copy in the call.</li>
<li>The second variant of ‘Send’ also has a parameter named ‘data’, but this is now of a different type ara::com::SampleAllocateePtr&lt;SampleType&gt;. ara::com introduced here, will behave like a std::unique_ptr&lt;T&gt;.Only one party can hold the pointer - if the owner wants to give it away, he has to explicitly do it via std::move.</li>
<li>ara::com::SampleAllocateePtr&lt;SampleType&gt; Allocate();<ul>
<li>The event wrapper class provides us here with a method to allocate memory for one sample of event data.</li>
<li>It returns a smart pointer ara::com::SampleAllocateePtr&lt;SampleType&gt;, which points to the allocated memory, where we then can write an event data sample to.</li>
</ul>
</li>
</ol>
<h3>2.3.6 Fields</h3>
<ul>
<li>On the skeleton side the service implementation is in charge of<ul>
<li>updating and notifying about changes of the value of a field.</li>
<li>serving incoming Get() calls.</li>
<li>serving incoming Set() calls.</li>
</ul>
</li>
<li>The field wrapper class on the skeleton/field provider side looks obviously different than on the proxy/field consumer side. <div class="image">
<img src="UpdateRateClass.png" alt="UpdateRateClass.png"/>
<div class="caption">
UpdateRate Class</div></div>
</li>
</ul>
<h4>2.3.6.1 Registering Getters</h4>
<ul>
<li>The RegisterGetHandler method provides the possibility to register a method implementation by the service implementer, which gets then called by the binding implementation on an incoming Get() call from any proxy instance.</li>
<li>The RegisterGetHandler method in the generated skeleton does only exist in case availability of “field getter” has been configured for the field in the configuration.</li>
</ul>
<h4>2.3.6.1 Registering Setters</h4>
<ul>
<li>RegisterSetHandler API has to be called by the service implementer in case field has been configured with setter support.</li>
</ul>
<h1>3 Service Discovery Implementation Strategies</h1>
<ul>
<li>As the service discovery functionality is basically defined at the API level with the methods for FindService, OfferService and StopOfferService.</li>
<li>When an AP node (more concretely an AP SWC) offers a service over the network or requires a service from another network node, then service discovery/service registry obviously takes place over the wire.</li>
<li>The protocol for service discovery over the wire needs to be completely specified by the used communication protocol.</li>
<li>if an ara::com application wants to communicate with another ara::com application on the same node within the AP of the same vendor there has to be a local variant of a service discovery available.</li>
</ul>
<h2>3.1 Central vs Distributed approach</h2>
<h3>3.1.1 Central approach</h3>
<ul>
<li>This approach have one central entity(a demon process), which:<ul>
<li>maintains a registry of all service instances together with their location information</li>
<li>serves all FindService, OfferService and StopOfferService requests from local ara::com applications, thereby either updating the registry (OfferService, StopOfferService) or querying the registry ( FindService)</li>
<li>serves all SOME/IP SD messages from the network either updating its registry (SOME/IP Offer Service received) or querying the registry (SOME/IP Find Service received) <div class="image">
<img src="Centralizeddiscoveryapproach.png" alt="Centralizeddiscoveryapproach.png"/>
<div class="caption">
Centralized discovery approach</div></div>
</li>
</ul>
</li>
</ul>
<h3>3.1.2 Distributed approach</h3>
<ul>
<li>This approach would be, to distribute the service registry information (availability and location information) among the ara::com applications within the node.So for the node local communication use case no prominent discovery demon would be needed. <div class="image">
<img src="Distributeddiscoveryapproach.png" alt="Distributeddiscoveryapproach.png"/>
<div class="caption">
Distributed discovery approach</div></div>
</li>
</ul>
<h2>3.2 Multi-Binding implications</h2>
<ul>
<li>Multi-Binding describes the solution to support setups, where the technical transport/connection between different instances of a certain proxy class/skeleton class are different.<ul>
<li>proxy class uses different transport/IPC to communicate with different skeleton instances. Reason: Different service instances support different transport mechanisms because of deployment decisions.</li>
<li>symmetrically it may also be the case, that different proxy instances for the same skeleton instance uses different transport/IPC to communicate with this instance: The skeleton instance supports multiple transport mechanisms to get contacted.</li>
</ul>
</li>
</ul>
<h3>3.2.1 Simple Multi-Binding use case</h3>
<ul>
<li>The following figure depicts an obvious and/or rather simple case. In this example, which only deals with node local (inside one AP product/ECU) communication between service consumers (proxy) and service providers (skeleton), there are two instances of the same proxy class on the service consumer side.</li>
<li>Service consumer application has triggered a ‘FindService’ first, which returned two handles for two different service instances of the searched service type.</li>
<li>The service consumer application has instantiated a proxy instance for each of those handles.</li>
<li>Now in this example the instance 1 of the service is located inside the same adaptive application (same process/address space) as the service consumer (proxy instance 1), while the service instance 2 is located in a different adaptive application (different process/ address space). <div class="image">
<img src="SimpleMultiBindingintraAPexample.png" alt="SimpleMultiBindingintraAPexample.png"/>
<div class="caption">
Simple MultiBinding intra example</div></div>
</li>
</ul>
<h3>3.2.2 Local/Network Multi-Binding use case</h3>
<ul>
<li>After we have seen a special variant of Multi-Binding in the preceding section, we now look at a variant, which can also be considered as being a real-world case.</li>
<li>The instance 2 of the service is located on a different ECU attached to the same Ethernet network as our ECU with the AP product, where the service consumer (with its proxies for instance 1 and 2) resides.</li>
<li>As the standard protocol on Ethernet for AP is SOME/IP, it is expected, that the communication between both ECUs is based on SOME/IP.</li>
<li>For our concrete example this means, that proxy 1 talks to service 1 via unix domain sockets (which might be optimized for process local communication to direct method calls), while the proxy 2 talks to service 2 via network sockets in a SOME/IP compliant message format. <div class="image">
<img src="Multi-Bindinglocalandnetworkexample.png" alt="Multi-Bindinglocalandnetworkexample.png"/>
<div class="caption">
Multi-Binding local and network example</div></div>
</li>
</ul>
<h3>3.2.3 Typical SOME/IP Multi-Binding use case</h3>
<ul>
<li>It is highly unlikely that an adaptive SWC (i.e. the language and network binding which runs in its context) opens socket connections itself to communicate with a remote service.</li>
<li>SOME/IP was explicitly designed to use as few ports as possible.</li>
<li>The reason for that requirement comes from low power/low resources embedded ECUs:</li>
<li>Managing a huge amount of IP sockets in parallel means huge costs in terms of memory (and runtime) resources.</li>
<li>AUTOSAR CP siblings which will be main communication partner in an inside vehicle network demand this approach, which is uncommon, compared to non-automotive IT usage pattern for ports.</li>
<li>The entire SOME/IP traffic of an ECU / network endpoint is routed through one IP port!</li>
<li>That means SOME/IP messages originating from/dispatched to many different local applications (service providers or service consumers) are (de)multiplexed to/from one socket connection.</li>
<li>POSIX compatible OS with POSIX socket API, multiplexing SOME/IP communication of many applications to/from one port means the introduction of a separate/central (demon) process, which manages the corresponding port.</li>
<li>The task of this process is to bridge between SOME/IP network communication and local communication and vice versa. <div class="image">
<img src="SOMEIPBridge.png" alt="SOMEIPBridge.png"/>
<div class="caption">
SOME/IP Bridge</div></div>
</li>
</ul>
<h1>4 ara::com and AUTOSAR meta-model relationship</h1>
<h2>4.1 Service Interface</h2>
<ul>
<li>Service Interface defines everything signaturewise of an ara::com proxy or skeleton.</li>
<li>The ServiceInterface describes the methods, fields and the methods a service interface consists of and how the signatures of those elements (arguments and data types) look like.</li>
<li>ara::com proxy and skeleton classes get generated from ServiceInterface.</li>
</ul>
<h2>4.2 Software Component</h2>
<ul>
<li>The idea of a software component is to describe a reusable part of software with well defined interfaces.</li>
<li>AUTOSAR manifest specification defines a model element SoftwareComponentType, which is an abstract element with several concrete subtypes, of which the subtype AdaptiveApplicationSwComponentType is the most important one for Adaptive Application software developers. <div class="image">
<img src="meta-modeltoImplementation.png" alt="meta-modeltoImplementation.png"/>
<div class="caption">
meta-model to Implementation</div></div>
</li>
<li>SoftwareComponentTypes A and B from the example in the upper part (meta-model level) a concrete implementation exists on implementation level (lower part in the figure).</li>
<li>The realization/implementation of R-Port of SoftwareComponentType A is based on an instance of ara::com proxy class on implementation level, while the P-Port implementation of SoftwareComponentType B is using an instance of ara::com skeleton class.</li>
<li>Proxy and skeleton class are generated from the service interface definition ServiceInterface, which is referenced by the corresponding ports.</li>
<li>Such a code fragment, which realizes a SoftwareComponentType can obviously be re-used. On C++ implementation level an implementation of an AdaptiveApplicationSwComponentType typically boils down to one or several C++ classes. So re-use simply means instantiating this class/those classes in different contexts multiple times. <div class="image">
<img src="MultipleInstantiation.png" alt="MultipleInstantiation.png"/>
<div class="caption">
Multiple Instantiation in Implementation Contexts</div></div>
</li>
<li>The figure above shows an arbitrary example, where the implementations of A and B are instantiated in different contexts. On the lower left side there is an Executable 1, which directly uses two instances of As impl and one instance of Bs impl.</li>
<li>Opposed to that, the right side shows an Executable 2, which "directly" (i.e. on its top most level) uses one instance of Bs impl and an instance of a composite software component, which itself "in its body" again instantiates one instance of As and Bs impl.</li>
<li>This natural implementation concept of composing software components from other components to a bigger/composite artefact is fully reflected in the AUTOSAR meta-model in the form of a CompositionSwComponentType, which itself is a SoftwareComponentType and allows arbitrary recursive nesting/compositing of software components.</li>
</ul>
<h2>4.3 Adaptive Application/Executables and Processes</h2>
<ul>
<li>Deployable software units within AP are so called Adaptive Applications (the corresponding meta-model element is AdaptiveAutosarApplication).</li>
<li>Such an Adaptive Application consists of 1..n executeables. <div class="image">
<img src="InstantiationoAddaptiveApplicationsinDeployment.png" alt="InstantiationoAddaptiveApplicationsinDeployment.png"/>
<div class="caption">
Instantiation of Addaptive Applications in Deployment</div></div>
</li>
<li>Abstract identifiers relate in a certain way to the corresponding port in the model of the SoftwareComponentType.</li>
<li>Instance IDs obviously have to be assigned to objects, which finally have a distinct identity in an deployment. <div class="image">
<img src="Executable.png" alt="Executable.png"/>
<div class="caption">
Example of the possible structure of an Executable</div></div>
</li>
</ul>
<h2>4.4 Usage of meta-model identifiers within ara::com based application code</h2>
<ul>
<li>The abstract identifiers relate in a certain way to the corresponding port in the model of the SoftwareComponentType.</li>
<li>Port name of the model alone isn’t sufficient to clearly identify it in its final instantiation, where the same component implementation might be instantiated multiple times in the code and then eventually started multiple times in different processes.</li>
<li>Instance IDs obviously have to be assigned to objects, which finally have a distinct identity in an deployment. <div class="image">
<img src="InstanceIdsDeployment.png" alt="InstanceIdsDeployment.png"/>
<div class="caption">
InstanceIds in Deployment</div></div>
</li>
<li>The figure above shows, within Executable 2 there are three instantiations of SoftwareComponentType B implementation in different contexts (nesting levels).All instances do provide a specific instance of SI RadarService.</li>
<li>The integrator, who applies the Service Instance Manifest for Process 2 has to do the technical mapping on ara::com level. I.e. he has to decide, which technical transport binding is to be used in each of the B instantiations and subsequently also, which technical transport binding specific instance ID.</li>
<li>In our example, the integrator wants to provide the SI RadarService via SOME/IP binding and an SOME/IP specific instance ID "1" in the context of the B instantiation, which is nested inside the composite component on the right side, while he decides to provide the SI RadarService via local IPC (Unix domain socket) binding and a Unix domain socket specific instance ID "/tmp/Radar/3" and "/tmp/Radar/4" in the context of the B instantiations on the left side, which are not nested.</li>
<li>Within the Service Instance Manifest, which allows to specify the mapping of port instantiations within a Process to technical bindings and their concrete instance IDs, the sole usage of the port name from the model isn’t sufficient to differentiate.</li>
<li>To get unique identifiers within an executable (and therefore a process), the nature of nested instantiation and re-use of SoftwareComponentTypes has to be considered. Every time a SoftwareComponentType gets instantiated, its instantiation gets a unique name within its instantiation context.</li>
<li>In our example this means:<ul>
<li>B instantiations on top level get unique names on their level: "B_Inst_1" and "B_Inst_2"</li>
<li>B instantiation within the Composite Component Type gets unique name on this level: "B_Inst_1"</li>
<li>Composite Component instantiation on top level gets unique name on its level: "Comp_Inst_1"</li>
<li>From the perspective of the executable/process, we therefore have unique identifiers for all instances of B:<ul>
<li>"B_Inst_1"</li>
<li>"B_Inst_2"</li>
<li>"Comp_Inst_1::B_Inst_1"</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>5. Serialization</h1>
<ul>
<li>Serialization is the process of transforming certain data structures into a standardized format for exchange between a sender and a (possibly different) receiver.</li>
<li>When putting data on the wire and reading it back, receiver have to follow exact, agreed-on rules to be able to correctly interpret the data on the receiver side.</li>
<li>For Adaptive Platform, the loading of executables during runtime, which have been built independently at different times and have been uploaded to an AP ECU at different times, is definitely a supported use case. The chance, that compiler settings for different ara::com applications were different regarding alignment decisions is consequently high. Therefore an AP product (more concrete its IPC binding implementation) has to use/support serialization of exchanged event/field/method data.</li>
</ul>
<h2>5.1 Zero-Copy implications</h2>
<ul>
<li>One thing which typically is at the top of the list of performance optimizations in IPC/middleware implementations is the avoidance of unnecessary copies between sender and the receiver of data.</li>
<li>When we talk about AP, where we have architectural expectations like applications running in separate processes providing memory protection, the typical communication approach needs at least ONE copy of the data from source address space to target address space.</li>
<li>Highly optimizing middleware/IPC implementations could even get rid of this single copy step by setting up shared memory regions between communicating ara::com components(sender and receiver). </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<style>
  .column {
    float: left;
    width: 50%;
    text-align:right
  } 
  .column1 {
    float: right;
    width: 50%;
    text-align:center;
  }
  .row:after {
    content: "";
    display: table;
    clear: both;
  }
  .row{
    background-color: #f4f0ff;
  }
</style>
<div class="row">
  <div class="column">AVIN Systems Private Limited</div>
  <div class="column1">Version 1.0.1</div>
</div>
