<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Adaptive Platform Demonstrator: Execution Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Platform Demonstrator
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('execution_management.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Execution Management </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Execution Management is the functional cluster within the Adaptive Platform Foundation that is responsible for platform initialization and the startup and shutdown of Applications. It performs these tasks using information contained within one or more Manifest files such as when and how Executables should be started. The Execution Management functional cluster is part of the Adaptive Platform.</p>
<p>Execution Management, in common with other Applications is assumed to be a process executed on a POSIX compliant operating system. Execution Management is responsible for initiating execution of the processes in all the Functional Clusters, Adaptive AUTOSAR Services, and Adaptive Applications. The launching order is derived by Execution Management to ensure proper startup of the Adaptive Platform.</p>
<p>For an example, The Adaptive AUTOSAR Services are provided via mechanisms provided by the Communication Management functional cluster of the Adaptive Platform Foundation. In order to use the Adaptive AUTOSAR Services, the functional clusters in the Foundation must be properly initialized beforehand.</p>
<p>Execution Management is responsible for all aspects of process lifecycle management, including:</p>
<ul>
<li><b>Machine startup and shutdown</b> – Execution Management is the initial (“boot”) process of the operating system.</li>
<li><b>Required process hierarchy of started services, e.g., init and its child process.</b> – The boot process in this case corresponds to machine init process.</li>
<li><b>Provision of process isolation with each instance of an Executable managed as a single process.</b></li>
<li><b>Startup and shutdown of Applications.</b> – Loading Executable based on a defined Execution Dependency. – Specific requirements until starting an Executable main function (i.e. entry point)<ul>
<li>Ensure that startup and shutdown dependencies between Executable instances are respected, if an execution dependency is specified in the Application Manifest of an Executable instance. If no execution dependency is specified between Executable instances, they can be started and stopped in an arbitrary order.</li>
</ul>
</li>
<li><b>Privileges and use of access control</b> – Description and semantics of access control in manifest files<ul>
<li>Allocate OS resource budgets for Executable and/or groups of Executables</li>
<li>Authentication and authorization of Executables at startup of Executable</li>
</ul>
</li>
<li><b>State management</b> – Conditions for the execution of Applications</li>
</ul>
<h1>2. <b>Technical aspect of execution manager</b></h1>
<h2>2.1 <b>Application</b></h2>
<ul>
<li>Applications are developed to resolve a set of coherent functional requirements.</li>
<li>An Application consists of executable software units, additional execution related items (e.g. data or parameter files), and descriptive information used for integration and execution (e.g. a formal model description based on the AUTOSAR meta model, test cases).</li>
<li>Applications can be located on user level above the middleware or can be implementation of functional clusters of the Adaptive Platform.</li>
<li>Applications might use all mechanisms and APIs provided by the operating system and other functional clusters of the Adaptive Platform, which in general restricts portability to other Adaptive Platforms.</li>
<li>All Applications, including Adaptive Applications, are treated the same by Execution Management.</li>
</ul>
<h2>2.2 <b>Adaptive Application</b></h2>
<ul>
<li>An Adaptive Application is a specific type of Application that fully complies with the AUTOSAR specification, i.e. it is restricted to use APIs standardized by AUTOSAR and needs to follow specific coding guidelines to allow reallocation between different Adaptive Platforms.</li>
<li>Adaptive Applications are always located above the middleware. To allow portability and reuse, user level Applications should be Adaptive Applications whenever technically possible.</li>
<li>An Adaptive Application is the result of functional development and is the unit of delivery for Machine specific configuration and integration.</li>
<li>Some contracts and Service Interfaces to interact with other Adaptive Applications need to be agreed on beforehand.</li>
</ul>
<h2>2.3 <b>Executable</b></h2>
<ul>
<li>An Executable is a software unit which is part of an Application. It has exactly one entry point (main function). An Application can be implemented in one or more Executables.</li>
<li>Executables which belong to the same Adaptive Application might need to be deployed to different Machines, e.g. to one high performance Machine and one high safety Machine.</li>
</ul>
<table class="doxtable">
<tr>
<th>Process Step </th><th>Software </th><th>Meta Information  </th></tr>
<tr>
<td>Development and Integration </td><td>Linked, configured and calibrated binary for deployment onto the target Machine. The binary might contain code which was generated at integration time. </td><td>Application Manifest and Service Instance Manifest (not used by Execution Management) </td></tr>
<tr>
<td>Deployment and Removal </td><td>Binary installed on the target Machine. </td><td>Processed Manifests, stored in a platform-specific format which is efficiently readable at Machine startup. </td></tr>
<tr>
<td>Execution </td><td>Process started as instance of the binary. </td><td>The Execution Management uses contents of the Processed Manifests to start up and configure each process individually. </td></tr>
</table>
<div class="image">
<img src="Executable_lifecycle.png" alt="Executable_lifecycle.png"/>
<div class="caption">
Executable lifecycle</div></div>
<h2>2.4 <b>Process</b></h2>
<ul>
<li>A Process is a forked instance of an Executable. <blockquote class="doxtable">
<p><b>Note: In the initial release it is assumed, that processes are self contained, i.e. that they take care of controlling thread creation and scheduling by calling APIs from within the code.</b> </p>
</blockquote>
</li>
<li>Execution Management only starts and terminates the processes and while the processes are running, Execution Management only interacts with the processes by using State Management mechanisms.</li>
</ul>
<h2>2.5 <b>Application Manifest</b></h2>
<ul>
<li>The Application Manifest consists of parts of the Application design information which is provided by the application developer in an application description, and additional machine-specific information which is added at integration time.</li>
<li>An Application Manifest is created together with a Service Instance Manifest (not used by Execution Management) at integration time and deployed onto a Machine together with the Executable it is attached to.</li>
<li>It describes in a standardized way the machine-specific configuration of Process properties (startup parameters, resource group assignment, priorities etc.).</li>
<li>Each instance of an Executable binary, i.e. each started process, is individually configurable, with the option to use a different configuration set per Machine state or per Function Group State.</li>
</ul>
<h2>2.6 <b>Machine Manifest</b></h2>
<ul>
<li>The Machine Manifest holds all configuration information which cannot be assigned to a specific Executable, i.e. which is not already covered by an Application Manifest or a Service Instance Manifest.</li>
<li>The Machine Manifest is also created at integration time for a specific Machine and is deployed like Application Manifests whenever its contents change.</li>
<li>The contents of a Machine Manifest includes the configuration of Machine properties and features (resources, safety, security, etc.), e.g. configured Machine States and Function Group States, resource groups, access right groups, scheduler configuration, SOME/IP configuration, memory segmentation.</li>
</ul>
<h2>2.7 <b>Manifest format</b></h2>
<ul>
<li>The Application Manifests and the Machine Manifest can be transformed into a platform-specific format (called Processed Manifest), which is efficiently readable at Machine startup.</li>
<li>The format transformation can be done either off board at integration time or at deployment time, or on the Machine (by Update and Configuration management) at installation time.</li>
</ul>
<h2>2.8 <b>Execution Management Responsibilities</b></h2>
<ul>
<li>Execution Management is responsible for all aspects of Process execution management. A Process is a loaded instance of an Executable, which is part of an Application.</li>
<li>Execution Management is started as part of the Adaptive Platform startup phase and is responsible for starting and terminating Processes.</li>
<li>Execution Management determines when, and possibly in which order, to start or stop Processes, i.e. instances of the deployed Executables, based on information in the Machine Manifest and Application Manifests.</li>
<li>Execution Management will be solely responsible for initiating execution of Processes.</li>
<li>Depending on the Machine State or on a Function Group State, deployed Executables are started during Adaptive Platform startup or later.</li>
<li>Execution Management is not responsible for run-time scheduling of Processes since this is the responsibility of the Operating System.</li>
<li><b>Application Lifecycle Management:</b><ul>
<li>The Execution Management is responsible for the ordered startup and shutdown of the deployed Applications.</li>
<li>The Execution Management determines when, and possibly in which order, to start or stop the deployed Applications, based on information in the Machine Manifest and Application Manifests.</li>
<li>Depending on the Machine State or on a Function Group State, deployed Applications are started during Adaptive Platform startup or later, however, it is not expected that all will begin active work immediately since many Applications will provide services to other Applications and therefore wait and “listen” for incoming service requests.</li>
<li>The Execution Management derives an ordering for startup/shutdown within the State Management framework, based on declared Application dependencies. The dependencies are described in the Application Manifests.</li>
</ul>
</li>
<li>The Execution Management is not responsible for run-time scheduling of Applications since this is the responsibility of the Operating System. However the Execution Management is responsible for initialization configuration of the OS to enable it to perform the necessary run-time scheduling based on information extracted by the Execution Management from the Machine Manifest and Application Manifests.</li>
</ul>
<h3>2.8.1 <b>Process Lifecycle Management</b></h3>
<ul>
<li><b>Process States:</b> From the execution stand point, Process States characterize the lifecycle of any Process. <blockquote class="doxtable">
<p><b>Note that each process is independent and therefore has its own Process State.</b> </p>
</blockquote>
<ul>
<li><b>Idle Process State:</b> The Idle Process State will be the Process state prior to creation of the process and resource allocation.</li>
<li><b>Starting Process State:</b> The Starting Process State will apply when the process has been created and resources have been allocated.</li>
<li><b>Running Process State:</b> The Running Process State will apply to a process after it has been scheduled and it has reported Running State to the Execution Manager.</li>
<li><b>Terminating Process State:</b><ul>
<li>The Terminating Process State will apply either after an process has received the termination indication from the Execution Manager or after it has decided to self-terminate and informed the Execution Manager.</li>
<li>The Terminating and Running Process State indications from Application to Execution Management use the ReportApplicationState API. On entering the kTerminatingProcess State, the Process is expected to save persistent data, free all used Process internal resources and exit.</li>
</ul>
</li>
<li><b>Terminated Process State:</b><ul>
<li>The Terminated Process State will apply after the process has been terminated and the process resources have been freed. For that, Execution Manager will observe the exit status of all processes, with the POSIX waitpid() command.</li>
<li>From the resource allocation stand point, Terminated state is similar to the Idle state as there is no process running and no resources are allocated anymore.</li>
<li>From the execution stand point, Terminated state is different from the Idle state since it tells that the process has already been executed and terminated.</li>
<li>This is relevant for one shot Processes which are supposed to run and terminate on their own as once they have reached their Terminated Process State they are to return to the Idle Process State without any external trigger.</li>
</ul>
</li>
<li><b>One-shot Process State:</b><ul>
<li>After a one-shot Process has terminated, Execution Management shall immediately set its Process State to Idle. <div class="image">
<img src="Process_lifecycle.png" alt="Process_lifecycle.png"/>
<div class="caption">
Process lifecycle</div></div>
</li>
</ul>
</li>
</ul>
</li>
<li><b>Startup and Shutdown:</b><ul>
<li><em>Ordering:</em><ul>
<li>The Execution Manager can derive an ordering for the startup and shutdown of Processes within the State Management framework based on the declared Execution Dependencies.</li>
<li>An Execution Dependency defines the provider of service(s) required by a Process before that Process can provide its own services. Hence Execution Management ensures the dependent Processes are in the state defined by the Execution Dependency before the Process with the dependency is started.</li>
<li>Execution Dependencies are described in the Application Manifest.</li>
<li>During startup, Execution Management shall respect Execution Dependencies by ensuring that any Processes upon which the Process to be started depends have reached the requested state before starting the Process.</li>
<li>The same Execution Dependencies used to define the startup order are also used to define the shutdown order. However the situation is reversed as Execution Management must ensure that dependent processes are shutdown after the process to ensure that the services required remain available until no longer required.</li>
<li>During shutdown, Execution Management will respect Execution Dependencies by ensuring that any Processes upon which the Process to be shutdown depends are not terminated before shutting down the Process.</li>
</ul>
</li>
<li><em>Arguments :</em><ul>
<li>Execution Manager provides argument passing for a Process contain is gone or more ModeDependentStartupConfig in the role Process.modeDepen-dentStartupConfig. This permits different Processes to be started with different arguments.</li>
<li>At the initiation of startup of a Process, the aggregated StartupOptions of the StartupConfig referenced by the ModeDependentStartupConfig will be passed to the call of the exec-family based POSIX interface to start the Process by the Operating System.</li>
<li>The first argument on the command-line passed by Execution Management is the name of the Executable.</li>
</ul>
</li>
</ul>
</li>
<li><b>Startup Sequence:</b><ul>
<li>When the Machine is started, the OS will be initialized first and then Execution Manager is launched as one of the OS’s initial Processes. Other functional clusters and platform-level Applications of the Adaptive Platform Foundation are then launched by Execution Management. After the Adaptive Platform Foundation is up and running, Execution Management continues to launch userlevel Applications.</li>
<li>The startup order of the platform-level Processes is determined by the Execution Management, based on Machine Manifest and Application Manifest information. <div class="image">
<img src="startup.png" alt="startup.png"/>
<div class="caption">
Startup sequence</div></div>
</li>
</ul>
</li>
<li><b>Execution Dependency:</b><ul>
<li>The Execution Management provides support to the Adaptive Platform for ordered startup and shutdown of Applications.</li>
<li>This ensures that Applications are started before dependent Applications use the services that they provide and, likewise, that Process are shutdown only when their provided services are no longer required.</li>
<li>The Execution dependencies, are configured in the Application Manifests, which is created at integration time based on information provided by the Application developer.</li>
<li>User-level applications use service discovery mechanisms of the Communication Management and should not depend on startup dependencies. Which Executable instances are running depends on the current Machine State and on the current Function Group States. The integrator must ensure that all service dependencies are mapped to State Management configuration, i.e. that all dependent Executable instances are running when needed.</li>
<li>In real life, specifying a simple dependency to an Process might not be sufficient to ensure that the depending service is actually provided. Since some Process will reach a certain Application State to be able to offer their services to other Process, the dependency information will also refer to Process State of the Process specified as dependency. With that in mind, the dependency information may be represented as a pair like: "&lt;Process&gt;.&lt;ApplicationState&gt;".</li>
<li>The following dependency use-cases have been identified:<ul>
<li>In case Process B has a simple dependency on Process A, the Running Application State of Process A is specified in the dependency section of Process B’s Application Manifest.</li>
<li>In case Process B depends on One-Shot Process A, the Terminated Application State of Process A is specified in the dependency section of Process B’s Application Manifest.</li>
</ul>
</li>
<li>Processes are only started by the Execution Manager if they reference a requested Machine State or Function Group State, but not because of configured Execution Dependencies.</li>
<li>Execution Dependencies are only used to control a startup or terminate sequence at state transitions or at machine startup/shutdown.</li>
</ul>
</li>
</ul>
<h2>2.9 <b>State Management</b></h2>
<ul>
<li>State Management provides a mechanism to define the state of the operation for an Adaptive Platform. The Application Manifest allows definition in which states the Process instances have to run . State Management grants full control over the set of Applications to be executed and ensures that Process are only executed (and hence resources allocated) when actually needed.</li>
<li>Four different states are relevant for Execution Management:<ul>
<li>Application State</li>
<li>Process State<ul>
<li>Process States are managed by an Execution Management internal state machine.</li>
</ul>
</li>
<li>Machine State</li>
<li>Functional group state.</li>
</ul>
</li>
</ul>
<h3>2.9.1 <b>Application State:</b></h3>
<div class="image">
<img src="application_state.png" alt="application_state.png"/>
<div class="caption">
Application states</div></div>
<ul>
<li>The Application State characterizes the internal lifecycle of any instance of an Process. The states are defined by the ApplicationState enumeration.</li>
<li><b>Application State Running:</b><ul>
<li>Execution Management shall consider Process initialization complete when the state kRunning is reported. <blockquote class="doxtable">
<p><b>Please note that Service Discovery can introduce non-deterministic delays and thus is advised to be done after reporting kRunning state thus the Process may not have completed all its initialization when the kRunningstate is reported.</b> </p>
</blockquote>
</li>
</ul>
</li>
<li><b>Initiation of Process termination:</b><ul>
<li>Execution Management shall initiate termination by sending the SIGTERM signal to a Process.</li>
<li>Note that from the perspective of Execution Management, requirement only requests the initiation of the steps necessary for termination.</li>
<li>On receipt of SIGTERM, a Process acknowledges the request (by reporting the new state to Execution Management using the Application-Client:ReportApplicationStateinterface) and then commences the actual termination.</li>
</ul>
</li>
<li><b>Acknowledgement of termination request:</b><ul>
<li>On reception of SIGTERM, the Process will acknowledge the state change request by reporting kTerminating to Execution Management.</li>
</ul>
</li>
<li><b>Initiation of Process self-termination:</b><ul>
<li>A Process will initiate self-termination by reporting the kTerminating state to Execution Management.</li>
<li>During the Terminating state, the Process is expected to free internally used resources. The Process indicates completion of the Terminating state by simply exiting (with an appropriate exit code). Execution Management as the parent process can detect termination of the child process and take the appropriate platform-specific actions.</li>
</ul>
</li>
</ul>
<h3>2.9.2 <b>Machine State</b></h3>
<ul>
<li>Requesting and reaching a Machine State is, besides using Function Group States, one way to define the current set of running Process. It is significantly influenced by vehicle-wide events and modes.</li>
<li>Each Application can declare in its Application Manifest in which Machine States it has to be running.</li>
<li>There are several mandatory machine states specified in this document that have to be present on each machine.</li>
<li>Additional Machine States can be defined on a machine specific basis and are therefore not standardized.</li>
<li>Machine States:<ul>
<li>A ModeDeclaration for each required Machine State has to be defined in the Machine Manifest.</li>
<li>The Execution Manager will obtain the Machine States from the Machine Manifest.</li>
<li>The API specification will use the shortName for identification of the Machine State.</li>
<li>The Machine States are determined and requested by the State Manager.</li>
</ul>
</li>
<li>Following are the default Machine state:</li>
<li><b>Startup</b> <div class="image">
<img src="startip_sequence.png" alt="startip_sequence.png"/>
<div class="caption">
Startup Sequence</div></div>
<ul>
<li>The Startup Machine State will be the first state to be active after the startup of Execution Manager. Therefore, a ModeDeclaration for the Startup has to be defined in the Machine Manifest.</li>
<li>The following behavior apply for the Startup Machine State:<ul>
<li>All Processes of platform-level Applications configured for Startup will be started.</li>
<li>Process configured for Startup are based on the reference from the Process to the ModeDependentStartupConfig in the role Process.modeDependentStartupConfig with the instanceRef to the ModeDeclaration in the role ModeDependentStartupConfig.machineMode that belongs to the Startup Machine State.</li>
<li>The Execution Manager will wait for all started Process until their Application State Running is reported.</li>
<li>If that is the case, the Execution Manager will notify the State Manager that the Startup Machine State is ready to be changed.</li>
<li>The Execution Manager will not change the Machine State by itself until a new state is requested by the State Manager.</li>
</ul>
</li>
</ul>
</li>
<li><b>Shutdown</b><ul>
<li>The Shutdown Machine State will be active after the Shutdown Machine State is requested by the State Manager. Therefore, a ModeDeclaration for the Shutdown has to be defined in the Machine Manifest.</li>
<li>The following behavior apply for the Shutdown Machine State:<ul>
<li>All Processes, including the platform-level Applications, that have a Process State different than Idle or Terminated will be shutdown.</li>
<li>When Process State of all Process is Idle or Terminated, all Process configured for Shutdown will be started.</li>
<li>Process configured for Shutdown are based on the reference from the Processes to the ModeDependentStartupConfig in the role Process.modeDe-pendentStartupConfig with the instanceRef to the ModeDeclaration in the role ModeDependentStartupConfig.machineMode that belongs to the Shutdown Machine State.</li>
</ul>
</li>
<li>Shutdown of the Operating System:<ul>
<li>There will be at least one Process consisting of at least one Process that has a ModeDependentStartupConfig in the role Process.modeDependentStartupConfig with the instanceRef to the ModeDeclaration in the role ModeDependentStartupConfig.machineMode that belongs to the Shutdown Machine State.</li>
<li>This Application will contain the actual mechanism(s) to initiate shutdown of the Operating System.</li>
</ul>
</li>
</ul>
</li>
<li><b>Restart</b><ul>
<li>The Restart Machine State will be active after the Restart Machine State is requested by the State Manager. Therefore, a ModeDeclaration for the Restart has to be defined in the Machine Manifest.</li>
<li>The following behavior applies for the Restart Machine State:<ul>
<li>All Process, including the platform-level Applications, that have a Process State different than Idle or Terminated will be shutdown.</li>
<li>When Process State of all Process is Idle or Terminated, all Process configured for Restart will be started.</li>
<li>Process configured for Restart are based on the reference from the Process to the ModeDependentStartupConfig in the role Process.modeDependentStartupConfig with the instanceRef to the ModeDeclaration in the role ModeDependentStartupConfig.machineMode that belongs to the Restart Machine State.</li>
</ul>
</li>
<li>Restart of the Operating System:<ul>
<li>There will be at least one Application consisting of at least one Process that has a ModeDependentStartupConfig in the role Process.modeDependentStartupConfig with the instanceRef to the ModeDeclaration in the role ModeDependentStartupConfig.machineMode that belongs to the Restart Machine State.</li>
<li>This Application will contain the actual mechanism(s) to initiate restart of the Operating System.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>2.10 <b>State Management Architecture</b></h2>
<ul>
<li>State Management is the functional cluster which is responsible for determining the current set of active Machine State and Function Group States, and for initiating State transitions by requesting them from Execution Management.</li>
<li>Execution Management performs the State transitions and controls the actual set of running Processes, depending on the current States.</li>
<li>State Management is the central point where new Machine States and Function Group States can be requested and where the requests are arbitrated, including coordination of contradicting requests from different sources. Additional data and events might need to be considered for arbitration.</li>
<li>The State change requests can be issued by:<ul>
<li>Platform Health Management to trigger error recovery, e.g. to activate fallback functionality</li>
<li>Diagnostics, to switch the system into diagnostic states.</li>
<li>Update and Configuration Management to switch the system into states where software or configuration can be updated.</li>
<li>Network Management to coordinate required functionality and network state.</li>
<li>authorized applications, e.g. a vehicle state manager which might be located in a different machine or on a different ECU State Change requests can be issued by other.</li>
</ul>
</li>
<li>Since State Management functionality is critical, access from other Functional Clusters or Process must be secured, e.g. by IAM (Identity and Access Management).</li>
<li>State Management is monitored and supervised by Platform Health Management.</li>
<li>State Management provides interfaces to request information about current states.</li>
</ul>
<h3>2.10.1 <b>State Interaction</b></h3>
<div class="image">
<img src="interaction_between_states.png" alt="interaction_between_states.png"/>
<div class="caption">
State Interaction</div></div>
<ul>
<li>One can see the state transitions of a Function Group and the Process and Application States of one Process which references one state of this Function Group, ignoring possible delays and dependencies if several Processes were involved.</li>
<li>The interaction is identical if the Process references a Machine State instead of a Function Group State.</li>
</ul>
<h3>2.10.2 <b>State Change</b></h3>
<div class="image">
<img src="state_transition.png" alt="state_transition.png"/>
<div class="caption">
State Change</div></div>
<ul>
<li>State Management can request to change one or several Function Group States and/or the Machine State from Execution Management by passing pairs of "Function Group" "requested State" as parameters, with Machine State being treated like any Function Group State.</li>
<li>A state change request by State Management will lead to immediate state transitions and hereof a state change to the requested Machine State and/or Function Group States.</li>
<li>State Management can request multiple Machine State and Function Group State changes sequentially by issuing several individual state change requests, or atomically within the same state change request, which leads to multiple coherent state changes.</li>
<li>However, the following restriction applies to avoid undefined behaviour while the state transitions are performed by Execution Management:</li>
<li><b>Deny State Change Request:</b><ul>
<li>Execution Management will deny state change requests, that are received before all previously requested Machine State and/or Function Group State transitions are completed. If a request is denied, Execution Management will return an error code to the requester of the state transition.</li>
</ul>
</li>
<li><b>State Transition Timeout:</b><ul>
<li>If a timeout is detected when stopping or starting Processes at a state transition, Execution Management will return an error code to the requester of the state changes.</li>
<li>This implies that the state change request blocks until the state transitions are completed or until an error is detected.</li>
</ul>
</li>
<li><b>State Change Failed:</b><ul>
<li>Execution Management will return an error code to the requester of the state changes when other or unspecified errors occur at a state transition.</li>
</ul>
</li>
<li><b>State Change Successful:</b><ul>
<li>When Execution Management succeeds with the requested state transitions, a success code will be returned to the requester of the state changes.</li>
</ul>
</li>
</ul>
<h2>2.11 <b>Deterministic Execution</b></h2>
<h3>2.11.1 <b>Determinism</b></h3>
<ul>
<li>In real-time systems, deterministic execution often means, that a calculation of a given set of input data always produces a consistent output within a bounded time, i.e. the behavior is reproducible.</li>
<li>In the context of Execution Management, the term “calculation” can apply to execution of a thread, a Process, or a group of Processes. The calculation can be event-driven or cyclic; i.e. time-driven.</li>
<li>There are multiple elements in determinism and here we distinguish them as follows:<ul>
<li><b>Time Determinism:</b> The output of the calculation is always produced before a given deadline (a point in time).</li>
<li><b>Data Determinism:</b> Given the same input and internal state, the calculation always produces the same output.</li>
<li><b>Full Determinism:</b> Combination of Time and Data Determinism as defined above.</li>
</ul>
</li>
<li>Deterministic behavior is important for safety-critical systems, which may not be allowed to deviate from the specified behavior at all.</li>
<li>Whether Time Determinism, or in addition Data Determinism is necessary to provide the required functionality depends on the system and on the safety goals.</li>
<li>Expected use cases of the Adaptive Platform where such determinism is required include:<ul>
<li>Software Lockstep: To execute ASIL C/D with high computing performance demands, specific measures, such as software lockstep are required, due to high transient hardware error rates of high performance microprocessors. Software lockstep is a technique where the calculation is done redundantly through two different execution paths and the results are compared. To make the redundant calculations comparable, software lockstep requires a fully deterministic calculation.</li>
<li>Reuse of verified software: The deterministic subsystem shows the same behavior on different platforms which satisfy the performance and resource needs of the subsystem, regardless of other differences in each environment, such as existence of unrelated applications. Examples include the different development and simulation platforms. Due to reproducible functional behavior, many results of testing, configuration and calibration of the subsystem are valid in each environment where the subsystem is deployed on and don’t need to be repeated.</li>
</ul>
</li>
</ul>
<h3>2.11.1.1 <b>Time Determinism</b></h3>
<ul>
<li>Each time a calculation is started, its results are guaranteed to be available before a specified deadline. To achieve this, sufficient and guaranteed computing resources (processor time, memory, service response times etc.) must be assigned to the software entities that perform the calculation.</li>
<li>Non-deterministic “best-effort” Processes can request guaranteed minimum resources for basic functionality, and additionally can have maximum resources specified for monitoring. However, if Time Determinism is requested, the resources must be guaranteed at any time, i.e. minimum and maximum resources are identical.</li>
<li>If the assumptions for deterministic execution are violated, e.g. due to a deadline miss, this must be treated as an error and recovery actions must be initiated. In nondeterministic “best-effort” subsystems such deadline violations or other deviations from normal behavior sometimes can be tolerated and mitigated without dedicated error management.</li>
<li>Fully-Deterministic behavior additionally requires Data Determinism, however in many cases Time Determinism is sufficient.</li>
</ul>
<h3>2.11.1.2 <b>Data Determinism</b></h3>
<ul>
<li>For Data Determinism, each time a calculation is started, its results only depend on the input data. For a specific sequence of input data, the results always need to be exactly the same, assuming the same initial internal state.</li>
<li>A common approach to verify Data Determinism in a safety context is the use of lockstep mechanisms, where execution is done simultaneously through two different paths and the result is compared to verify consistency. Hardware lockstep means that the hardware has specific equipment to make this double-/multi-execution transparent. Software lockstep is another technique that allows providing a similar property without requiring the use of dedicated hardware.</li>
<li>Depending on the Safety Level, as well as the Safety Concept employed, software lockstep may involve executing multiple times the same software, in parallel or sequentially, but may also involve running multiple separate implementations of the same algorithm.</li>
</ul>
<h3>2.11.1.3 <b>Full Determinism</b></h3>
<ul>
<li>For Full Determinism, each time a calculation is started, its results are available before a specified deadline and only depend on the input data, i.e. both Time and Data Determinism must be guaranteed.</li>
<li>Currently, only Full Deterministic behavior of one Process is specified. Determinism of a cluster of Processes on one or even several machines needs extensions of the Communication Management, which have not been specified yet.</li>
<li>Non-deterministic behavior may arise from different reasons; for example insufficient computing resources, uncoordinated access of data, potentially by multiple threads running on multiple processor cores. The order in which the threads access such data will affect the result, which makes it non-deterministic (“race condition”).</li>
<li>A fully deterministic calculation must be designed, implemented and integrated in a way such that it is independent of processor load, sporadic unrelated events, race conditions, etc.</li>
</ul>
<h2>2.11.2 <b>Redundant Deterministic Execution</b></h2>
<ul>
<li>Future systems need high computing performance in combination with high ASIL safety goals.</li>
<li>Here are some additional rationales behind it:<ul>
<li>Safety goals for Highly Automated Driving (HAD) systems can be up to ASIL D.</li>
<li>High Performance Computing (HPC) demands can only be met by non automotive-grade, e.g. consumer electronics (CE), microprocessors, which have high transient hardware error rates compared to automotive-grade microcontrollers. Most likely no such microprocessor is available for ASIL above B, at least for the parts relevant to the design.</li>
<li>To deal with high error rates, ASIL C/D HAD applications require specific measures, in particular software lockstep, where execution is done redundantly through two different paths and the result is compared to detect errors.</li>
<li>To make these redundant calculations comparable, software lockstep requires a fully deterministic calculation which must be designed, implemented and integrated in a way such that it is independent of processor load caused by other functions and calculations, sporadic unrelated events, race conditions, deviating random numbers etc, i.e. for the same input and initial conditions it always produces the same result within a given time.</li>
<li>To meet HPC demands, highly predictable and reliable multi-threading must be supported.</li>
</ul>
</li>
<li>Two redundant Processes, which run in an internal cycle, get in each cycle the same input data via regular interfaces of the Communication Management and produce (in the absence of errors) the same results, due to full deterministic execution.</li>
</ul>
<h2>2.12 <b>Resource limitation</b></h2>
<ul>
<li>Despite the correct behavior of a particular Adaptive Application in the system, it is important to ensure any potentially incorrect behavior, as well as any unforeseen interactions cannot cause interference in unrelated parts of the system.</li>
<li>it is important to consider that Execution Management is only responsible for the correct configuration of the Machine. However, enforcing the associated restrictions is usually done by either the Operating System or another Application like the Persistency service.</li>
</ul>
<h3>2.12.1 <b>Resource configuration</b></h3>
<ul>
<li>This section provides an overview on resource assignment to Processes, resources like:<ul>
<li>RAM (e.g. for code, data, thread stacks, heap)</li>
<li>CPU time</li>
</ul>
</li>
<li>In general, we need to distinguish between two resource demand values:<ul>
<li>Minimum resources, which need to be guaranteed so the process can reach its Running state and perform its basic functionality.</li>
<li>Maximum resources, which might be temporarily needed and will not be exceeded at any time, otherwise it will throw an error.</li>
</ul>
</li>
<li>Execution Management will configure the maximum amount of RAM available globally for all Processes belonging to each ResourceGroup when defined in the configuration, before loading a Process from this ResourceGroup. If a ResourceGroup does not have a configured RAM limit, then the Processes are only bound by their implicit memory limit.</li>
<li>Execution Management will configure the maximum amount of CPU time available globally for all Processes belonging to each ResourceGroup when defined in the configuration, before loading a Process from this ResourceGroup. If ResourceGroup does not have a configured CPU usage limit, then the Processes are only bound by their implicit CPU usage limit (priority, scheduling scheme...).</li>
</ul>
<h3>2.12.2 <b>Resource Monitoring</b></h3>
<ul>
<li>The resources which are actually used by a Process should be controlled at any given time.</li>
<li>For the entire system, the monitoring part of this activity is fulfilled by the Operating System.</li>
<li>Depending on system requirements and safety goals, an appropriate Operating System has to be chosen and configured accordingly, in combination with other monitoring mechanisms (e.g. for execution deadlines) which are provided by Platform Health Management.</li>
<li>Resource monitoring can serve several purposes, e.g.<ul>
<li>Detection of misbehavior of the monitored Process to initiate appropriate recovery actions, like Process restart or state change, to maintain the provided functionality and guarantee functional safety.</li>
<li>Protection of other parts of the system by isolating the erroneous Processes from unaffected ones to avoid resource shortage.</li>
</ul>
</li>
<li>For Processes which are attempting to exceed their configured maximum resource needs, one of the following alternatives:<ul>
<li>The resource limit violation or deadline miss is considered a failure and recovery actions may need to be initiated. Therefore the specific violation gets reported to the Platform Health Management, which then starts recovery actions which have been configured beforehand. This will be the standard option for deterministic subsystems.</li>
<li>For Processes without hard deadlines, resource violations sometimes can be mitigated without dedicated error recovery actions, e.g. by interrupting execution and continue at a later point in time.</li>
<li>If the OS provides a way to limit resource consumption of a Process or a group of Processes by design, explicit external monitoring is usually not necessary and often not even possible. Instead, the limitation mechanisms make sure that resource availability for other parts of the system is not affected by failures within the enclosed Processes. When such by-design limitation is used, monitoring mechanisms may still be used for the benefit of the platform, but are not required. Self-monitoring and out-of-process monitoring is currently out-of-scope in Adaptive Platform.</li>
</ul>
</li>
</ul>
<h3>2.12.3 <b>Application-level Resource configuration</b></h3>
<h3>2.12.3.1 <b>CPU Usage</b></h3>
<ul>
<li>CPU usage is represented in a Process by its threads. Generally speaking, Operating Systems use some properties of each thread’s configuration to determine when to run it, and additionally constrain a group of threads to not use more than a defined amount of CPU time. Because threads may be created at runtime, only the first thread can be configured by Execution Management.</li>
</ul>
<h3>2.12.3.2 <b>Core Affinity</b></h3>
<ul>
<li>Execution Management will configure the Core affinity of the Process initial thread restricting it to a sub-set of cores in the system.</li>
<li>Depending on the capabilities of the Operating System the sub-set could be a single core.</li>
<li>If the Operating System does not support binding to specific cores then the only supported sub-set is the entire set of cores.</li>
</ul>
<h3>2.12.3.3 <b>Scheduling Policy</b></h3>
<ul>
<li>Currently available POSIX-compliant Operating Systems offer the scheduling policies required by POSIX, and in most cases additional, but different and incompatible scheduling strategies. This means for now, the required scheduling properties need to be configured individually, depending on the chosen OS.</li>
<li>Moreover, scheduling strategy is defined per thread and the POSIX standard allows for modifying the scheduling policy at runtime for a given thread, using pthread_setschedparam(). It is therefore not currently possible for the Adaptive Platform to enforce a particular scheduling strategy for an entire Process, but only for its first thread.</li>
<li>While scheduling policies are not a sufficient method to guarantee Full Determinism, they contribute to improve it. While the aim is to limit CPU time for a Process, scheduling policies apply to threads. <blockquote class="doxtable">
<p><b>Note that while Execution Management will ensure the proper configuration for the first thread (that calls the main() function), it is the responsibility of the Process itself to properly configure secondary threads.</b> </p>
</blockquote>
</li>
</ul>
<h3>2.12.3.4 <b>Resource Management</b></h3>
<ul>
<li>In general, for deterministic behavior the required computing time is guaranteed and violations are treated as error, while best-effort subsystems are more robust and might be able to mitigate sporadic violations, e.g. by continuing the calculation at the next activation, or by providing a result of lesser quality. This means, if time (e.g. deadline or runtime budget) monitoring is in place, the reaction on deviations is different for deterministic and best-effort subsystems.</li>
<li>In fact, it may not even be necessary to monitor best-effort subsystems, since they by definition are doing only a function that may not succeed. This leads to an architecture where monitoring is a voluntary, configured property.</li>
<li>The remaining critical property however is to guarantee that a particular process or set of Processes cannot adversely affect the behavior of other Processes.</li>
<li>To guarantee Full Determinism for the entire system, it is important to ensure Freedom from Interference, which the ResourceGroup contribute to ensure.</li>
<li>Execution Management will configure the Process according to its ResourceGroup membership.</li>
</ul>
<h3>2.12.3.5 <b>Memory Budget and Monitoring</b></h3>
<ul>
<li>To render a function, a Process requires the availability of some amount of memory for its usage (mainly code, data, heap, thread stacks). Over the course of its execution however, not all of this memory is required at all times, such that an OS can take advantage of this property to make these ranges of memory available on-demand, and provide them to other Processes when the memory is no longer used.</li>
<li>While this has clear advantages in terms of system flexibility as well as memory efficiency, it is also in the way of both Time Determinism and Full Determinism: when a range of memory that was previously unused must now be made available, the OS may have to execute some amounts of potentially-unbounded activities to make this memory available. Often, the reverse may also be happening, removing previously available (but unused) memory from the Process under scope, to make it available to other Processes. This is detrimental to an overall system determinism.</li>
<li>Execution Management will ensure that the entire memory range that deterministic Processes may be using is available at the start and for the whole duration of the respective Process execution.</li>
<li>In order to provide sufficient memory at the beginning of the execution of a Process, some properties may need to be defined for each Process.</li>
<li><b>Maximum heap:</b><ul>
<li>Execution Management will configure the Maximum heap usage for the Process.</li>
<li>Heap memory is used for dynamic memory allocation inside a Process e.g. through malloc()/free() and new/delete.</li>
</ul>
</li>
<li><b>Maximum system memory usage:</b><ul>
<li>Execution Management will configure the Maximum system memory usage of the Process.</li>
<li>System memory can be used to create extra resources like file handles or semaphores, as well as creating new threads.</li>
</ul>
</li>
<li><b>Process pre-mapping:</b><ul>
<li>Execution Management will premap a Process if required by the corresponding Application Manifest.</li>
<li>Fully pre-mapping a Process ensures that code and data execution is not going to be delayed at its first execution by demand-loading. This helps providing Time Determinism during system startup and first execution phases, but also helps with safety where code handling error cases can be preloaded and made guaranteed to be available. In addition, pre-mapping avoids late issues where filesystem may be corrupted and part of the Process may not be loadable anymore. </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<style>
  .column {
    float: left;
    width: 50%;
    text-align:right
  } 
  .column1 {
    float: right;
    width: 50%;
    text-align:center;
  }
  .row:after {
    content: "";
    display: table;
    clear: both;
  }
  .row{
    background-color: #f4f0ff;
  }
</style>
<div class="row">
  <div class="column">AVIN Systems Private Limited</div>
  <div class="column1">Version 1.0.1</div>
</div>
