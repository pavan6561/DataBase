<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptive Platform Demonstrator: Introduction to Yocto</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Platform Demonstrator
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('yocto_introduction.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction to Yocto </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Yocto Project is an open source collaboration project that helps developers create custom Linux-based systems for embedded products,regardless of the hardware architecture. The project provides a flexible set of tools and a space where embedded developers worldwide can share technologies,software stacks, configurations and best practices which can be used to create tailored Linux images for embedded devices. The project provides a standard to delivering hardware support and software stacks, allowing the interchange of software configurations and builds. The tools allow users to build and support customizations for multiple hardware platforms and software stacks in a maintainable and scalable way.</p>
<p>The Yocto Project combines, maintains and validates three (3) key development elements.</p><ul>
<li>A set of integrated tools to make working with embedded Linux successful, including tools for automated building and testing, processes for board support and license compliance, and component information for custom Linux-based embedded operating systems</li>
<li>A reference embedded distribution (called Poky)</li>
<li>The OpenEmbedded build system, co-maintained with the OpenEmbedded Project</li>
</ul>
<h2>Yocto Project Terms</h2>
<p>Following is a list of terms and definitions users new to the Yocto Project development environment might find helpful. While some of these terms are universal, the list includes them just in case:</p>
<ul>
<li><b>Append Files:</b> Files that append build information to a recipe file. Append files are known as BitBake append files and .bbappend files. The OpenEmbedded build system expects every append file to have a corresponding recipe (.bb) file. Furthermore, the append file and corresponding recipe file must use the same root filename. The filenames can differ only in the file type suffix used (e.g. formfactor_0.0.bb and formfactor_0.0.bbappend). Information in append files extends or overrides the information in the similarly-named recipe file. For an example of an append file in use. Note Append files can also use wildcard patterns in their version numbers so they can be applied to more than one version of the underlying recipe file.</li>
<li><p class="startli"><b>BitBake:</b> The task executor and scheduler used by the OpenEmbedded build system to build images.</p>
<p class="startli">BitBake is the tool at the heart of the OpenEmbedded build system and is responsible for parsing the Metadata, generating a list of tasks from it, and then executing those tasks. This section briefly introduces BitBake. If you want more information on BitBake, see the BitBake User Manual. To see a list of the options BitBake supports, use either of the following commands: </p><pre class="fragment">&gt;       $ bitbake -h\n
&gt;       $ bitbake --help
</pre><p class="startli">The most common usage for BitBake is bitbake packagename, where packagename is the name of the package you want to build (referred to as the "target" in this manual). The target often equates to the first part of a recipe's filename (e.g. "foo" for a recipe named foo_1.3.0-r0.bb). So, to process the matchbox-desktop_1.2.3.bb recipe file, you might type the following: &gt; $ bitbake matchbox-desktop</p>
<p class="startli">Several different versions of matchbox-desktop might exist. BitBake chooses the one selected by the distribution configuration. You can get more details about how BitBake chooses between different target versions and providers in the "Preferences" section of the BitBake User Manual. BitBake also tries to execute any dependent tasks first. So for example, before building matchbox-desktop, BitBake would build a cross compiler and glibc if they had not already been built. A useful BitBake option to consider is the -k or &ndash;continue option. This option instructs BitBake to try and continue processing the job as long as possible even after encountering an error. When an error occurs, the target that failed and those that depend on it cannot be remade. However, when you use this option other dependencies can still be processed.</p>
</li>
<li><b>Board Support Package (BSP):</b> A group of drivers, definitions, and other components that provide support for a specific hardware configuration.</li>
<li><p class="startli"><b>Build Directory:</b> This term refers to the area used by the OpenEmbedded build system for builds. The area is created when you source the setup environment script that is found in the Source Directory (i.e. oe-init-build-env). The TOPDIR variable points to the Build Directory. You have a lot of flexibility when creating the Build Directory. Following are some examples that show how to create the directory. The examples assume your Source Directory is named poky: Create the Build Directory inside your Source Directory and let the name of the Build Directory default to build: </p><pre class="fragment">&gt;     $ cd $HOME/poky
&gt;     $ source oe-init-build-env
</pre><p class="startli">Create the Build Directory inside your home directory and specifically name it test-builds: </p><pre class="fragment">&gt;    $ cd $HOME
&gt;    $ source poky/oe-init-build-env test-builds
</pre><p class="startli">Provide a directory path and specifically name the Build Directory. Any intermediate folders in the pathname must exist. This next example creates a Build Directory named YP-19.0.2 in your home directory within the existing directory mybuilds: </p><pre class="fragment">&gt;   $cd $HOME
&gt;   $ source $HOME/poky/oe-init-build-env $HOME/mybuilds/YP-19.0.2


&gt;   Note
&gt;   By default, the Build Directory contains TMPDIR, which is a temporary directory the build system uses for its work. TMPDIR cannot be under NFS. 
&gt;   Thus, by default, the Build Directory cannot be under NFS. However, if you need the Build Directory to be under NFS, you can set this up by setting TMPDIR in your local.conf file to use a local drive. 
&gt;   Doing so effectively separates TMPDIR from TOPDIR, which is the Build Directory. 
</pre></li>
<li><b>Build System:</b> The system used to build images in a Yocto Project Development environment. The build system is sometimes referred to as the development host.</li>
<li><b>Cross-Development Toolchain:</b> In general, a cross-development toolchain is a collection of software development tools and utilities that run on one architecture and allow you to develop software for a different, or targeted, architecture. These toolchains contain cross-compilers, linkers, and debuggers that are specific to the target architecture. The Yocto Project supports two different cross-development toolchains: A toolchain only used by and within BitBake when building an image for a target architecture. A relocatable toolchain used outside of BitBake by developers when developing applications that will run on a targeted device. Creation of these toolchains is simple and automated. For information on toolchain concepts as they apply to the Yocto Project. You can also find more information on using the relocatable toolchain in the Yocto Project Application Development and the Extensible Software Development Kit (eSDK) manual.</li>
<li><b>Image:</b> An image is an artifact of the BitBake build process given a collection of recipes and related Metadata. Images are the binary output that run on specific hardware or QEMU and are used for specific use-cases. For a list of the supported image types that the Yocto Project provides.</li>
<li><b>Layer:</b> A collection of recipes representing the core, a BSP, or an application stack. For a discussion specifically on BSP Layers.</li>
<li><b>Metadata:</b> The files that BitBake parses when building an image. In general, Metadata includes recipes, classes, and configuration files.<ul>
<li><em>Recipe:</em> A set of instructions for building packages. A recipe describes where you get source code, which patches to apply, how to configure the source, how to compile it and so on. Recipes also describe dependencies for libraries or for other recipes. Recipes represent the logical unit of execution, the software to build, the images to build, and use the .bb file extension. Files that have the .bb suffix are "recipes" files. In general, a recipe contains information about a single piece of software. This information includes the location from which to download the unaltered source, any source patches to be applied to that source (if needed), which special configuration options to apply, how to compile the source files, and how to package the compiled output. The term "package" is sometimes used to refer to recipes. However, the word "package" is used for the packaged output from the OpenEmbedded build system (i.e. .ipk or .deb files).</li>
<li><em>Classes:</em> Class files (.bbclass) contain information that is useful to share between Metadata files. It provides logic encapsulation and inheritance so that commonly used patterns can be defined once and then easily used in multiple recipes. An example is the autotools class, which contains common settings for any application that Autotools uses.</li>
<li><em>Configuration:</em> The configuration files (.conf) define various configuration variables that govern the OpenEmbedded build process. These files fall into several areas that define machine configuration options, distribution configuration options, compiler tuning options, general common configuration options, and user configuration options in local.conf, which is found in the Build Directory. Configuration information in various .conf files provides global definitions of variables. The conf/local.conf configuration file in the Build Directory contains user-defined variables that affect every build. The meta-poky/conf/distro/poky.conf configuration file defines Yocto "distro" configuration variables used only when building with this policy. Machine configuration files, which are located throughout the Source Directory, define variables for specific hardware and are only used when building for that target (e.g. the machine/beaglebone.conf configuration file defines variables for the Texas Instruments ARM Cortex-A8 development board). Configuration files end with a .conf filename extension.</li>
</ul>
</li>
<li><b>OE-Core:</b> A core set of Metadata originating with OpenEmbedded (OE) that is shared between OE and the Yocto Project. This Metadata is found in the meta directory of the Source Directory.</li>
<li><b>OpenEmbedded Build System:</b> The build system specific to the Yocto Project. The OpenEmbedded build system is based on another project known as "Poky", which uses BitBake as the task executor. Throughout the Yocto Project documentation set, the OpenEmbedded build system is sometimes referred to simply as "the build system". If other build systems, such as a host or target build system are referenced, the documentation clearly states the difference.</li>
<li><b>Package:</b> In the context of the Yocto Project, this term refers to a recipe's packaged output produced by BitBake (i.e. a "baked recipe"). A package is generally the compiled binaries produced from the recipe's sources. You "bake" something by running it through BitBake. It is worth noting that the term "package" can, in general, have subtle meanings. For example, the packages referred to in the "The Build Host Packages" section in the Yocto Project Quick Start are compiled binaries that, when installed, add functionality to your Linux distribution. Another point worth noting is that historically within the Yocto Project, recipes were referred to as packages - thus, the existence of several BitBake variables that are seemingly mis-named, (e.g. PR, PV, and PE).</li>
<li><b>Package Groups:</b> Arbitrary groups of software Recipes. You use package groups to hold recipes that, when built, usually accomplish a single task. For example, a package group could contain the recipes for a company’s proprietary or value-add software. Or, the package group could contain the recipes that enable graphics. A package group is really just another recipe. Because package group files are recipes, they end with the .bb filename extension.</li>
<li><b>Poky:</b> The term "poky", which is pronounced Pah-kee, can mean several things: In its most general sense, poky is an open-source project that was initially developed by OpenedHand. OpenedHand developed poky off of the existing OpenEmbedded build system to create a commercially supportable build system for embedded Linux. After Intel Corporation acquired OpenedHand, the poky project became the basis for the Yocto Project's build system. Within the Yocto Project Source Repositories, "poky" exists as a separate Git repository from which you can clone to yield a local Git repository that is a copy on your host system. Thus, "poky" can refer to the upstream or local copy of the files used for development within the Yocto Project. Finally, "poky" can refer to the default DISTRO (i.e. distribution) created when you use the Yocto Project in conjunction with the poky repository to build an image.</li>
<li><b>Reference Kit:</b> A working example of a system, which includes a BSP as well as a build system and other components, that can work on specific hardware.</li>
<li><p class="startli"><b>Source Directory:</b> This term refers to the directory structure created as a result of creating a local copy of the poky Git repository git://git.yoctoproject.org/poky or expanding a released poky tarball. </p><pre class="fragment">&gt;   Note
&gt;   Creating a local copy of the poky Git repository is the recommended method for setting up your Source Directory. 
</pre><p class="startli">Sometimes you might hear the term "poky directory" used to refer to this directory structure. </p><pre class="fragment">&gt;   Note
&gt;   The OpenEmbedded build system does not support file or directory names that contain spaces. Be sure that the Source Directory you use does not contain these types of names. 
</pre><p class="startli">The Source Directory contains BitBake, Documentation, Metadata and other files that all support the Yocto Project. Consequently, you must have the Source Directory in place on your development system in order to do any development using the Yocto Project. When you create a local copy of the Git repository, you can name the repository anything you like. Throughout much of the documentation, "poky" is used as the name of the top-level folder of the local copy of the poky Git repository. So, for example, cloning the poky Git repository results in a local Git repository whose top-level folder is also named "poky". While it is not recommended that you use tarball expansion to set up the Source Directory, if you do, the top-level directory name of the Source Directory is derived from the Yocto Project release tarball. For example, downloading and unpacking poky-rocko-19.0.2.tar.bz2 results in a Source Directory whose root folder is named poky-rocko-19.0.2. It is important to understand the differences between the Source Directory created by unpacking a released tarball as compared to cloning git://git.yoctoproject.org/poky. When you unpack a tarball, you have an exact copy of the files based on the time of release - a fixed release point. Any changes you make to your local files in the Source Directory are on top of the release and will remain local only. On the other hand, when you clone the poky Git repository, you have an active development repository with access to the upstream repository's branches and tags. In this case, any local changes you make to the local Source Directory can be later applied to active development branches of the upstream poky Git repository.</p>
</li>
<li><b>Task:</b> A unit of execution for BitBake (e.g. do_compile, do_fetch, do_patch, and so forth).</li>
</ul>
<h2>Development concept</h2>
<p>The following diagram represents development at a high level. The remainder of this chapter expands on the fundamental input, output, process, and Metadata) blocks that make up development in the Yocto Project environment. </p><div class="image">
<img src="yocto-environment.png" alt="yocto-environment.png"/>
<div class="caption">
Yocto Develpement processes</div></div>
<p>In general, development consists of several functional areas:</p><ul>
<li><b>User Configuration:</b> Metadata you can use to control the build process.</li>
<li><b>Metadata Layers:</b> Various layers that provide software, machine, and distro Metadata.</li>
<li><b>Source Files:</b> Upstream releases, local projects, and SCMs.</li>
<li><b>Build System:</b> Processes under the control of BitBake. This block expands on how BitBake fetches source, applies patches, completes compilation, analyzes output for package generation, creates and tests packages, generates images, and generates cross-development tools.</li>
<li><b>Package Feeds:</b> Directories containing output packages (RPM, DEB or IPK), which are subsequently used in the construction of an image or SDK, produced by the build system. These feeds can also be copied and shared using a web server or other means to facilitate extending or updating existing images on devices at runtime if runtime package management is enabled.</li>
<li><b>Images:</b> Images produced by the development process.</li>
<li><b>Application Development SDK:</b> Cross-development tools that are produced along with an image or separately with BitBake.</li>
</ul>
<h2>Build process</h2>
<p>The OpenEmbedded build system uses BitBake to produce images. You can see from the general Yocto Project Development Environment figure, the BitBake area consists of several functional areas. which are divided into task as follows:</p>
<ul>
<li><b>Source Fetching</b> The first stages of building a recipe are to fetch and unpack the source code: <div class="image">
<img src="source_fetching.PNG" alt="source_fetching.PNG"/>
<div class="caption">
Source Fetching</div></div>
 The <em>do_fetch</em> and <em>do_unpack</em> tasks fetch the source files and unpack them into the work directory. By default, everything is accomplished in the Build Directory, which has a defined structure Unpacked source files are pointed to by the S variable. Each recipe has an area in the Build Directory where the unpacked source code resides. The name of that directory for any given recipe is defined from several different variables. You can see the variables that define these directories by looking at the figure:<ul>
<li><em>TMPDIR</em> - The base directory where the OpenEmbedded build system performs all its work during the build.</li>
<li><em>PACKAGE_ARCH</em> - The architecture of the built package or packages.</li>
<li><em>PN</em> - The name of the built package.</li>
<li><em>PV</em> - The version of the recipe used to build the package.</li>
<li><em>PR</em> - The revision of the recipe used to build the package.</li>
<li><em>WORKDIR</em> - The location within TMPDIR where a specific package is built.</li>
<li><em>S</em> - Contains the unpacked source files for a given recipe.</li>
</ul>
</li>
<li><b>Patching</b> Once source code is fetched and unpacked, BitBake locates patch files and applies them to the source files <div class="image">
<img src="Patching.png" alt="Patching.png"/>
<div class="caption">
Patching</div></div>
 The <em>do_patch</em> task processes recipes by using the <em>SRC_URI</em> variable to locate applicable patch files, which by default are *.patch or *.diff files, or any file if "apply=yes" is specified for the file in SRC_URI. BitBake finds and applies multiple patches for a single recipe in the order in which it finds the patches. Patches are applied to the recipe's source files located in the S directory.</li>
<li><b>Configuration and Compilation</b> After source code is patched, BitBake executes tasks that configure and compile the source code: <div class="image">
<img src="compilation.png" alt="compilation.png"/>
<div class="caption">
Compilation</div></div>
 This step in the build process consists of three tasks:<ul>
<li><em>do_prepare_recipe_sysroot:</em> This task sets up the two sysroots in ${WORKDIR} (i.e. recipe-sysroot and recipe-sysroot-native) so that the sysroots contain the contents of the do_populate_sysroot tasks of the recipes on which the recipe containing the tasks depends. A sysroot exists for both the target and for the native binaries, which run on the host system.</li>
<li><em>do_configure:</em> This task configures the source by enabling and disabling any build-time and configuration options for the software being built. Configurations can come from the recipe itself as well as from an inherited class. Additionally, the software itself might configure itself depending on the target for which it is being built. The configurations handled by the do_configure task are specific to source code configuration for the source code being built by the recipe. If you are using the autotools class, you can add additional configuration options by using the EXTRA_OECONF or PACKAGECONFIG_CONFARGS variables. For information on how this variable works within that class, see the meta/classes/autotools.bbclass file.</li>
<li><em>do_compile:</em> Once a configuration task has been satisfied, BitBake compiles the source using the do_compile task. Compilation occurs in the directory pointed to by the B variable. Realize that the B directory is, by default, the same as the S directory.</li>
<li><em>do_install:</em> Once compilation is done, BitBake executes the <em>do_install</em> task. This task copies files from the B directory and places them in a holding area pointed to by the D variable.</li>
</ul>
</li>
<li><p class="startli"><b>Package Splitting</b> <br />
 After source code is configured and compiled, the OpenEmbedded build system analyzes the results and splits the output into packages: </p><div class="image">
<img src="package_splitting.png" alt="package_splitting.png"/>
<div class="caption">
Package Splitting</div></div>
<p> The do_package and do_packagedata tasks combine to analyze the files found in the D directory and split them into subsets based on available packages and files. The analyzing process involves the following as well as other items: splitting out debugging symbols, looking at shared library dependencies between packages, and looking at package relationships. The do_packagedata task creates package metadata based on the analysis such that the OpenEmbedded build system can generate the final packages. Working, staged, and intermediate results of the analysis and package splitting process use these areas:</p><ul>
<li><em>PKGD</em> - The destination directory for packages before they are split.</li>
<li><em>PKGDATA_DIR</em> - A shared, global-state directory that holds data generated during the packaging process.</li>
<li><em>PKGDESTWORK</em> - A temporary work area used by the do_package task.</li>
<li><em>PKGDEST</em> - The parent directory for packages after they have been split.</li>
</ul>
<p class="startli">The FILES variable defines the files that go into each package in PACKAGES. If you want details on how this is accomplished, you can look at the package class. Depending on the type of packages being created (RPM, DEB, or IPK), the <em>do_package_write_</em> task creates the actual packages and places them in the Package Feed area, which is ${TMPDIR}/deploy. You can see the "Package Feeds" section for more detail on that part of the build process.</p>
</li>
<li><p class="startli"><b>Image Generation</b> Once packages are split and stored in the Package Feeds area, the OpenEmbedded build system uses BitBake to generate the root filesystem image: </p><div class="image">
<img src="image_generation.png" alt="image_generation.png"/>
<div class="caption">
Package Splitting</div></div>
<p> The image generation process consists of several stages and depends on several tasks and variables. The do_rootfs task creates the root filesystem (file and directory structure) for an image. This task uses several key variables to help create the list of packages to actually install:</p><ul>
<li><em>IMAGE_INSTALL:</em> Lists out the base set of packages to install from the Package Feeds area.</li>
<li><em>PACKAGE_EXCLUDE:</em> Specifies packages that should not be installed.</li>
<li><em>IMAGE_FEATURES:</em> Specifies features to include in the image. Most of these features map to additional packages for installation.</li>
<li><em>PACKAGE_CLASSES:</em> Specifies the package backend to use and consequently helps determine where to locate packages within the Package Feeds area.</li>
<li><em>IMAGE_LINGUAS:</em> Determines the language(s) for which additional language support packages are installed.</li>
<li><em>PACKAGE_INSTALL:</em> The final list of packages passed to the package manager for installation into the image.</li>
</ul>
<p class="startli">With IMAGE_ROOTFS pointing to the location of the filesystem under construction and the <em>PACKAGE_INSTALL</em> variable providing the final list of packages to install, the root file system is created. Package installation is under control of the package manager (e.g. dnf/rpm, opkg, or apt/dpkg) regardless of whether or not package management is enabled for the target. At the end of the process, if package management is not enabled for the target, the package manager's data files are deleted from the root filesystem. As part of the final stage of package installation, postinstall scripts that are part of the packages are run. Any scripts that fail to run on the build host are run on the target when the target system is first booted. If you are using a read-only root filesystem, all the post installation scripts must succeed during the package installation phase since the root filesystem is read-only. The final stages of the do_rootfs task handle post processing. Post processing includes creation of a manifest file and optimizations. The manifest file (.manifest) resides in the same directory as the root filesystem image. This file lists out, line-by-line, the installed packages. The manifest file is useful for the testimage class, for example, to determine whether or not to run specific tests. See the <em>IMAGE_MANIFEST</em> variable for additional information.</p>
<p class="startli">Optimizing processes run across the image include mklibs, prelink, and any other post-processing commands as defined by the ROOTFS_POSTPROCESS_COMMAND variable. The mklibs process optimizes the size of the libraries, while the prelink process optimizes the dynamic linking of shared libraries to reduce start up time of executables. After the root filesystem is built, processing begins on the image through the do_image task. The build system runs any pre-processing commands as defined by the IMAGE_PREPROCESS_COMMAND variable. This variable specifies a list of functions to call before the OpenEmbedded build system creates the final image output files. The OpenEmbedded build system dynamically creates do_image_* tasks as needed, based on the image types specified in the IMAGE_FSTYPES variable. The process turns everything into an image file or a set of image files and compresses the root filesystem image to reduce the overall size of the image. The formats used for the root filesystem depend on the IMAGE_FSTYPES variable. As an example, a dynamically created task when creating a particular image type would take the following form: </p><pre class="fragment"> do_image_type[depends]
</pre><p class="startli">So, if the type as specified by the IMAGE_FSTYPES were ext4, the dynamically generated task would be as follows: </p><pre class="fragment"> do_image_ext4[depends]
</pre><p class="startli">The final task involved in image creation is the do_image_complete task. This task completes the image by applying any image post processing as defined through the IMAGE_POSTPROCESS_COMMAND variable. The variable specifies a list of functions to call once the OpenEmbedded build system has created the final image output files. <br />
</p>
</li>
<li><b>Image</b> The images produced by the OpenEmbedded build system are compressed forms of the root filesystem that are ready to boot on a target device. You can see from the general Yocto Project Development Environment figure that BitBake output, in part, consists of images. <div class="image">
<img src="Image.png" alt="Image.png"/>
<div class="caption">
Package Splitting</div></div>
 For a list of example images that the Yocto Project provides, see the "Images" chapter. Images are written out to the Build Directory inside the tmp/deploy/images/machine/ folder as shown in the figure. This folder contains any files expected to be loaded on the target device. The DEPLOY_DIR variable points to the deploy directory, while the DEPLOY_DIR_IMAGE variable points to the appropriate directory containing images for the current configuration.<ul>
<li><em>kernel-image:</em> A kernel binary file. The KERNEL_IMAGETYPE variable setting determines the naming scheme for the kernel image file. Depending on that variable, the file could begin with a variety of naming strings. The deploy/images/machine directory can contain multiple image files for the machine.</li>
<li><em>root-filesystem-image:</em> Root filesystems for the target device (e.g. *.ext3 or *.bz2 files). The IMAGE_FSTYPES variable setting determines the root filesystem image type. The deploy/images/machine directory can contain multiple root filesystems for the machine.</li>
<li><em>kernel-modules:</em> Tarballs that contain all the modules built for the kernel. Kernel module tarballs exist for legacy purposes and can be suppressed by setting the MODULE_TARBALL_DEPLOY variable to "0". The deploy/images/machine directory can contain multiple kernel module tarballs for the machine.</li>
<li><em>bootloaders:</em> Bootloaders supporting the image, if applicable to the target machine. The deploy/images/machine directory can contain multiple bootloaders for the machine.</li>
<li><em>symlinks:</em> The deploy/images/machine folder contains a symbolic link that points to the most recently built file for each machine. These links might be useful for external scripts that need to obtain the latest version of each file.</li>
</ul>
</li>
</ul>
<h2>How does Bitbake build system use metadata to build an image?</h2>
<p>The primary purpose for running BitBake is to produce some kind of output such as a single installable package, a kernel, a software development kit, or even a full, board-specific bootable Linux image, complete with bootloader, kernel, and root filesystem. Of course, you can execute the bitbake command with options that cause it to execute single tasks, compile single recipe files, capture or clear data, or simply return information about the execution environment. The execution process is launched using the following command form: </p><pre class="fragment">    $ bitbake target
</pre><ul>
<li><p class="startli"><b>Parsing the Base Configuration Metadata</b> The first thing BitBake does is parse base configuration metadata. Base configuration metadata consists of your project's bblayers.conf file to determine what layers BitBake needs to recognize, all necessary layer.conf files (one from each layer), and bitbake.conf. The data itself is of various types:</p><ul>
<li><em>Recipes:</em> Details about particular pieces of software.</li>
<li><em>Class Data:</em> An abstraction of common build information (e.g. how to build a Linux kernel).</li>
<li><em>Configuration Data:</em> Machine-specific settings, policy decisions, and so forth. Configuration data acts as the glue to bind everything together.</li>
</ul>
<p class="startli">The layer.conf files are used to construct key variables such as BBPATH and BBFILES. BBPATH is used to search for configuration and class files under the conf and classes directories, respectively. BBFILES is used to locate both recipe and recipe append files (.bb and .bbappend). If there is no bblayers.conf file, it is assumed the user has set the BBPATH and BBFILES directly in the environment.</p>
<p class="startli">The base configuration metadata is global and therefore affects all recipes and tasks that are executed. BitBake first searches the current working directory for an optional conf/bblayers.conf configuration file. This file is expected to contain a BBLAYERS variable that is a space-delimited list of 'layer' directories. Recall that if BitBake cannot find a bblayers.conf file, then it is assumed the user has set the BBPATH and BBFILES variables directly in the environment.</p>
<p class="startli">For each directory (layer) in this list, a conf/layer.conf file is located and parsed with the LAYERDIR variable being set to the directory where the layer was found. The idea is these files automatically set up BBPATH and other variables correctly for a given build directory.</p>
<p class="startli">BitBake then expects to find the conf/bitbake.conf file somewhere in the user-specified BBPATH. That configuration file generally has include directives to pull in any other metadata such as files specific to the architecture, the machine, the local environment, and so forth.</p>
<p class="startli">Only variable definitions and include directives are allowed in BitBake .conf files. Some variables directly influence BitBake's behavior. These variables might have been set from the environment depending on the environment variables previously mentioned or set in the configuration files. The "Variables Glossary" chapter presents a full list of variables.</p>
<p class="startli">After parsing configuration files, BitBake uses its rudimentary inheritance mechanism, which is through class files, to inherit some standard classes. BitBake parses a class when the inherit directive responsible for getting that class is encountered.</p>
<p class="startli">The base.bbclass file is always included. Other classes that are specified in the configuration using the INHERIT variable are also included. BitBake searches for class files in a classes subdirectory under the paths in BBPATH in the same way as configuration files.</p>
</li>
<li><b>Locating and Parsing Recipes</b> During the configuration phase, BitBake will have set BBFILES. BitBake now uses it to construct a list of recipes to parse, along with any append files (.bbappend) to apply. BBFILES is a space-separated list of available files and supports wildcards. An example would be:</li>
</ul>
<blockquote class="doxtable">
<p>BBFILES = "/path/to/bbfiles/*.bb /path/to/appends/*.bbappend" </p>
</blockquote>
<p>BitBake parses each recipe and append file located with BBFILES and stores the values of various variables into the datastore.</p>
<p>For each file, a fresh copy of the base configuration is made, then the recipe is parsed line by line. Any inherit statements cause BitBake to find and then parse class files (.bbclass) using BBPATH as the search path. Finally, BitBake parses in order any append files found in BBFILES <br />
 By the time parsing is complete for a recipe, BitBake has a list of tasks that the recipe defines and a set of data consisting of keys and values as well as dependency information about the tasks.</p>
<p>BitBake does not need all of this information. It only needs a small subset of the information to make decisions about the recipe. Consequently, BitBake caches the values in which it is interested and does not store the rest of the information. Experience has shown it is faster to re-parse the metadata than to try and write it out to the disk and then reload it.</p>
<p>Where possible, subsequent BitBake commands reuse this cache of recipe information. The validity of this cache is determined by first computing a checksum of the base configuration data (see BB_HASHCONFIG_WHITELIST) and then checking if the checksum matches. If that checksum matches what is in the cache and the recipe and class files have not changed, Bitbake is able to use the cache. BitBake then reloads the cached information about the recipe instead of reparsing it from scratch.</p>
<p>Recipe file collections exist to allow the user to have multiple repositories of .bb files that contain the same exact package. For example, one could easily use them to make one's own local copy of an upstream repository, but with custom modifications that one does not want upstream. Here is an example:</p>
<blockquote class="doxtable">
<p>BBFILES = "/stuff/openembedded/*/*.bb /stuff/openembedded.modified/*/*.bb" </p>
</blockquote>
<blockquote class="doxtable">
<p>BBFILE_COLLECTIONS = "upstream local" </p>
</blockquote>
<blockquote class="doxtable">
<p>BBFILE_PATTERN_upstream = "^/stuff/openembedded/" </p>
</blockquote>
<blockquote class="doxtable">
<p>BBFILE_PATTERN_local = "^/stuff/openembedded.modified/" </p>
</blockquote>
<blockquote class="doxtable">
<p>BBFILE_PRIORITY_upstream = "5" </p>
</blockquote>
<blockquote class="doxtable">
<p>BBFILE_PRIORITY_local = "10" </p>
</blockquote>
<ul>
<li><b>Providers</b> Assuming BitBake has been instructed to execute a target and that all the recipe files have been parsed, BitBake starts to figure out how to build the target. BitBake looks through the PROVIDES list for each of the recipes. A PROVIDES list is the list of names by which the recipe can be known. Each recipe's PROVIDES list is created implicitly through the recipe's PN variable and explicitly through the recipe's PROVIDES variable, which is optional. When a recipe uses PROVIDES, that recipe's functionality can be found under an alternative name or names other than the implicit PN name. As an example, suppose a recipe named keyboard_1.0.bb contained the following:</li>
</ul>
<blockquote class="doxtable">
<p>PROVIDES += "fullkeyboard" </p>
</blockquote>
<p>The PROVIDES list for this recipe becomes "keyboard", which is implicit, and "fullkeyboard", which is explicit. Consequently, the functionality found in keyboard_1.0.bb can be found under two different names. <br />
</p><ul>
<li><p class="startli"><b>Dependencies</b> Each target BitBake builds consists of multiple tasks such as fetch, unpack, patch, configure, and compile. For best performance on multi-core systems, BitBake considers each task as an independent entity with its own set of dependencies.</p>
<p class="startli">Dependencies are defined through several variables. You can find information about variables BitBake uses in the Variables Glossary near the end of this manual. At a basic level, it is sufficient to know that BitBake uses the DEPENDS and RDEPENDS variables when calculating dependencies. <br />
</p>
</li>
<li><p class="startli"><b>The Task List</b> Based on the generated list of providers and the dependency information, BitBake can now calculate exactly what tasks it needs to run and in what order it needs to run them. The "Executing Tasks" section has more information on how BitBake chooses which task to execute next.</p>
<p class="startli">The build now starts with BitBake forking off threads up to the limit set in the BB_NUMBER_THREADS variable. BitBake continues to fork threads as long as there are tasks ready to run, those tasks have all their dependencies met, and the thread threshold has not been exceeded.</p>
<p class="startli">It is worth noting that you can greatly speed up the build time by properly setting the BB_NUMBER_THREADS variable.</p>
<p class="startli">As each task completes, a timestamp is written to the directory specified by the STAMP variable. On subsequent runs, BitBake looks in the build directory within tmp/stamps and does not rerun tasks that are already completed unless a timestamp is found to be invalid. Currently, invalid timestamps are only considered on a per recipe file basis. So, for example, if the configure stamp has a timestamp greater than the compile timestamp for a given target, then the compile task would rerun. Running the compile task again, however, has no effect on other providers that depend on that target.</p>
<p class="startli">The exact format of the stamps is partly configurable. In modern versions of BitBake, a hash is appended to the stamp so that if the configuration changes, the stamp becomes invalid and the task is automatically rerun. This hash, or signature used, is governed by the signature policy that is configured (see the "Checksums (Signatures)" section for information). It is also possible to append extra metadata to the stamp using the [stamp-extra-info] task flag. For example, OpenEmbedded uses this flag to make some tasks machine-specific. <br />
</p>
</li>
<li><p class="startli"><b>Executing Tasks</b> Tasks can be either a shell task or a Python task. For shell tasks, BitBake writes a shell script to ${T}/run.do_taskname.pid and then executes the script. The generated shell script contains all the exported variables, and the shell functions with all variables expanded. Output from the shell script goes to the file ${T}/log.do_taskname.pid. Looking at the expanded shell functions in the run file and the output in the log files is a useful debugging technique.</p>
<p class="startli">For Python tasks, BitBake executes the task internally and logs information to the controlling terminal. Future versions of BitBake will write the functions to files similar to the way shell tasks are handled. Logging will be handled in a way similar to shell tasks as well.</p>
<p class="startli">The order in which BitBake runs the tasks is controlled by its task scheduler. It is possible to configure the scheduler and define custom implementations for specific use cases. For more information, see these variables that control the behavior:</p><ul>
<li>BB_SCHEDULER</li>
<li>BB_SCHEDULERS</li>
</ul>
<p class="startli">It is possible to have functions run before and after a task's main function. This is done using the [prefuncs] and [postfuncs] flags of the task that lists the functions to run. </p>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="asrbuild_root.html">Build Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
